diff --git a/Makefile b/Makefile
index b4d3e3d..a053128 100644
--- a/Makefile
+++ b/Makefile
@@ -1,9 +1,9 @@
 # Makefile to build non-SGX-SDK-based RA-TLS client and server
 # programs.
 
-CFLAGS=-std=gnu99 -I. -I/opt/intel/sgxsdk/include -Ideps/local/include -fPIC
+CFLAGS=-std=gnu99 -I. -I/opt/intel/sgxsdk/include -Ideps/local/include -fPIC -Dsocket=seng_socket
 CFLAGSERRORS=-Wall -Wextra -Wwrite-strings -Wlogical-op -Wshadow -Werror
-CFLAGS+=$(CFLAGSERRORS) -g -O0 -DWOLFSSL_SGX_ATTESTATION -DWOLFSSL_CERT_EXT # -DDEBUG -DDYNAMIC_RSA
+CFLAGS+=$(CFLAGSERRORS) -g -O0 -DWOLFSSL_SGX_ATTESTATION -DWOLFSSL_CERT_EXT -Dsocket=seng_socket  # -DDEBUG -DDYNAMIC_RSA
 CFLAGS+=-DSGX_GROUP_OUT_OF_DATE
 
 LIBS=mbedtls/libra-attester.a \
@@ -12,7 +12,8 @@ LIBS=mbedtls/libra-attester.a \
 	wolfssl/libra-challenger.a \
 	wolfssl/libnonsdk-ra-attester.a \
 	wolfssl/libra-attester.a \
-	openssl/libra-challenger.a
+	openssl/libra-challenger.a \
+	openssl/libnonsdk-ra-attester.a
 
 .PHONY=all
 all: $(LIBS)
@@ -27,6 +28,8 @@ wolfssl-client-mutual: deps/wolfssl-examples/tls/client-tls.c ra_tls_options.c w
 
 mbedtls-client : deps/mbedtls/programs/ssl/ssl_client1.c mbedtls/libra-challenger.a
 	$(CC) -o $@ $(filter %.c, $^) $(CFLAGS) -Lmbedtls -Ldeps/local/lib -l:libra-challenger.a -l:libmbedtls.a -l:libmbedx509.a -l:libmbedcrypto.a
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output $@.manifest.sgx -exec $@ -manifest ssl-client.manifest
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output $@.token -sig $@.sig
 
 openssl-client : openssl-client.c openssl/libra-challenger.a
 	$(CC) -o $@ $(filter %.c, $^) $(CFLAGS) -Lopenssl -Ldeps/local/lib -l:libra-challenger.a -lssl -lcrypto -lm
@@ -61,8 +64,21 @@ wolfssl/libnonsdk-ra-attester.a : wolfssl wolfssl-ra.o wolfssl-ra-attester.o ias
 openssl/libra-challenger.a : openssl ra-challenger.o openssl-ra-challenger.o ias_sign_ca_cert.o
 	$(AR) rcs $@ $(filter %.o, $^)
 
+openssl/libnonsdk-ra-attester.a : openssl ra-challenger.o openssl-ra-attester.o ias-ra.o  nonsdk-ra-attester.o messages.pb-c.o sgx_report.o
+	$(AR) rcs $@ $(filter %.o, $^)
+
+
+openssl-ra-attester : openssl/libnonsdk-ra-attester.a ra_tls_options.c
+	$(CC) $(CFLAGS) -DOPENSSL $^ -o $@ -Ideps/local/include -Ldeps/local/lib -l:libcurl.a -l:libssl.a -l:libcrypto.a -l:libprotobuf-c.a -lm -l:libz.a -ldl
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-sign -libpal deps/graphene/Runtime/libpal-Linux-SGX.so -key deps/graphene/Pal/src/host/Linux-SGX/signer/enclave-key.pem -output $@.manifest.sgx -exec $@ -manifest ssl-server.manifest
+	deps/graphene/Pal/src/host/Linux-SGX/signer/pal-sgx-get-token -output $@.token -sig $@.sig
+
+openssl-ra-challenger : openssl/libra-challenger.a
+	$(CC) $(CFLAGS) -DOPENSSL $^ -o $@ -l:libcrypto.a -ldl
+
+
 SGX_GIT=deps/linux-sgx
-EPID_SDK=$(SGX_GIT)/external/epid-sdk-3.0.0
+EPID_SDK=$(SGX_GIT)/external/epid-sdk
 
 CFLAGS+=-I$(SGX_GIT)/common/inc/internal -I$(EPID_SDK) -I$(SGX_GIT)/common/inc
 
@@ -79,7 +95,7 @@ messages.pb-c.c messages.pb-c.h :
 
 SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include -Ideps/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 MBEDTLS_SSL_SERVER_SRC=deps/mbedtls/programs/ssl/ssl_server.c \
@@ -119,13 +135,13 @@ README.html : README.md
 
 SCONE_SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include -ISCONE/deps/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 SGXLKL_SSL_SERVER_INCLUDES=-I. -I/opt/intel/sgxsdk/include \
   -Isgxlkl/local/include \
 	-Ideps/linux-sgx/common/inc/internal \
-  -Ideps/linux-sgx/external/epid-sdk-3.0.0 \
+  -Ideps/linux-sgx/external/epid-sdk \
   -I$(SGX_GIT)/common/inc
 
 clients: mbedtls-client wolfssl-client openssl-client
@@ -155,3 +171,6 @@ mrproper: clean
 	$(RM) -r deps/curl deps/graphene deps/linux-sgx deps/linux-sgx-driver deps/mbedtls deps/wolfssl deps/wolfssl-examples
 
 .PHONY = all clean clients scone-server scone-wolfssl-ssl-server graphene-server sgxsdk-server mrproper
+
+
+
diff --git a/build.sh b/build.sh
index edd8446..a2e9a58 100755
--- a/build.sh
+++ b/build.sh
@@ -40,7 +40,8 @@ if [ ! -d mbedtls ] ; then
     patch -p1 < ../../mbedtls-enlarge-cert-write-buffer.patch
     patch -p1 < ../../mbedtls-ssl-server.patch
     patch -p1 < ../../mbedtls-client.patch
-    cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION" . || exit 1
+    cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" . || exit 1
+    #cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_PROGRAMS=off -DCMAKE_C_FLAGS="-fPIC -DMBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" . || exit 1
     make -j`nproc` || exit 1
     cmake -D CMAKE_INSTALL_PREFIX=$(readlink -f ../local) -P cmake_install.cmake || exit 1
     popd
@@ -78,36 +79,59 @@ if [[ ! -d curl && "$VARIANT" != "scone" && "$VARIANT" != "sgxlkl" ]] ; then
     pushd curl
     git checkout curl-7_47_0
     ./buildconf
-    ./configure --prefix=$(readlink -f ../local) --without-libidn --without-librtmp --without-libssh2 --without-libmetalink --without-libpsl --with-ssl # --enable-debug
-    make -j`nproc` || exit 1
+    ./configure --prefix=$(readlink -f ../local) --without-libidn --without-librtmp --without-libssh2 --without-libmetalink --without-libpsl --with-ssl # --with-mbedtlsssl # --enable-debug
+
+    pushd lib
+    make CFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" CXXFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" -j`nproc` || exit 1
+    make install || exit 1
+    popd
+
+    pushd include
+    make CFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" CXXFLAGS="-fPIC -Dsocket=seng_socket -Dgetaddrinfo=seng_getaddrinfo" -j`nproc` || exit 1
     make install || exit 1
     popd
+
+    popd
 fi
 
 # Linux SGX SDK code
 if [[ ! -d linux-sgx ]] ; then
     git clone https://github.com/01org/linux-sgx.git
     pushd linux-sgx
-    git checkout sgx_2.0
+    git checkout 0b493e04efe6e24d67ca6dcceb0d1af6f4010868 # same as host
+    #git checkout sgx_2.0
     popd
 fi
 
 if [[ ! -d linux-sgx-driver && $VARIANT == "graphene" ]] ; then
      git clone https://github.com/01org/linux-sgx-driver.git
      pushd linux-sgx-driver
-     git checkout sgx_driver_2.0
+     git checkout 2a509c203533f9950fa3459fe91864051bc021a2 # should be sth. between 2.1 and 2.2; same as host has
+     #git checkout sgx_driver_2.0
      popd
 fi
 
 if [[ ! -d graphene && $VARIANT == "graphene" ]] ; then
-    git clone --recursive https://github.com/oscarlab/graphene.git
+    git clone https://github.com/oscarlab/graphene.git
+    #git clone --recursive https://github.com/oscarlab/graphene.git
     pushd graphene
-    git checkout e01769337c38f67d7ccd7a7cadac4f9df0c6c65e
+    git checkout -b my_changes 58cb88d2c187358aad428b100d1ff444173e1a2b
+    patch -p1 < ../../pull_request_438.patch
+    patch -p1 < ../../graphene_patches.patch
+    #patch -p1 < ../../fixed_exitless_syscalls_pr405.patch
+    
+    git submodule update --init --recursive
+
+    #git checkout 54f767f7ba6e1766d64543a975763066f65037af # newest version (not still races > cf. pull requests)
+    #patch -p1 < ../../pull_request_438.patch
+
     openssl genrsa -3 -out Pal/src/host/Linux-SGX/signer/enclave-key.pem 3072
     # patch -p1 < ../../graphene-sgx-linux-driver-2.1.patch
     # The Graphene build process requires two inputs: (i) SGX driver directory, (ii) driver version.
     # Unfortunately, cannot use make -j`nproc` with Graphene's build process :(
-    printf "$(readlink -f ../linux-sgx-driver)\n2.0\n" | make SGX=1 || exit 1
+    printf "$(readlink -f ../linux-sgx-driver)\n2.1\n" | make SGX=1 || exit 1
+    #printf "$(readlink -f ../linux-sgx-driver)\n2.1\n" | make SGX=1 DEBUG=1 || exit 1
+
 
     # I prefer to have all dynamic libraries in one directory. This
     # reduces the effort in the Graphene-SGX manifest file.
@@ -116,7 +140,9 @@ if [[ ! -d graphene && $VARIANT == "graphene" ]] ; then
     ln -s /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 Runtime/
     ln -s /lib/x86_64-linux-gnu/libz.so.1 Runtime/
     ln -s /lib/x86_64-linux-gnu/libssl.so.1.0.0 Runtime/
-    
+   
+    cp -P ../../graphene_runtime_symlinks/* Runtime/
+
     popd
 fi
 
@@ -148,23 +174,25 @@ fi
 popd
 
 echo "Building non-SGX-SDK sample clients ..."
-make clients || exit 1
+make messages.pb-c.c messages.pb-c.h
+SGX_MODE=HW make mbedtls/libnonsdk-ra-attester.a mbedtls/libra-challenger.a mbedtls/libra-attester.a || exit 1
+#make clients || exit 1
 make clean || exit
 
-if [ $VARIANT == "scone" ] ; then
-    bash ./build-SCONE.sh || exit 1
-    make scone-server || exit 1
-fi
+#if [ $VARIANT == "scone" ] ; then
+#    bash ./build-SCONE.sh || exit 1
+#    make scone-server || exit 1
+#fi
 
-if [ $VARIANT == "sgxlkl" ] ; then
-    make -C sgxlkl -j2 || exit 1
-fi
+#if [ $VARIANT == "sgxlkl" ] ; then
+#    make -C sgxlkl -j2 || exit 1
+#fi
 
-if [ $VARIANT == "sgxsdk" ] ; then
-    make sgxsdk-server
-fi
+#if [ $VARIANT == "sgxsdk" ] ; then
+#    make sgxsdk-server
+#fi
 
-if [ $VARIANT == "graphene" ] ; then
-    make graphene-server
-    make wolfssl-client-mutual
-fi
+#if [ $VARIANT == "graphene" ] ; then
+#    make graphene-server
+#    make wolfssl-client-mutual
+#fi
diff --git a/copy_libs_helper.bash b/copy_libs_helper.bash
new file mode 100644
index 0000000..e6a0ab8
--- /dev/null
+++ b/copy_libs_helper.bash
@@ -0,0 +1,66 @@
+#!/bin/bash
+LIBS=(/lib/x86_64-linux-gnu/libc.so.6
+/lib/x86_64-linux-gnu/libcom_err.so.2
+/lib/x86_64-linux-gnu/libcrypt.so.1
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
+/lib/x86_64-linux-gnu/libdl.so.2
+/lib/x86_64-linux-gnu/libkeyutils.so.1
+/lib/x86_64-linux-gnu/libpthread.so.0
+/lib/x86_64-linux-gnu/libresolv.so.2
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
+/lib/x86_64-linux-gnu/libz.so.1
+/usr/lib/x86_64-linux-gnu/libasn1.so.8
+/usr/lib/x86_64-linux-gnu/libcurl.so.4
+/usr/lib/x86_64-linux-gnu/libffi.so.6
+/usr/lib/x86_64-linux-gnu/libgmp.so.10
+/usr/lib/x86_64-linux-gnu/libgnutls.so.30
+/usr/lib/x86_64-linux-gnu/libgssapi.so.3
+/usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2
+/usr/lib/x86_64-linux-gnu/libhcrypto.so.4
+/usr/lib/x86_64-linux-gnu/libheimbase.so.1
+/usr/lib/x86_64-linux-gnu/libheimntlm.so.0
+/usr/lib/x86_64-linux-gnu/libhogweed.so.4
+/usr/lib/x86_64-linux-gnu/libhx509.so.5
+/usr/lib/x86_64-linux-gnu/libidn.so.11
+/usr/lib/x86_64-linux-gnu/libk5crypto.so.3
+/usr/lib/x86_64-linux-gnu/libkrb5.so.26
+/usr/lib/x86_64-linux-gnu/libkrb5.so.3
+/usr/lib/x86_64-linux-gnu/libkrb5support.so.0
+/usr/lib/x86_64-linux-gnu/liblber-2.4.so.2
+/usr/lib/x86_64-linux-gnu/libldap_r-2.4.so.2
+/usr/lib/x86_64-linux-gnu/libnettle.so.6
+/usr/lib/x86_64-linux-gnu/libp11-kit.so.0
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1
+/usr/lib/x86_64-linux-gnu/libroken.so.18
+/usr/lib/x86_64-linux-gnu/librtmp.so.1
+/usr/lib/x86_64-linux-gnu/libsasl2.so.2
+/usr/lib/x86_64-linux-gnu/libsqlite3.so.0
+/usr/lib/x86_64-linux-gnu/libtasn1.so.6
+/usr/lib/x86_64-linux-gnu/libwind.so.0)
+
+LIBS_NEW=(/home/encl-dev/sgx-ra-tls/deps/local/lib/libcurl.so.4
+/lib/x86_64-linux-gnu/libc.so.6
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
+/lib/x86_64-linux-gnu/libdl.so.2
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
+/lib/x86_64-linux-gnu/libz.so.1
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1)
+
+for l in ${LIBS[@]}
+do
+                echo "Link: deps/graphene/Runtime/`basename ${l}`"
+        if [ -e "deps/graphene/Runtime/`basename ${l}`" ]
+        then
+                echo "Link for ${l} already exists"
+        else
+                echo "${l}"
+                ln -s "${l}" deps/graphene/Runtime/
+        fi
+done
+
+echo -e "\n\n"
+
+for l in ${LIBS[@]}
+do
+		echo "sgx.trusted_files.`basename ${l} | sed -rn 's/^(lib.*).so.*$/\1/p' | tr -d '\-_.'` = file:deps/graphene/Runtime/`basename ${l}`"
+done
diff --git a/graphene_runtime_symlinks/crt1.o b/graphene_runtime_symlinks/crt1.o
new file mode 120000
index 0000000..aabb693
--- /dev/null
+++ b/graphene_runtime_symlinks/crt1.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crt1.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/crti.o b/graphene_runtime_symlinks/crti.o
new file mode 120000
index 0000000..73f270e
--- /dev/null
+++ b/graphene_runtime_symlinks/crti.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crti.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/crtn.o b/graphene_runtime_symlinks/crtn.o
new file mode 120000
index 0000000..150ac50
--- /dev/null
+++ b/graphene_runtime_symlinks/crtn.o
@@ -0,0 +1 @@
+../LibOS/glibc-build/csu/crtn.o
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/ld-linux-x86-64.so.2 b/graphene_runtime_symlinks/ld-linux-x86-64.so.2
new file mode 120000
index 0000000..1ff6f8e
--- /dev/null
+++ b/graphene_runtime_symlinks/ld-linux-x86-64.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/elf/ld-linux-x86-64.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libapp_bench_onload.so b/graphene_runtime_symlinks/libapp_bench_onload.so
new file mode 120000
index 0000000..5c2c604
--- /dev/null
+++ b/graphene_runtime_symlinks/libapp_bench_onload.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libapp_bench_onload.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libbsd.so.0 b/graphene_runtime_symlinks/libbsd.so.0
new file mode 120000
index 0000000..f85caa0
--- /dev/null
+++ b/graphene_runtime_symlinks/libbsd.so.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libbsd.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libc.so b/graphene_runtime_symlinks/libc.so
new file mode 120000
index 0000000..ddc0005
--- /dev/null
+++ b/graphene_runtime_symlinks/libc.so
@@ -0,0 +1 @@
+../LibOS/glibc-build/libc.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libc.so.6 b/graphene_runtime_symlinks/libc.so.6
new file mode 120000
index 0000000..1251dd7
--- /dev/null
+++ b/graphene_runtime_symlinks/libc.so.6
@@ -0,0 +1 @@
+../LibOS/glibc-build/libc.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcom_err.so.2 b/graphene_runtime_symlinks/libcom_err.so.2
new file mode 120000
index 0000000..3c692fe
--- /dev/null
+++ b/graphene_runtime_symlinks/libcom_err.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcom_err.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcrypt.so.1 b/graphene_runtime_symlinks/libcrypt.so.1
new file mode 120000
index 0000000..648db5b
--- /dev/null
+++ b/graphene_runtime_symlinks/libcrypt.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcrypt.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcrypto.so.1.0.0 b/graphene_runtime_symlinks/libcrypto.so.1.0.0
new file mode 120000
index 0000000..3d817f9
--- /dev/null
+++ b/graphene_runtime_symlinks/libcrypto.so.1.0.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libcurl.so b/graphene_runtime_symlinks/libcurl.so
new file mode 120000
index 0000000..fa729fc
--- /dev/null
+++ b/graphene_runtime_symlinks/libcurl.so
@@ -0,0 +1 @@
+/home/encl-dev/benchmarking/curl-7.47.0/build/lib/libcurl.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libdl.so.2 b/graphene_runtime_symlinks/libdl.so.2
new file mode 120000
index 0000000..1f235e1
--- /dev/null
+++ b/graphene_runtime_symlinks/libdl.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/dlfcn/libdl.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libedit.so.2 b/graphene_runtime_symlinks/libedit.so.2
new file mode 120000
index 0000000..9c08931
--- /dev/null
+++ b/graphene_runtime_symlinks/libedit.so.2
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libedit.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libexpat.so.1 b/graphene_runtime_symlinks/libexpat.so.1
new file mode 120000
index 0000000..d774768
--- /dev/null
+++ b/graphene_runtime_symlinks/libexpat.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libexpat.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgcc_s.so.1 b/graphene_runtime_symlinks/libgcc_s.so.1
new file mode 120000
index 0000000..2e4aad4
--- /dev/null
+++ b/graphene_runtime_symlinks/libgcc_s.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libgcc_s.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgcrypt.so.20 b/graphene_runtime_symlinks/libgcrypt.so.20
new file mode 120000
index 0000000..5be3209
--- /dev/null
+++ b/graphene_runtime_symlinks/libgcrypt.so.20
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libgcrypt.so.20
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgnutls.so.30 b/graphene_runtime_symlinks/libgnutls.so.30
new file mode 120000
index 0000000..81ee7bd
--- /dev/null
+++ b/graphene_runtime_symlinks/libgnutls.so.30
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libgnutls.so.30
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libgssapi_krb5.so.2 b/graphene_runtime_symlinks/libgssapi_krb5.so.2
new file mode 120000
index 0000000..7170272
--- /dev/null
+++ b/graphene_runtime_symlinks/libgssapi_krb5.so.2
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libiperf.so.0 b/graphene_runtime_symlinks/libiperf.so.0
new file mode 120000
index 0000000..b9b1284
--- /dev/null
+++ b/graphene_runtime_symlinks/libiperf.so.0
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libiperf.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libk5crypto.so.3 b/graphene_runtime_symlinks/libk5crypto.so.3
new file mode 120000
index 0000000..f76bb95
--- /dev/null
+++ b/graphene_runtime_symlinks/libk5crypto.so.3
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libk5crypto.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkeyutils.so.1 b/graphene_runtime_symlinks/libkeyutils.so.1
new file mode 120000
index 0000000..48434f3
--- /dev/null
+++ b/graphene_runtime_symlinks/libkeyutils.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libkeyutils.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkrb5.so.3 b/graphene_runtime_symlinks/libkrb5.so.3
new file mode 120000
index 0000000..cd3065b
--- /dev/null
+++ b/graphene_runtime_symlinks/libkrb5.so.3
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libkrb5.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libkrb5support.so.0 b/graphene_runtime_symlinks/libkrb5support.so.0
new file mode 120000
index 0000000..9290d77
--- /dev/null
+++ b/graphene_runtime_symlinks/libkrb5support.so.0
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libkrb5support.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/liblibos.so.1 b/graphene_runtime_symlinks/liblibos.so.1
new file mode 120000
index 0000000..c40d629
--- /dev/null
+++ b/graphene_runtime_symlinks/liblibos.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/libos/liblibos.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/liblwip.so b/graphene_runtime_symlinks/liblwip.so
new file mode 120000
index 0000000..50155c0
--- /dev/null
+++ b/graphene_runtime_symlinks/liblwip.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/liblwip.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libm.so.6 b/graphene_runtime_symlinks/libm.so.6
new file mode 120000
index 0000000..bd97296
--- /dev/null
+++ b/graphene_runtime_symlinks/libm.so.6
@@ -0,0 +1 @@
+../LibOS/glibc-build/math/libm.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnsl.so.1 b/graphene_runtime_symlinks/libnsl.so.1
new file mode 120000
index 0000000..d0c6282
--- /dev/null
+++ b/graphene_runtime_symlinks/libnsl.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnsl.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_compat.so.2 b/graphene_runtime_symlinks/libnss_compat.so.2
new file mode 120000
index 0000000..71b8768
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_compat.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_compat.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_db.so.2 b/graphene_runtime_symlinks/libnss_db.so.2
new file mode 120000
index 0000000..c7dd4b6
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_db.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/nss/libnss_db.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_dns.so.2 b/graphene_runtime_symlinks/libnss_dns.so.2
new file mode 120000
index 0000000..44125e2
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_dns.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/resolv/libnss_dns.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_files.so.2 b/graphene_runtime_symlinks/libnss_files.so.2
new file mode 120000
index 0000000..6f8e598
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_files.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_files.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libnss_nis.so.2 b/graphene_runtime_symlinks/libnss_nis.so.2
new file mode 120000
index 0000000..908d218
--- /dev/null
+++ b/graphene_runtime_symlinks/libnss_nis.so.2
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libnss_nis.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libpcre.so.3 b/graphene_runtime_symlinks/libpcre.so.3
new file mode 120000
index 0000000..45b27dd
--- /dev/null
+++ b/graphene_runtime_symlinks/libpcre.so.3
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libpcre.so.3
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libprotobuf-c.so.1 b/graphene_runtime_symlinks/libprotobuf-c.so.1
new file mode 120000
index 0000000..08b1380
--- /dev/null
+++ b/graphene_runtime_symlinks/libprotobuf-c.so.1
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libprotobuf-c.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libprotobuf.so.9 b/graphene_runtime_symlinks/libprotobuf.so.9
new file mode 120000
index 0000000..c55c411
--- /dev/null
+++ b/graphene_runtime_symlinks/libprotobuf.so.9
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libprotobuf.so.9
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libpthread.so.0 b/graphene_runtime_symlinks/libpthread.so.0
new file mode 120000
index 0000000..12e82e1
--- /dev/null
+++ b/graphene_runtime_symlinks/libpthread.so.0
@@ -0,0 +1 @@
+../LibOS/glibc-build/nptl/libpthread.so.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libreadline.so.6 b/graphene_runtime_symlinks/libreadline.so.6
new file mode 120000
index 0000000..768b9cb
--- /dev/null
+++ b/graphene_runtime_symlinks/libreadline.so.6
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libreadline.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libresolv.so.2 b/graphene_runtime_symlinks/libresolv.so.2
new file mode 120000
index 0000000..b9b0b53
--- /dev/null
+++ b/graphene_runtime_symlinks/libresolv.so.2
@@ -0,0 +1 @@
+../LibOS/glibc-build/resolv/libresolv.so.2
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/librt.so.1 b/graphene_runtime_symlinks/librt.so.1
new file mode 120000
index 0000000..2d42a77
--- /dev/null
+++ b/graphene_runtime_symlinks/librt.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/rt/librt.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libselinux.so.1 b/graphene_runtime_symlinks/libselinux.so.1
new file mode 120000
index 0000000..4bfd214
--- /dev/null
+++ b/graphene_runtime_symlinks/libselinux.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libselinux.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so b/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so
new file mode 120000
index 0000000..600d16d
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_mbench_ossl_double_tunnel_netif.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_mbench_ossl_double_tunnel_netif.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_onload.so b/graphene_runtime_symlinks/libseng_ossl_double_onload.so
new file mode 120000
index 0000000..5e1b1d2
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_onload.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_onload.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so b/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so
new file mode 120000
index 0000000..d6909f4
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_onload_finegrained_mbench.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_onload_finegrained_mbench.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so b/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so
new file mode 120000
index 0000000..620fb4c
--- /dev/null
+++ b/graphene_runtime_symlinks/libseng_ossl_double_tunnel_netif.so
@@ -0,0 +1 @@
+/home/encl-dev/client_enclave/lwip_based_client_lib/build/dtls_tunnel_netif/src/libseng_ossl_double_tunnel_netif.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libsgx_uae_service.so b/graphene_runtime_symlinks/libsgx_uae_service.so
new file mode 120000
index 0000000..f671e69
--- /dev/null
+++ b/graphene_runtime_symlinks/libsgx_uae_service.so
@@ -0,0 +1 @@
+/usr/lib/libsgx_uae_service.so
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libssl.so.1.0.0 b/graphene_runtime_symlinks/libssl.so.1.0.0
new file mode 120000
index 0000000..f5d9aa3
--- /dev/null
+++ b/graphene_runtime_symlinks/libssl.so.1.0.0
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libssl.so.1.0.0
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libstdc++.so.6 b/graphene_runtime_symlinks/libstdc++.so.6
new file mode 120000
index 0000000..3ac50bb
--- /dev/null
+++ b/graphene_runtime_symlinks/libstdc++.so.6
@@ -0,0 +1 @@
+/usr/lib/x86_64-linux-gnu/libstdc++.so.6
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libthread_db.so.1 b/graphene_runtime_symlinks/libthread_db.so.1
new file mode 120000
index 0000000..b25a306
--- /dev/null
+++ b/graphene_runtime_symlinks/libthread_db.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/nptl_db/libthread_db.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libtinfo.so.5 b/graphene_runtime_symlinks/libtinfo.so.5
new file mode 120000
index 0000000..c4803c3
--- /dev/null
+++ b/graphene_runtime_symlinks/libtinfo.so.5
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libtinfo.so.5
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libutil.so.1 b/graphene_runtime_symlinks/libutil.so.1
new file mode 120000
index 0000000..c819eda
--- /dev/null
+++ b/graphene_runtime_symlinks/libutil.so.1
@@ -0,0 +1 @@
+../LibOS/glibc-build/login/libutil.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/libz.so.1 b/graphene_runtime_symlinks/libz.so.1
new file mode 120000
index 0000000..c801c65
--- /dev/null
+++ b/graphene_runtime_symlinks/libz.so.1
@@ -0,0 +1 @@
+/lib/x86_64-linux-gnu/libz.so.1
\ No newline at end of file
diff --git a/graphene_runtime_symlinks/pal_gdb-Linux-SGX b/graphene_runtime_symlinks/pal_gdb-Linux-SGX
new file mode 120000
index 0000000..36a8bea
--- /dev/null
+++ b/graphene_runtime_symlinks/pal_gdb-Linux-SGX
@@ -0,0 +1 @@
+../Pal/src/host/Linux-SGX/debugger/gdb
\ No newline at end of file
diff --git a/ias-ra.c b/ias-ra.c
index 70af519..c23c50f 100644
--- a/ias-ra.c
+++ b/ias-ra.c
@@ -16,6 +16,8 @@
 #include "ra-attester.h"
 #include "ias-ra.h"
 
+//#define DEBUG
+
 struct buffer_and_size {
     char* data;
     size_t len;
@@ -72,7 +74,7 @@ void extract_certificates_from_response_header
 )
 {
     // Locate x-iasreport-signature HTTP header field in the response.
-    const char response_header_name[] = "x-iasreport-signing-certificate: ";
+    const char response_header_name[] = "X-IASReport-Signing-Certificate: ";
     char *field_begin = memmem(header,
                                header_len,
                                response_header_name,
@@ -144,12 +146,17 @@ void parse_response_header
     uint32_t* signature_size
 )
 {
-    const char sig_tag[] = "x-iasreport-signature: ";
+    const char sig_tag[] = "X-IASReport-Signature: ";
     char* sig_begin = memmem((const char*) header,
                              header_len,
                              sig_tag,
                              strlen(sig_tag));
-    assert(sig_begin != NULL);
+    /* This one has failed sometimes in the past, which results in a freeze. So call exit(1) instead */
+    //assert(sig_begin != NULL);
+    if (sig_begin == NULL) {
+        fprintf(stderr, "error in ias-ra.c:154@parse_response_header: `sig_begin != NULL' failed\n");
+        exit(1);
+    }
     sig_begin += strlen(sig_tag);
     char* sig_end = memmem(sig_begin,
                            header_len - (sig_begin - header),
@@ -182,31 +189,52 @@ void obtain_attestation_verification_report
 
     curl = curl_easy_init();
     if(curl) {
-        // curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
+#ifdef DEBUG
+        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
+#endif
         curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
         char url[512];
-        ret = snprintf(url, sizeof(url), "https://%s/attestation/sgx/v2/report",
+        ret = snprintf(url, sizeof(url), "https://%s/sgx/dev/attestation/v3/report",
                            opts->ias_server);
         assert(ret < (int) sizeof(url));
-        curl_easy_setopt(curl, CURLOPT_URL, url);
-        curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
-        curl_easy_setopt(curl, CURLOPT_SSLCERT, opts->ias_cert_file);
-        curl_easy_setopt(curl, CURLOPT_SSLKEY, opts->ias_key_file);
-        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
-        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
+        ret = curl_easy_setopt(curl, CURLOPT_URL, url);
+        assert(ret == CURLE_OK);
+        ret = curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
+        assert(ret == CURLE_OK);
+        ret = curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
+        assert(ret == CURLE_OK);
     
         struct curl_slist *headers = NULL;
         headers = curl_slist_append(headers, "Content-Type: application/json");
 
+        // new client authentication method
+        headers = curl_slist_append(headers, "Ocp-Apim-Subscription-Key: YYY");
+
         const char json_template[] = "{\"isvEnclaveQuote\":\"%s\"}";
         unsigned char quote_base64[quote_size * 2];
         char json[quote_size * 2];
 
+        memset(quote_base64, 0, sizeof(quote_base64));
+        memset(json, 0, sizeof(json));
+
         ret = EVP_EncodeBlock(quote_base64, (unsigned char*) quote, quote_size);
          // +1 since EVP_EncodeBlock() adds \0 to the output.
         assert((size_t) ret + 1 <= sizeof(quote_base64));
 
         snprintf(json, sizeof(json), json_template, quote_base64);
+
+#ifdef DEBUG
+        printf("Going to send following header:\n%s\n", headers->data);
+        printf("%s\n", headers->next->data);
+        printf("Going to send following json body:\n%s\n", json);
+
+        // == 1510 which is the shown Content-Length
+        printf("json body strlen: %ld\n", strlen(json));
+        // > 2k
+        printf("sizeof: %ld\n", sizeof(json));
+        printf("other stuff: %ld\n", strlen("{\"isvEnclaveQuote\":\"\"}"));
+        fflush(stdout);
+#endif
     
         curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json);
@@ -225,8 +253,10 @@ void obtain_attestation_verification_report
             printf("curl_easy_perform= %d\n", res);
         }
         
-        /* printf("%s", header.data); */
-        /* printf("body= %s", body.data); */
+#ifdef DEBUG
+        printf("%s", header.data);
+        printf("body= %s", body.data);
+#endif
 
         parse_response_header(header.data, header.len,
                               attn_report->ias_report_signature,
diff --git a/mbedtls-ra-attester.c b/mbedtls-ra-attester.c
index 679bfed..b24d182 100644
--- a/mbedtls-ra-attester.c
+++ b/mbedtls-ra-attester.c
@@ -22,6 +22,10 @@
 #include "ra_private.h"
 #include "mbedtls-ra-attester.h"
 
+#include <sys/time.h>
+
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
 static const size_t SHA256_DIGEST_SIZE = 32;
 
 static
@@ -70,9 +74,10 @@ void generate_x509
     mbedtls_ctr_drbg_init( &ctr_drbg );
     
     const char *pers = "crt example app";
-    assert(0 == mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
+    int r = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                                        (const unsigned char *) pers,
-                                       strlen( pers ) ));
+                                       strlen( pers ) );
+    assert ( r == 0 );
 
     int ret;
     mbedtls_x509write_crt_init(&writecrt);
@@ -174,8 +179,111 @@ void create_x509
 
     do_remote_attestation(&report_data, opts, &attestation_report);
 
+    /* TODO:    the protobuf-based communication is NOT SECURE AT ALL
+     *
+     * CORRECTION:
+     *      1. the target_info is used by EREPORT to sign the report, s.t. that
+     *          the target enclave can check that the report was indeed created
+     *          by EREPORT with target_info matching the checking enclave
+     *
+     *      2. EREPORT's RCX is the address to the userdata AND the report
+     *          contains a MAC (!), s.t. it is NOT POSSIBLE for the attacker to
+     *          replace the userdata w/o failing the report integrity checks
+     *          done by the quoting enclave
+     *
+     *      ===> attacker will not be able to mix-and-match Client Enclave
+     *          measurement part of EREPORT with its own public-key for privilege
+     *          escalation hijacking;
+     *
+     *      ===> though might still DoS the connection, hijack the connection
+     *          with own measurements / keys, or that of an older/other LEAKED
+     *          client enclave instance, and eavesdrop at the connection
+     *
+     *          ALSO: unsure whether other attacks are still possible in this
+     *          scenario
+     *
+     *      --> attacker could also privilege-drop the client enclave w/o complete
+     *          DoS by replacing the report with an other valid report including
+     *          the public key of the client enclave;
+     *
+     *          BUT: by checking report data of IAS against own EREPORT result,
+     *          the client would be able to detect such manipulations;
+     *          also it would be just another kind of partial DoS attack which
+     *          we anyway keep out of the threat model
+     *
+     *      Keeping the private key only in the client enclave and using certificate pinning
+     *      w.r.t. the middlebox certificate prevents eavesdropping attacks on the connection
+     *      between Client Enclave and Middlbox Server.
+     *
+     *      HOWEVER:    the malicious host can masquerade successfully as client enclave when
+     *          connecting to the Middlebox Server, because as long as the connection between
+     *          Client Enclave and Quoting Enclave is NOT SECURED via LOCAL ATTESTATION + secret
+     *          exchange,
+     *          the attacker is able to intercept the Report during Quote Request, replace the
+     *          public-key with its own one, intercept the resulting Quote, submit it to IAS
+     *          and then create a valid certificate with the IAS report verifying the measurements
+     *          of the client enclave bound to the attacker's own private-public key pair.
+     *
+     *          => The attacker can then successfully connect to the Middlebox Server and thereby
+     *          gain the network privileges of the client enclave.
+     *
+     *          The root of the problem is the missing authentication of the Quoting Encalve
+     *          in the NON-SDK Protobuf-based Quote creation process.
+     *
+     *      Note that afterwards the attacker could still tamper with the client certificate on
+     *      the fly, bcs for TLS <= 1.2 the certificate is sent in plaintext, BUT IAS report
+     *      manipulation can be detected via the IAS report signature check,
+     *      and IAS report replacement will NOT help, bcs:
+     *          -> the attacker doesn't know the client private key, so cannot eavesdrop
+     *          -> IAS with attacker's public key can only have the enclave measurements of
+     *              an ATTACKER CONTROLLED enclave, so no privilege escalation possible
+     *
+     *      CAUTION/WARNING:    confused deputy attacks still possible; mis-progammed enclaves
+     *              might leak their reports or make connections on behalf of an attacker which
+     *              could lead to classical privilege escalation attacks via confused deputies
+     *              as for instance in Android
+     *          -> use existing approaches to check statically that EREPORT data is not leaked
+     *          -> adopt existing ideas to find a way of handling confused deputy problem;
+     *              (PROBLEM: no secure I/O via SGX, which TZ can provide; hacky SMM approach?
+     *                  but then VT-d/IOMMU can again be ugly; lightweight(!) Hypervisor support?)
+     *
+     *
+     *      ==> solution will require Local Attestation-based secure connection between client
+     *          enclave and quoting enclave either now, or when integrating it into Graphene /
+     *          library layer
+     *
+     *      Notes:  Graphene already has some Local Attestation code for Graphene<->Graphene
+     *              bootstrapping;
+     *              Quoting Enclave MUST HAVE some kind of Local Attestation / secure channel
+     *              API used by the SDK, bcs otherwise I cannot see how such an attack would
+     *              be prevented.
+     */
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     generate_x509(cert, key, &attestation_report);
-    
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif 
+
+
     /* printf_sgx("attestation_report.ias_report=\n"); */
     /* printf_sgx("%.s", attestation_report.ias_report_len, attestation_report.ias_report); */
 }
@@ -188,6 +296,16 @@ void mbedtls_create_key_and_x509
     const struct ra_tls_options* opts
 )
 {
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_seed = 1;
+        struct timeval listen_tv_start_seed , listen_tv_end_seed ;
+        if( gettimeofday(&listen_tv_start_seed , NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_seed  = 0;
+        }
+#endif
     int ret;
 
     mbedtls_ctr_drbg_context ctr_drbg;
@@ -196,21 +314,57 @@ void mbedtls_create_key_and_x509
     mbedtls_entropy_context entropy;
     mbedtls_entropy_init( &entropy );
 
-    const char* pers = "deadbeef";
-    ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
-                                (const unsigned char *) pers,
-                                strlen(pers));
+    //const char* pers = "deadbeef";
+    ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0);
+//                                (const unsigned char *) pers,
+//                                strlen(pers));
     assert(ret == 0);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_seed == 1 ) {
+            if ( gettimeofday(&listen_tv_end_seed, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_seed.tv_sec - listen_tv_start_seed.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_seed.tv_usec - listen_tv_start_seed.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif
 
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     mbedtls_pk_setup(key, mbedtls_pk_info_from_type(MBEDTLS_PK_RSA));
 
     mbedtls_rsa_init((mbedtls_rsa_context*)key->pk_ctx,
                      MBEDTLS_RSA_PKCS_V15, 0);
-    
+
     ret = mbedtls_rsa_gen_key((mbedtls_rsa_context*)key->pk_ctx,
                               mbedtls_ctr_drbg_random, &ctr_drbg, 2048, 65537);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fflush(stdout);
+            }
+        }
+#endif
+
     assert(ret == 0);
-    
+
     create_x509(key, cert, opts);
 }
 
diff --git a/mbedtls-ra-challenger.c b/mbedtls-ra-challenger.c
index ecee76a..d225ce2 100644
--- a/mbedtls-ra-challenger.c
+++ b/mbedtls-ra-challenger.c
@@ -24,7 +24,7 @@ extern unsigned char ias_sign_ca_cert_der[];
 extern unsigned int ias_sign_ca_cert_der_len;
 
 static
-void extract_x509_extension
+int extract_x509_extension
 (
     uint8_t* ext,
     int ext_len,
@@ -38,60 +38,78 @@ void extract_x509_extension
     uint8_t* base64_data;
     size_t base64_data_len;
     
-    find_oid(ext, ext_len, oid, oid_len,
-             &base64_data, &base64_data_len);
+    if (find_oid(ext, ext_len, oid, oid_len,
+                 &base64_data, &base64_data_len) != 0) {
+        return 1;
+    }
     
     assert(base64_data != NULL);
-    assert(base64_data_len <= data_max_len);
+    
+    if(!(base64_data_len <= data_max_len)) {
+        return 1;
+    }
 
     size_t out_len;
-    int ret;
-    ret = mbedtls_base64_decode(data,
+    if (mbedtls_base64_decode(data,
                                 data_max_len,
                                 &out_len,
                                 base64_data,
-                                base64_data_len);
+                              base64_data_len) != 0) {
+        return 1;
+    }
 
-    assert(ret == 0);
-    assert(out_len <= UINT32_MAX);
+    if (!(out_len <= UINT32_MAX)) {
+        return 1;
+    }
     *data_len = (uint32_t) out_len;
+    return 0;
 }
 
 /* Extract extensions from X509 and decode base64. */
 static
-void extract_x509_extensions
+int extract_x509_extensions
 (
     uint8_t* ext,
     int ext_len,
     attestation_verification_report_t* attn_report
 )
 {
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_response_body_oid, ias_oid_len,
                            attn_report->ias_report,
                            &attn_report->ias_report_len,
-                           sizeof(attn_report->ias_report));
+                               sizeof(attn_report->ias_report)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_root_cert_oid, ias_oid_len,
                            attn_report->ias_sign_ca_cert,
                            &attn_report->ias_sign_ca_cert_len,
-                           sizeof(attn_report->ias_sign_ca_cert));
+                               sizeof(attn_report->ias_sign_ca_cert)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_leaf_cert_oid, ias_oid_len,
                            attn_report->ias_sign_cert,
                            &attn_report->ias_sign_cert_len,
-                           sizeof(attn_report->ias_sign_cert));
+                               sizeof(attn_report->ias_sign_cert)) != 0) {
+        return 1;
+    }
 
-    extract_x509_extension(ext, ext_len,
+    if (extract_x509_extension(ext, ext_len,
                            ias_report_signature_oid, ias_oid_len,
                            attn_report->ias_report_signature,
                            &attn_report->ias_report_signature_len,
-                           sizeof(attn_report->ias_report_signature));
+                               sizeof(attn_report->ias_report_signature)) != 0) {
+        return 1;
+    }
+    
+    return 0;
 }
 
-void get_quote_from_report(const uint8_t* report /* in */,
+int get_quote_from_report(const uint8_t* report /* in */,
                            const int report_len  /* in */,
                            sgx_quote_t* quote)
 {
@@ -99,23 +117,35 @@ void get_quote_from_report(const uint8_t* report /* in */,
 
     const char* json_string = "\"isvEnclaveQuoteBody\":\"";
     char* p_begin = strstr((const char*) report, json_string);
-    assert(p_begin != NULL);
+    if (p_begin == NULL) {
+        return 1;
+    }
     p_begin += strlen(json_string);
     const char* p_end = strchr(p_begin, '"');
-    assert(p_end != NULL);
+    if (p_end == NULL) {
+        return 1;
+    }
 
     const int quote_base64_len = p_end - p_begin;
     uint8_t* quote_bin = malloc(quote_base64_len);
+    
+    if (quote_bin == NULL) {
+        return 1;
+    }
+    
     size_t quote_bin_len = quote_base64_len;
 
-    mbedtls_base64_decode(quote_bin, quote_base64_len,
-                          &quote_bin_len,
-                          (unsigned char*) p_begin, quote_base64_len);
+    if (mbedtls_base64_decode(quote_bin, quote_base64_len,
+                              &quote_bin_len, (unsigned char*) p_begin, quote_base64_len) != 0
+        || !(quote_bin_len <= sizeof(sgx_quote_t))) {
+        free (quote_bin);
+        return 1;
+    }
 
-    assert(quote_bin_len <= sizeof(sgx_quote_t));
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+    return 0;
 }
 
 static
@@ -233,6 +263,10 @@ int verify_ias_report_signature
                                    MBEDTLS_MD_SHA256, 0,
                                    sha256,
                                    attn_report->ias_report_signature);
+
+    // Prevent memory leak!
+    mbedtls_x509_crt_free(&cert);
+
     return ret;
 }
 
@@ -258,7 +292,11 @@ int verify_ias_certificate_chain(attestation_verification_report_t* attn_report)
     ret = mbedtls_x509_crt_verify(&cert, &cacert, NULL, NULL, &flags,
                                   NULL, NULL);
     assert(ret == 0);
-    
+   
+    // Prevent memory leaks!
+    mbedtls_x509_crt_free(&cacert);
+    mbedtls_x509_crt_free(&cert);
+
     return ret;
 }
 
@@ -276,27 +314,40 @@ int verify_sgx_cert_extensions
     mbedtls_x509_crt crt;
     mbedtls_x509_crt_init(&crt);
     
-    int ret;
-    ret = mbedtls_x509_crt_parse(&crt, der_crt, der_crt_len);
+    if (mbedtls_x509_crt_parse(&crt, der_crt, der_crt_len) != 0) {
+            return 1;
+    }
     
-    extract_x509_extensions(crt.v3_ext.p,
+    if (extract_x509_extensions(crt.v3_ext.p,
                             crt.v3_ext.len,
-                            &attn_report);
-
-    ret = verify_ias_certificate_chain(&attn_report);
-    assert(ret == 0);
-
-    ret = verify_ias_report_signature(&attn_report);
-    assert(ret == 0);
+                                &attn_report) != 0) {
+        goto error;
+    }
 
+    if(verify_ias_certificate_chain(&attn_report) != 0) {
+        goto error;
+    }
+    
+    if(verify_ias_report_signature(&attn_report) != 0) {
+        goto error;
+    }
+    
     sgx_quote_t quote = {0, };
-    get_quote_from_report(attn_report.ias_report,
+    if (get_quote_from_report(attn_report.ias_report,
                           attn_report.ias_report_len,
-                          &quote);
-    ret = verify_report_data_against_server_cert(&crt, &quote);
-    assert(ret == 0);
+                              &quote) != 0) {
+        goto error;
+    }
+    
+    
+    if(verify_report_data_against_server_cert(&crt, &quote) != 0) {
+        goto error;
+    }
 
     mbedtls_x509_crt_free(&crt);
-
     return 0;
+        
+error:
+    mbedtls_x509_crt_free(&crt);
+    return 1;
 }
diff --git a/my_etc_files/group b/my_etc_files/group
new file mode 120000
index 0000000..3075d99
--- /dev/null
+++ b/my_etc_files/group
@@ -0,0 +1 @@
+/etc/group
\ No newline at end of file
diff --git a/my_etc_files/host.conf b/my_etc_files/host.conf
new file mode 100644
index 0000000..d1a59f7
--- /dev/null
+++ b/my_etc_files/host.conf
@@ -0,0 +1 @@
+multi on
diff --git a/my_etc_files/hosts b/my_etc_files/hosts
new file mode 100644
index 0000000..4ddb3fd
--- /dev/null
+++ b/my_etc_files/hosts
@@ -0,0 +1,14 @@
+127.0.0.1 localhost
+::1 localhost ip6-localhost ip6-loopback
+fe00::0	ip6-localnet
+ff00::0	ip6-mcastprefix
+ff02::1	ip6-allnodes
+ff02::2	ip6-allrouters
+
+
+# TODO: IAS IP has to be kept up-to-date until IAS resolv of SENG Runtime init
+# code works as expected (currently wrongly redirected to lwIP?)
+
+# IAS Server for new API (still correct on 04.05.2020)
+40.87.90.88 api.trustedservices.intel.com
+
diff --git a/my_etc_files/localtime b/my_etc_files/localtime
new file mode 120000
index 0000000..92ba4ff
--- /dev/null
+++ b/my_etc_files/localtime
@@ -0,0 +1 @@
+/etc/localtime
\ No newline at end of file
diff --git a/my_etc_files/nsswitch.conf b/my_etc_files/nsswitch.conf
new file mode 100644
index 0000000..ba59980
--- /dev/null
+++ b/my_etc_files/nsswitch.conf
@@ -0,0 +1,23 @@
+# /etc/nsswitch.conf
+#
+# Example configuration of GNU Name Service Switch functionality.
+# If you have the `glibc-doc-reference' and `info' packages installed, try:
+# `info libc "Name Service Switch"' for information about this file.
+
+passwd:         compat
+group:          compat
+shadow:         compat
+gshadow:        files
+
+# TODO: need to use file-based resolution for IAS until resolv of SENG Runtime
+# init code works as expected for IAS (currently wrongly redirected to lwIP?)
+#hosts:          files dns
+hosts:          files
+networks:       files
+
+protocols:      db files
+services:       db files
+ethers:         db files
+rpc:            db files
+
+netgroup:       nis
diff --git a/my_etc_files/passwd b/my_etc_files/passwd
new file mode 120000
index 0000000..3594e94
--- /dev/null
+++ b/my_etc_files/passwd
@@ -0,0 +1 @@
+/etc/passwd
\ No newline at end of file
diff --git a/my_etc_files/resolv.conf b/my_etc_files/resolv.conf
new file mode 100644
index 0000000..82ef6b4
--- /dev/null
+++ b/my_etc_files/resolv.conf
@@ -0,0 +1,4 @@
+#search example.com
+#domain example.com
+nameserver 8.8.8.8
+options edns0 ndots:0
diff --git a/my_etc_files/services b/my_etc_files/services
new file mode 100644
index 0000000..704cd12
--- /dev/null
+++ b/my_etc_files/services
@@ -0,0 +1,612 @@
+# Network services, Internet style
+#
+# Note that it is presently the policy of IANA to assign a single well-known
+# port number for both TCP and UDP; hence, officially ports have two entries
+# even if the protocol doesn't support UDP operations.
+#
+# Updated from http://www.iana.org/assignments/port-numbers and other
+# sources like http://www.freebsd.org/cgi/cvsweb.cgi/src/etc/services .
+# New ports will be added on request if they have been officially assigned
+# by IANA and used in the real-world or are needed by a debian package.
+# If you need a huge list of used numbers please install the nmap package.
+
+tcpmux		1/tcp				# TCP port service multiplexer
+echo		7/tcp
+echo		7/udp
+discard		9/tcp		sink null
+discard		9/udp		sink null
+systat		11/tcp		users
+daytime		13/tcp
+daytime		13/udp
+netstat		15/tcp
+qotd		17/tcp		quote
+msp		18/tcp				# message send protocol
+msp		18/udp
+chargen		19/tcp		ttytst source
+chargen		19/udp		ttytst source
+ftp-data	20/tcp
+ftp		21/tcp
+fsp		21/udp		fspd
+ssh		22/tcp				# SSH Remote Login Protocol
+ssh		22/udp
+telnet		23/tcp
+smtp		25/tcp		mail
+time		37/tcp		timserver
+time		37/udp		timserver
+rlp		39/udp		resource	# resource location
+nameserver	42/tcp		name		# IEN 116
+whois		43/tcp		nicname
+tacacs		49/tcp				# Login Host Protocol (TACACS)
+tacacs		49/udp
+re-mail-ck	50/tcp				# Remote Mail Checking Protocol
+re-mail-ck	50/udp
+domain		53/tcp				# Domain Name Server
+domain		53/udp
+mtp		57/tcp				# deprecated
+tacacs-ds	65/tcp				# TACACS-Database Service
+tacacs-ds	65/udp
+bootps		67/tcp				# BOOTP server
+bootps		67/udp
+bootpc		68/tcp				# BOOTP client
+bootpc		68/udp
+tftp		69/udp
+gopher		70/tcp				# Internet Gopher
+gopher		70/udp
+rje		77/tcp		netrjs
+finger		79/tcp
+http		80/tcp		www		# WorldWideWeb HTTP
+http		80/udp				# HyperText Transfer Protocol
+link		87/tcp		ttylink
+kerberos	88/tcp		kerberos5 krb5 kerberos-sec	# Kerberos v5
+kerberos	88/udp		kerberos5 krb5 kerberos-sec	# Kerberos v5
+supdup		95/tcp
+hostnames	101/tcp		hostname	# usually from sri-nic
+iso-tsap	102/tcp		tsap		# part of ISODE
+acr-nema	104/tcp		dicom		# Digital Imag. & Comm. 300
+acr-nema	104/udp		dicom
+csnet-ns	105/tcp		cso-ns		# also used by CSO name server
+csnet-ns	105/udp		cso-ns
+rtelnet		107/tcp				# Remote Telnet
+rtelnet		107/udp
+pop2		109/tcp		postoffice pop-2 # POP version 2
+pop2		109/udp		pop-2
+pop3		110/tcp		pop-3		# POP version 3
+pop3		110/udp		pop-3
+sunrpc		111/tcp		portmapper	# RPC 4.0 portmapper
+sunrpc		111/udp		portmapper
+auth		113/tcp		authentication tap ident
+sftp		115/tcp
+uucp-path	117/tcp
+nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
+ntp		123/tcp
+ntp		123/udp				# Network Time Protocol
+pwdgen		129/tcp				# PWDGEN service
+pwdgen		129/udp
+loc-srv		135/tcp		epmap		# Location Service
+loc-srv		135/udp		epmap
+netbios-ns	137/tcp				# NETBIOS Name Service
+netbios-ns	137/udp
+netbios-dgm	138/tcp				# NETBIOS Datagram Service
+netbios-dgm	138/udp
+netbios-ssn	139/tcp				# NETBIOS session service
+netbios-ssn	139/udp
+imap2		143/tcp		imap		# Interim Mail Access P 2 and 4
+imap2		143/udp		imap
+snmp		161/tcp				# Simple Net Mgmt Protocol
+snmp		161/udp
+snmp-trap	162/tcp		snmptrap	# Traps for SNMP
+snmp-trap	162/udp		snmptrap
+cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
+cmip-man	163/udp
+cmip-agent	164/tcp
+cmip-agent	164/udp
+mailq		174/tcp			# Mailer transport queue for Zmailer
+mailq		174/udp
+xdmcp		177/tcp				# X Display Mgr. Control Proto
+xdmcp		177/udp
+nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
+nextstep	178/udp		NeXTStep NextStep	#  server
+bgp		179/tcp				# Border Gateway Protocol
+bgp		179/udp
+prospero	191/tcp				# Cliff Neuman's Prospero
+prospero	191/udp
+irc		194/tcp				# Internet Relay Chat
+irc		194/udp
+smux		199/tcp				# SNMP Unix Multiplexer
+smux		199/udp
+at-rtmp		201/tcp				# AppleTalk routing
+at-rtmp		201/udp
+at-nbp		202/tcp				# AppleTalk name binding
+at-nbp		202/udp
+at-echo		204/tcp				# AppleTalk echo
+at-echo		204/udp
+at-zis		206/tcp				# AppleTalk zone information
+at-zis		206/udp
+qmtp		209/tcp				# Quick Mail Transfer Protocol
+qmtp		209/udp
+z3950		210/tcp		wais		# NISO Z39.50 database
+z3950		210/udp		wais
+ipx		213/tcp				# IPX
+ipx		213/udp
+imap3		220/tcp				# Interactive Mail Access
+imap3		220/udp				# Protocol v3
+pawserv		345/tcp				# Perf Analysis Workbench
+pawserv		345/udp
+zserv		346/tcp				# Zebra server
+zserv		346/udp
+fatserv		347/tcp				# Fatmen Server
+fatserv		347/udp
+rpc2portmap	369/tcp
+rpc2portmap	369/udp				# Coda portmapper
+codaauth2	370/tcp
+codaauth2	370/udp				# Coda authentication server
+clearcase	371/tcp		Clearcase
+clearcase	371/udp		Clearcase
+ulistserv	372/tcp				# UNIX Listserv
+ulistserv	372/udp
+ldap		389/tcp			# Lightweight Directory Access Protocol
+ldap		389/udp
+imsp		406/tcp			# Interactive Mail Support Protocol
+imsp		406/udp
+svrloc		427/tcp				# Server Location
+svrloc		427/udp
+https		443/tcp				# http protocol over TLS/SSL
+https		443/udp
+snpp		444/tcp				# Simple Network Paging Protocol
+snpp		444/udp
+microsoft-ds	445/tcp				# Microsoft Naked CIFS
+microsoft-ds	445/udp
+kpasswd		464/tcp
+kpasswd		464/udp
+urd		465/tcp		ssmtp smtps  # URL Rendesvous Directory for SSM
+saft		487/tcp			# Simple Asynchronous File Transfer
+saft		487/udp
+isakmp		500/tcp			# IPsec - Internet Security Association
+isakmp		500/udp			#  and Key Management Protocol
+rtsp		554/tcp			# Real Time Stream Control Protocol
+rtsp		554/udp
+nqs		607/tcp				# Network Queuing system
+nqs		607/udp
+npmp-local	610/tcp		dqs313_qmaster		# npmp-local / DQS
+npmp-local	610/udp		dqs313_qmaster
+npmp-gui	611/tcp		dqs313_execd		# npmp-gui / DQS
+npmp-gui	611/udp		dqs313_execd
+hmmp-ind	612/tcp		dqs313_intercell	# HMMP Indication / DQS
+hmmp-ind	612/udp		dqs313_intercell
+asf-rmcp	623/udp		# ASF Remote Management and Control Protocol
+qmqp		628/tcp
+qmqp		628/udp
+ipp		631/tcp				# Internet Printing Protocol
+ipp		631/udp
+#
+# UNIX specific services
+#
+exec		512/tcp
+biff		512/udp		comsat
+login		513/tcp
+who		513/udp		whod
+shell		514/tcp		cmd		# no passwords used
+syslog		514/udp
+printer		515/tcp		spooler		# line printer spooler
+talk		517/udp
+ntalk		518/udp
+route		520/udp		router routed	# RIP
+timed		525/udp		timeserver
+tempo		526/tcp		newdate
+courier		530/tcp		rpc
+conference	531/tcp		chat
+netnews		532/tcp		readnews
+netwall		533/udp				# for emergency broadcasts
+gdomap		538/tcp				# GNUstep distributed objects
+gdomap		538/udp
+uucp		540/tcp		uucpd		# uucp daemon
+klogin		543/tcp				# Kerberized `rlogin' (v5)
+kshell		544/tcp		krcmd		# Kerberized `rsh' (v5)
+dhcpv6-client	546/tcp
+dhcpv6-client	546/udp
+dhcpv6-server	547/tcp
+dhcpv6-server	547/udp
+afpovertcp	548/tcp				# AFP over TCP
+afpovertcp	548/udp
+idfp		549/tcp
+idfp		549/udp
+remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
+nntps		563/tcp		snntp		# NNTP over SSL
+nntps		563/udp		snntp
+submission	587/tcp				# Submission [RFC4409]
+submission	587/udp
+ldaps		636/tcp				# LDAP over SSL
+ldaps		636/udp
+tinc		655/tcp				# tinc control port
+tinc		655/udp
+silc		706/tcp
+silc		706/udp
+kerberos-adm	749/tcp				# Kerberos `kadmin' (v5)
+#
+webster		765/tcp				# Network dictionary
+webster		765/udp
+rsync		873/tcp
+rsync		873/udp
+ftps-data	989/tcp				# FTP over SSL (data)
+ftps		990/tcp
+telnets		992/tcp				# Telnet over SSL
+telnets		992/udp
+imaps		993/tcp				# IMAP over SSL
+imaps		993/udp
+ircs		994/tcp				# IRC over SSL
+ircs		994/udp
+pop3s		995/tcp				# POP-3 over SSL
+pop3s		995/udp
+#
+# From ``Assigned Numbers'':
+#
+#> The Registered Ports are not controlled by the IANA and on most systems
+#> can be used by ordinary user processes or programs executed by ordinary
+#> users.
+#
+#> Ports are used in the TCP [45,106] to name the ends of logical
+#> connections which carry long term conversations.  For the purpose of
+#> providing services to unknown callers, a service contact port is
+#> defined.  This list specifies the port used by the server process as its
+#> contact port.  While the IANA can not control uses of these ports it
+#> does register or list uses of these ports as a convienence to the
+#> community.
+#
+socks		1080/tcp			# socks proxy server
+socks		1080/udp
+proofd		1093/tcp
+proofd		1093/udp
+rootd		1094/tcp
+rootd		1094/udp
+openvpn		1194/tcp
+openvpn		1194/udp
+rmiregistry	1099/tcp			# Java RMI Registry
+rmiregistry	1099/udp
+kazaa		1214/tcp
+kazaa		1214/udp
+nessus		1241/tcp			# Nessus vulnerability
+nessus		1241/udp			#  assessment scanner
+lotusnote	1352/tcp	lotusnotes	# Lotus Note
+lotusnote	1352/udp	lotusnotes
+ms-sql-s	1433/tcp			# Microsoft SQL Server
+ms-sql-s	1433/udp
+ms-sql-m	1434/tcp			# Microsoft SQL Monitor
+ms-sql-m	1434/udp
+ingreslock	1524/tcp
+ingreslock	1524/udp
+prospero-np	1525/tcp			# Prospero non-privileged
+prospero-np	1525/udp
+datametrics	1645/tcp	old-radius
+datametrics	1645/udp	old-radius
+sa-msg-port	1646/tcp	old-radacct
+sa-msg-port	1646/udp	old-radacct
+kermit		1649/tcp
+kermit		1649/udp
+groupwise	1677/tcp
+groupwise	1677/udp
+l2f		1701/tcp	l2tp
+l2f		1701/udp	l2tp
+radius		1812/tcp
+radius		1812/udp
+radius-acct	1813/tcp	radacct		# Radius Accounting
+radius-acct	1813/udp	radacct
+msnp		1863/tcp			# MSN Messenger
+msnp		1863/udp
+unix-status	1957/tcp			# remstats unix-status server
+log-server	1958/tcp			# remstats log server
+remoteping	1959/tcp			# remstats remoteping server
+cisco-sccp	2000/tcp			# Cisco SCCP
+cisco-sccp	2000/udp
+search		2010/tcp	ndtp
+pipe-server	2010/tcp	pipe_server
+nfs		2049/tcp			# Network File System
+nfs		2049/udp			# Network File System
+gnunet		2086/tcp
+gnunet		2086/udp
+rtcm-sc104	2101/tcp			# RTCM SC-104 IANA 1/29/99
+rtcm-sc104	2101/udp
+gsigatekeeper	2119/tcp
+gsigatekeeper	2119/udp
+gris		2135/tcp		# Grid Resource Information Server
+gris		2135/udp
+cvspserver	2401/tcp			# CVS client/server operations
+cvspserver	2401/udp
+venus		2430/tcp			# codacon port
+venus		2430/udp			# Venus callback/wbc interface
+venus-se	2431/tcp			# tcp side effects
+venus-se	2431/udp			# udp sftp side effect
+codasrv		2432/tcp			# not used
+codasrv		2432/udp			# server port
+codasrv-se	2433/tcp			# tcp side effects
+codasrv-se	2433/udp			# udp sftp side effect
+mon		2583/tcp			# MON traps
+mon		2583/udp
+dict		2628/tcp			# Dictionary server
+dict		2628/udp
+f5-globalsite	2792/tcp
+f5-globalsite	2792/udp
+gsiftp		2811/tcp
+gsiftp		2811/udp
+gpsd		2947/tcp
+gpsd		2947/udp
+gds-db		3050/tcp	gds_db		# InterBase server
+gds-db		3050/udp	gds_db
+icpv2		3130/tcp	icp		# Internet Cache Protocol
+icpv2		3130/udp	icp
+iscsi-target	3260/tcp
+mysql		3306/tcp
+mysql		3306/udp
+nut		3493/tcp			# Network UPS Tools
+nut		3493/udp
+distcc		3632/tcp			# distributed compiler
+distcc		3632/udp
+daap		3689/tcp			# Digital Audio Access Protocol
+daap		3689/udp
+svn		3690/tcp	subversion	# Subversion protocol
+svn		3690/udp	subversion
+suucp		4031/tcp			# UUCP over SSL
+suucp		4031/udp
+sysrqd		4094/tcp			# sysrq daemon
+sysrqd		4094/udp
+sieve		4190/tcp			# ManageSieve Protocol
+epmd		4369/tcp			# Erlang Port Mapper Daemon
+epmd		4369/udp
+remctl		4373/tcp		# Remote Authenticated Command Service
+remctl		4373/udp
+f5-iquery	4353/tcp			# F5 iQuery
+f5-iquery	4353/udp
+ipsec-nat-t	4500/udp			# IPsec NAT-Traversal [RFC3947]
+iax		4569/tcp			# Inter-Asterisk eXchange
+iax		4569/udp
+mtn		4691/tcp			# monotone Netsync Protocol
+mtn		4691/udp
+radmin-port	4899/tcp			# RAdmin Port
+radmin-port	4899/udp
+rfe		5002/udp			# Radio Free Ethernet
+rfe		5002/tcp
+mmcc		5050/tcp	# multimedia conference control tool (Yahoo IM)
+mmcc		5050/udp
+sip		5060/tcp			# Session Initiation Protocol
+sip		5060/udp
+sip-tls		5061/tcp
+sip-tls		5061/udp
+aol		5190/tcp			# AIM
+aol		5190/udp
+xmpp-client	5222/tcp	jabber-client	# Jabber Client Connection
+xmpp-client	5222/udp	jabber-client
+xmpp-server	5269/tcp	jabber-server	# Jabber Server Connection
+xmpp-server	5269/udp	jabber-server
+cfengine	5308/tcp
+cfengine	5308/udp
+mdns		5353/tcp			# Multicast DNS
+mdns		5353/udp
+postgresql	5432/tcp	postgres	# PostgreSQL Database
+postgresql	5432/udp	postgres
+freeciv		5556/tcp	rptp		# Freeciv gameplay
+freeciv		5556/udp
+amqps		5671/tcp			# AMQP protocol over TLS/SSL
+amqp		5672/tcp
+amqp		5672/udp
+amqp		5672/sctp
+ggz		5688/tcp			# GGZ Gaming Zone
+ggz		5688/udp
+x11		6000/tcp	x11-0		# X Window System
+x11		6000/udp	x11-0
+x11-1		6001/tcp
+x11-1		6001/udp
+x11-2		6002/tcp
+x11-2		6002/udp
+x11-3		6003/tcp
+x11-3		6003/udp
+x11-4		6004/tcp
+x11-4		6004/udp
+x11-5		6005/tcp
+x11-5		6005/udp
+x11-6		6006/tcp
+x11-6		6006/udp
+x11-7		6007/tcp
+x11-7		6007/udp
+gnutella-svc	6346/tcp			# gnutella
+gnutella-svc	6346/udp
+gnutella-rtr	6347/tcp			# gnutella
+gnutella-rtr	6347/udp
+sge-qmaster	6444/tcp	sge_qmaster	# Grid Engine Qmaster Service
+sge-qmaster	6444/udp	sge_qmaster
+sge-execd	6445/tcp	sge_execd	# Grid Engine Execution Service
+sge-execd	6445/udp	sge_execd
+mysql-proxy	6446/tcp			# MySQL Proxy
+mysql-proxy	6446/udp
+afs3-fileserver 7000/tcp	bbs		# file server itself
+afs3-fileserver 7000/udp	bbs
+afs3-callback	7001/tcp			# callbacks to cache managers
+afs3-callback	7001/udp
+afs3-prserver	7002/tcp			# users & groups database
+afs3-prserver	7002/udp
+afs3-vlserver	7003/tcp			# volume location database
+afs3-vlserver	7003/udp
+afs3-kaserver	7004/tcp			# AFS/Kerberos authentication
+afs3-kaserver	7004/udp
+afs3-volser	7005/tcp			# volume managment server
+afs3-volser	7005/udp
+afs3-errors	7006/tcp			# error interpretation service
+afs3-errors	7006/udp
+afs3-bos	7007/tcp			# basic overseer process
+afs3-bos	7007/udp
+afs3-update	7008/tcp			# server-to-server updater
+afs3-update	7008/udp
+afs3-rmtsys	7009/tcp			# remote cache manager service
+afs3-rmtsys	7009/udp
+font-service	7100/tcp	xfs		# X Font Service
+font-service	7100/udp	xfs
+http-alt	8080/tcp	webcache	# WWW caching service
+http-alt	8080/udp
+bacula-dir	9101/tcp			# Bacula Director
+bacula-dir	9101/udp
+bacula-fd	9102/tcp			# Bacula File Daemon
+bacula-fd	9102/udp
+bacula-sd	9103/tcp			# Bacula Storage Daemon
+bacula-sd	9103/udp
+xmms2		9667/tcp	# Cross-platform Music Multiplexing System
+xmms2		9667/udp
+nbd		10809/tcp			# Linux Network Block Device
+zabbix-agent	10050/tcp			# Zabbix Agent
+zabbix-agent	10050/udp
+zabbix-trapper	10051/tcp			# Zabbix Trapper
+zabbix-trapper	10051/udp
+amanda		10080/tcp			# amanda backup services
+amanda		10080/udp
+dicom		11112/tcp
+hkp		11371/tcp			# OpenPGP HTTP Keyserver
+hkp		11371/udp
+bprd		13720/tcp			# VERITAS NetBackup
+bprd		13720/udp
+bpdbm		13721/tcp			# VERITAS NetBackup
+bpdbm		13721/udp
+bpjava-msvc	13722/tcp			# BP Java MSVC Protocol
+bpjava-msvc	13722/udp
+vnetd		13724/tcp			# Veritas Network Utility
+vnetd		13724/udp
+bpcd		13782/tcp			# VERITAS NetBackup
+bpcd		13782/udp
+vopied		13783/tcp			# VERITAS NetBackup
+vopied		13783/udp
+db-lsp		17500/tcp			# Dropbox LanSync Protocol
+dcap		22125/tcp			# dCache Access Protocol
+gsidcap		22128/tcp			# GSI dCache Access Protocol
+wnn6		22273/tcp			# wnn6
+wnn6		22273/udp
+
+#
+# Datagram Delivery Protocol services
+#
+rtmp		1/ddp			# Routing Table Maintenance Protocol
+nbp		2/ddp			# Name Binding Protocol
+echo		4/ddp			# AppleTalk Echo Protocol
+zip		6/ddp			# Zone Information Protocol
+
+#=========================================================================
+# The remaining port numbers are not as allocated by IANA.
+#=========================================================================
+
+# Kerberos (Project Athena/MIT) services
+# Note that these are for Kerberos v4, and are unofficial.  Sites running
+# v4 should uncomment these and comment out the v5 entries above.
+#
+kerberos4	750/udp		kerberos-iv kdc	# Kerberos (server)
+kerberos4	750/tcp		kerberos-iv kdc
+kerberos-master	751/udp		kerberos_master	# Kerberos authentication
+kerberos-master	751/tcp
+passwd-server	752/udp		passwd_server	# Kerberos passwd server
+krb-prop	754/tcp		krb_prop krb5_prop hprop # Kerberos slave propagation
+krbupdate	760/tcp		kreg		# Kerberos registration
+swat		901/tcp				# swat
+kpop		1109/tcp			# Pop with Kerberos
+knetd		2053/tcp			# Kerberos de-multiplexor
+zephyr-srv	2102/udp			# Zephyr server
+zephyr-clt	2103/udp			# Zephyr serv-hm connection
+zephyr-hm	2104/udp			# Zephyr hostmanager
+eklogin		2105/tcp			# Kerberos encrypted rlogin
+# Hmmm. Are we using Kv4 or Kv5 now? Worrying.
+# The following is probably Kerberos v5  --- ajt@debian.org (11/02/2000)
+kx		2111/tcp			# X over Kerberos
+iprop		2121/tcp			# incremental propagation
+#
+# Unofficial but necessary (for NetBSD) services
+#
+supfilesrv	871/tcp				# SUP server
+supfiledbg	1127/tcp			# SUP debugging
+
+#
+# Services added for the Debian GNU/Linux distribution
+#
+linuxconf	98/tcp				# LinuxConf
+poppassd	106/tcp				# Eudora
+poppassd	106/udp
+moira-db	775/tcp		moira_db	# Moira database
+moira-update	777/tcp		moira_update	# Moira update protocol
+moira-ureg	779/udp		moira_ureg	# Moira user registration
+spamd		783/tcp				# spamassassin daemon
+omirr		808/tcp		omirrd		# online mirror
+omirr		808/udp		omirrd
+customs		1001/tcp			# pmake customs server
+customs		1001/udp
+skkserv		1178/tcp			# skk jisho server port
+predict		1210/udp			# predict -- satellite tracking
+rmtcfg		1236/tcp			# Gracilis Packeten remote config server
+wipld		1300/tcp			# Wipl network monitor
+xtel		1313/tcp			# french minitel
+xtelw		1314/tcp			# french minitel
+support		1529/tcp			# GNATS
+cfinger		2003/tcp			# GNU Finger
+frox		2121/tcp			# frox: caching ftp proxy
+ninstall	2150/tcp			# ninstall service
+ninstall	2150/udp
+zebrasrv	2600/tcp			# zebra service
+zebra		2601/tcp			# zebra vty
+ripd		2602/tcp			# ripd vty (zebra)
+ripngd		2603/tcp			# ripngd vty (zebra)
+ospfd		2604/tcp			# ospfd vty (zebra)
+bgpd		2605/tcp			# bgpd vty (zebra)
+ospf6d		2606/tcp			# ospf6d vty (zebra)
+ospfapi		2607/tcp			# OSPF-API
+isisd		2608/tcp			# ISISd vty (zebra)
+afbackup	2988/tcp			# Afbackup system
+afbackup	2988/udp
+afmbackup	2989/tcp			# Afmbackup system
+afmbackup	2989/udp
+xtell		4224/tcp			# xtell server
+fax		4557/tcp			# FAX transmission service (old)
+hylafax		4559/tcp			# HylaFAX client-server protocol (new)
+distmp3		4600/tcp			# distmp3host daemon
+munin		4949/tcp	lrrd		# Munin
+enbd-cstatd	5051/tcp			# ENBD client statd
+enbd-sstatd	5052/tcp			# ENBD server statd
+pcrd		5151/tcp			# PCR-1000 Daemon
+noclog		5354/tcp			# noclogd with TCP (nocol)
+noclog		5354/udp			# noclogd with UDP (nocol)
+hostmon		5355/tcp			# hostmon uses TCP (nocol)
+hostmon		5355/udp			# hostmon uses UDP (nocol)
+rplay		5555/udp			# RPlay audio service
+nrpe		5666/tcp			# Nagios Remote Plugin Executor
+nsca		5667/tcp			# Nagios Agent - NSCA
+mrtd		5674/tcp			# MRT Routing Daemon
+bgpsim		5675/tcp			# MRT Routing Simulator
+canna		5680/tcp			# cannaserver
+syslog-tls	6514/tcp			# Syslog over TLS [RFC5425]
+sane-port	6566/tcp	sane saned	# SANE network scanner daemon
+ircd		6667/tcp			# Internet Relay Chat
+zope-ftp	8021/tcp			# zope management by ftp
+tproxy		8081/tcp			# Transparent Proxy
+omniorb		8088/tcp			# OmniORB
+omniorb		8088/udp
+clc-build-daemon 8990/tcp			# Common lisp build daemon
+xinetd		9098/tcp
+mandelspawn	9359/udp	mandelbrot	# network mandelbrot
+git		9418/tcp			# Git Version Control System
+zope		9673/tcp			# zope server
+webmin		10000/tcp
+kamanda		10081/tcp			# amanda backup services (Kerberos)
+kamanda		10081/udp
+amandaidx	10082/tcp			# amanda backup services
+amidxtape	10083/tcp			# amanda backup services
+smsqp		11201/tcp			# Alamin SMS gateway
+smsqp		11201/udp
+xpilot		15345/tcp			# XPilot Contact Port
+xpilot		15345/udp
+sgi-cmsd	17001/udp		# Cluster membership services daemon
+sgi-crsd	17002/udp
+sgi-gcd		17003/udp			# SGI Group membership daemon
+sgi-cad		17004/tcp			# Cluster Admin daemon
+isdnlog		20011/tcp			# isdn logging system
+isdnlog		20011/udp
+vboxd		20012/tcp			# voice box system
+vboxd		20012/udp
+binkp		24554/tcp			# binkp fidonet protocol
+asp		27374/tcp			# Address Search Protocol
+asp		27374/udp
+csync2		30865/tcp			# cluster synchronization tool
+dircproxy	57000/tcp			# Detachable IRC Proxy
+tfido		60177/tcp			# fidonet EMSI over telnet
+fido		60179/tcp			# fidonet EMSI over TCP
+
+# Local services
diff --git a/my_etc_files/ssl/openssl.cnf b/my_etc_files/ssl/openssl.cnf
new file mode 120000
index 0000000..b307285
--- /dev/null
+++ b/my_etc_files/ssl/openssl.cnf
@@ -0,0 +1 @@
+/etc/ssl/openssl.cnf
\ No newline at end of file
diff --git a/nonsdk-ra-attester.c b/nonsdk-ra-attester.c
index 6ec4eab..013a430 100644
--- a/nonsdk-ra-attester.c
+++ b/nonsdk-ra-attester.c
@@ -29,6 +29,12 @@
 #include <epid/common/types.h>
 #include <internal/se_quote_internal.h>
 
+#include <sys/time.h>
+
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
+//#define DEBUG
+
 /* Each protobuf is preceeded by its length stored in a uint32_t. */
 static uint32_t hdr_len = sizeof(uint32_t);
 
@@ -104,6 +110,10 @@ void init_quote_response
     memcpy(target_info, qr->targetinfo.data, sizeof(*target_info));
     memcpy(group_id, qr->gid.data, sizeof(*group_id));
 
+#ifdef DEBUG
+    printf("group_id: %x\n", *((unsigned int *)group_id));
+#endif
+
     free(reply); reply = NULL;
 }
 
@@ -113,6 +123,7 @@ int sgx_report(void*, void*, void*);
 static void hex_print(uint8_t* str, size_t len) {
     for (uint32_t i = 0; i < len; ++i) printf("%02x", str[i]);
     printf("\n");
+    fflush(stdout);
 }
 #endif
 
@@ -160,13 +171,19 @@ void create_report(
     memcpy_s(tmp_report_data, sizeof(*tmp_report_data), report_data, sizeof(*report_data));
 
     sgx_report(tmp_target_info, tmp_report_data, tmp_report);
-    /* for (int i = 0; i < sizeof(*report); ++i) printf("%02x", ((uint8_t*) tmp_report)[i]); */
+    //for (int i = 0; i < sizeof(*report); ++i) printf("%02x", ((uint8_t*) tmp_report)[i]); 
 
     memcpy_s(report, sizeof(*report), tmp_report, sizeof(*tmp_report));
 
-    /* hex_print((uint8_t*) report, sizeof(*report)); */
 #ifdef DEBUG
+    printf("report hex:\n");
+    hex_print((uint8_t*) report, sizeof(*report));
+    printf("\n");
+#endif
+#ifdef DEBUG
+    printf("MR ENCLAVE:\n");
     hex_print((uint8_t*) &report->body.mr_enclave, sizeof(sgx_measurement_t));
+    printf("MR SIGNER:\n");
     hex_print((uint8_t*) &report->body.mr_signer, sizeof(sgx_measurement_t));
 #endif
     
@@ -188,11 +205,15 @@ void get_quote_request(
 
     req.report.data = (uint8_t*) report;
     req.report.len = sizeof(*report);
-    /* printf("len report= %lu\n", sizeof(*report)); */
+#ifdef DEBUG
+    printf("len report= %lu\n", sizeof(*report));
+#endif
     req.quote_type = quote_type;
     req.spid.data = (uint8_t*) spid;
     req.spid.len = sizeof(*spid);
-    /* printf("len spid= %lu\n", sizeof(*spid)); */
+#ifdef DEBUG
+    printf("len spid= %lu\n", sizeof(*spid));
+#endif
     req.has_qe_report = 1;
     req.qe_report = 0;
     req.has_timeout = 1;
@@ -259,6 +280,10 @@ int open_socket(void) {
     saddr.sin_port = htons(1234);
     
     int rc = connect(fd, (const struct sockaddr*) &saddr, sizeof(saddr));
+#ifdef DEBUG
+    perror(NULL);
+#endif
+
     assert(rc != -1);
     
     return fd;
@@ -313,6 +338,16 @@ void do_remote_attestation
 )
 {
     uint32_t quote_size;
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_quote = 1;
+        struct timeval listen_tv_start_quote, listen_tv_end_quote;
+        if( gettimeofday(&listen_tv_start_quote, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_quote = 0;
+        }
+#endif
     sgx_quote_t* quote = alloc_quote(&quote_size);
     assert(quote != NULL);
 
@@ -321,10 +356,47 @@ void do_remote_attestation
               report_data,
               quote,
               quote_size);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_quote == 1 ) {
+            if ( gettimeofday(&listen_tv_end_quote, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_quote.tv_sec - listen_tv_start_quote.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_quote.tv_usec - listen_tv_start_quote.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "get_quote\n");
+                //fflush(stdout);
+            }
+        }
+#endif
 
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
     obtain_attestation_verification_report(quote,
                                            quote_size,
                                            opts,
                                            attn_report);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "IAS\n");
+                //fflush(stdout);
+            }
+        }
+#endif
     free_quote(quote); quote = NULL;
 }
diff --git a/old_graphene.txt b/old_graphene.txt
new file mode 100644
index 0000000..0f4d83d
--- /dev/null
+++ b/old_graphene.txt
@@ -0,0 +1 @@
+aa449b2caf0dda850611aa7b2cf6c475ba60aa04
diff --git a/openssl-ra-attester.c b/openssl-ra-attester.c
new file mode 100644
index 0000000..6a334e3
--- /dev/null
+++ b/openssl-ra-attester.c
@@ -0,0 +1,290 @@
+/* Code to create an extended X.509 certificate with OpenSSL. */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <sgx_uae_service.h>
+
+#include <openssl/rsa.h>
+#include <openssl/x509.h>
+
+#include "ra.h"
+#include "ra-attester.h"
+#include "ra-challenger_private.h"
+#include "ra_private.h"
+
+static const uint32_t SHA256_DIGEST_SIZE = 256 / 8;
+
+#include <sys/time.h>
+//#define MEASURE_FINE_GRAINED_SETUP_TIME
+
+//#define USE_ECDSA 1
+
+/**
+ * Caller must allocate memory for certificate.
+ * 
+ * @param der_crt_len On entry contains the size of der_crt buffer. On return holds actual size of certificate in bytes.
+ */
+static
+void generate_x509
+(
+    EVP_PKEY* key,   /* in */
+    uint8_t* der_crt, /* out */
+    int* der_crt_len, /* in/out */
+    attestation_verification_report_t* attn_report
+)
+{
+    X509* crt;
+    crt = X509_new();
+    
+    X509_set_version(crt, 2);
+    X509_gmtime_adj(X509_get_notBefore(crt), 0);
+    X509_gmtime_adj(X509_get_notAfter(crt), 31536000L);
+
+    X509_set_pubkey(crt, key);
+
+    X509_NAME* name;
+    name = X509_get_subject_name(crt);
+    
+    X509_NAME_add_entry_by_txt(name, "C",  MBSTRING_ASC,
+                               (unsigned char *)"US", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "ST",  MBSTRING_ASC,
+                               (unsigned char *)"OR", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "L",  MBSTRING_ASC,
+                               (unsigned char *)"Hillsboro", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "O",  MBSTRING_ASC,
+                               (unsigned char *)"Intel Inc.", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "OU",  MBSTRING_ASC,
+                               (unsigned char *)"Intel Labs", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
+                               (unsigned char *)"SGX rocks!", -1, -1, 0);
+
+    X509_set_issuer_name(crt, name);
+
+    ASN1_OBJECT obj = { .data = ias_response_body_oid + 2,
+                        .length = ias_oid_len - 2 };
+    ASN1_OCTET_STRING val = { .data = attn_report->ias_report,
+                              .length = attn_report->ias_report_len};
+    X509_EXTENSION ex = { &obj, 0, &val };
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_root_cert_oid + 2;
+    val.data   = attn_report->ias_sign_ca_cert;
+    val.length = attn_report->ias_sign_ca_cert_len;
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_leaf_cert_oid + 2;
+    val.data   = attn_report->ias_sign_cert;
+    val.length = attn_report->ias_sign_cert_len;
+    X509_add_ext(crt, &ex, -1);
+
+    obj.data   = ias_report_signature_oid + 2;
+    val.data   = attn_report->ias_report_signature;
+    val.length = attn_report->ias_report_signature_len;
+    X509_add_ext(crt, &ex, -1);
+
+    X509_sign(crt, key, EVP_sha256());
+
+    /* Encode X509 as DER. */
+    int len = i2d_X509(crt, NULL);
+    assert(len <= *der_crt_len);
+    i2d_X509(crt, &der_crt);
+    *der_crt_len = len;
+
+    X509_free(crt);
+    crt = NULL;
+}
+
+#ifdef USE_ECDSA
+void sha256_ecdsa_pubkey
+(
+    unsigned char hash[SHA256_DIGEST_SIZE],
+    EC_KEY* key
+)
+{
+    int len = i2o_ECPublicKey(key, NULL);
+    assert(len > 0);
+    //assert(len == 97);
+
+    unsigned char buf[len];
+    unsigned char* p = buf;
+    len = i2o_ECPublicKey(key, &p);
+
+    unsigned char md_value[EVP_MAX_MD_SIZE];
+    uint32_t md_len;
+
+    EVP_MD_CTX* mdctx = EVP_MD_CTX_create();
+    const EVP_MD* md = EVP_sha256();
+    EVP_DigestInit_ex(mdctx, md, NULL);
+    EVP_DigestUpdate(mdctx, buf, len);
+    EVP_DigestFinal_ex(mdctx, md_value, &md_len);
+    assert(md_len == SHA256_DIGEST_SIZE);
+    EVP_MD_CTX_destroy(mdctx);
+    memcpy(hash, md_value, SHA256_DIGEST_SIZE);
+}
+#else
+void sha256_rsa_pubkey
+(
+    unsigned char hash[SHA256_DIGEST_SIZE],
+    RSA* key
+)
+{
+    int len = i2d_RSAPublicKey(key, NULL);
+    assert(len > 0);
+    /* magic size of DER-encoded 2048 bit RSA public key. */
+    assert(len == 270);
+    
+    unsigned char buf[len];
+    unsigned char* p = buf;
+    len = i2d_RSAPublicKey(key, &p);
+
+    unsigned char md_value[EVP_MAX_MD_SIZE];
+    uint32_t md_len;
+
+    EVP_MD_CTX* mdctx = EVP_MD_CTX_create();
+    const EVP_MD* md = EVP_sha256();
+    EVP_DigestInit_ex(mdctx, md, NULL);
+    EVP_DigestUpdate(mdctx, buf, len);
+    EVP_DigestFinal_ex(mdctx, md_value, &md_len);
+    assert(md_len == SHA256_DIGEST_SIZE);
+    EVP_MD_CTX_destroy(mdctx);
+    memcpy(hash, md_value, SHA256_DIGEST_SIZE);
+}
+#endif
+
+static void
+openssl_create_key_and_x509
+(
+    uint8_t* der_key,
+    int* der_key_len,
+    uint8_t* der_cert,
+    int* der_cert_len,
+    const struct ra_tls_options* opts
+)
+{
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok_key = 1;
+        struct timeval listen_tv_start_key, listen_tv_end_key;
+        if( gettimeofday(&listen_tv_start_key, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok_key = 0;
+        }
+#endif
+
+    uint8_t der[4096];
+    int derSz;
+    unsigned char* p = der;
+
+#ifdef USE_ECDSA
+    EC_KEY *key;
+    int eccgrp;
+
+    eccgrp = OBJ_txt2nid("secp384r1");
+    key = EC_KEY_new_by_curve_name(eccgrp);
+
+    EC_KEY_set_asn1_flag(key, OPENSSL_EC_NAMED_CURVE);
+
+    int res = EC_KEY_generate_key(key);
+    if (!res) {
+        printf("Failed to generate EC key\n");
+    }
+    assert (res);
+
+    derSz = i2d_ECPrivateKey(key, NULL);
+    i2d_ECPrivateKey(key, &p);
+#else
+    /* Generate key. */
+    RSA* key;
+
+    static const int nr_bits = 2048;
+    key = RSA_generate_key(nr_bits, RSA_F4, NULL, NULL);
+    assert(NULL != key);
+    
+    derSz = i2d_RSAPrivateKey(key, NULL);
+    i2d_RSAPrivateKey(key, &p);
+#endif
+
+    assert(derSz >= 0);
+    assert(derSz <= (int) *der_key_len);
+
+    *der_key_len = derSz;
+    memcpy(der_key, der, derSz);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok_key == 1 ) {
+            if ( gettimeofday(&listen_tv_end_key, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end_key.tv_sec - listen_tv_start_key.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end_key.tv_usec - listen_tv_start_key.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "RSA key\n");
+                //fflush(stdout);
+            }
+        }
+#endif
+
+    /* Generate certificate */
+    sgx_report_data_t report_data = {0, };
+#ifdef USE_ECDSA
+    sha256_ecdsa_pubkey(report_data.d, key);
+#else
+    sha256_rsa_pubkey(report_data.d, key);
+#endif
+    attestation_verification_report_t attestation_report;
+
+    do_remote_attestation(&report_data, opts, &attestation_report);
+
+    EVP_PKEY* evp_key = EVP_PKEY_new();
+#ifdef USE_ECDSA
+    EVP_PKEY_assign_EC_KEY(evp_key, key);
+#else
+    EVP_PKEY_assign_RSA(evp_key, key);
+#endif
+
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        int timeofday_ok = 1;
+        struct timeval listen_tv_start, listen_tv_end;
+        if( gettimeofday(&listen_tv_start, NULL) != 0 ) {
+            fprintf(stderr, "gettimeofday failed in setup\n");
+            fflush(stderr);
+            timeofday_ok = 0;
+        }
+#endif
+    generate_x509(evp_key, der_cert, der_cert_len,
+                  &attestation_report);
+#ifdef MEASURE_FINE_GRAINED_SETUP_TIME
+        if( timeofday_ok == 1 ) {
+            if ( gettimeofday(&listen_tv_end, NULL) != 0 ) {
+                fprintf(stderr, "gettimeofday failed in setup\n");
+                fflush(stderr);
+            } else {
+                unsigned long int diff_sec = listen_tv_end.tv_sec - listen_tv_start.tv_sec;
+                unsigned long int total_diff_in_ms = diff_sec * 1000000 + listen_tv_end.tv_usec - listen_tv_start.tv_usec;
+                printf("%ld;", total_diff_in_ms);
+                //fprintf(stderr, "x509\n");
+                //fflush(stdout);
+            }
+        }
+#endif
+    //printf("Type: %d\n", evp_key->type);
+    EVP_PKEY_free(evp_key);
+    evp_key = NULL;
+}
+
+void create_key_and_x509
+(
+    uint8_t* der_key,  /* out */
+    int* der_key_len,  /* in/out */
+    uint8_t* der_cert, /* out */
+    int* der_cert_len, /* in/out */
+    const struct ra_tls_options* opts /* in */
+)
+{
+    openssl_create_key_and_x509(der_key, der_key_len,
+                                der_cert, der_cert_len,
+                                opts);
+}
diff --git a/openssl-ra-challenger.c b/openssl-ra-challenger.c
index ef5ea24..38982b2 100644
--- a/openssl-ra-challenger.c
+++ b/openssl-ra-challenger.c
@@ -188,7 +188,7 @@ void get_quote_from_cert
     get_quote_from_report(ias_report, ias_report_len, q);
 }
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
@@ -220,6 +220,9 @@ void get_quote_from_report
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+
+    // TODO: return 1 on errors, remove asserts
+    return 0;
 }
 
 static
diff --git a/ra-challenger.c b/ra-challenger.c
index d2d1fc1..9f3b56c 100644
--- a/ra-challenger.c
+++ b/ra-challenger.c
@@ -24,7 +24,7 @@ const uint8_t ias_report_signature_oid[] = OID(0x05);
 
 const size_t ias_oid_len = sizeof(ias_response_body_oid);
 
-void find_oid
+int find_oid
 (
      const unsigned char* ext, size_t ext_len,
      const unsigned char* oid, size_t oid_len,
@@ -32,7 +32,12 @@ void find_oid
 )
 {
     uint8_t* p = memmem(ext, ext_len, oid, oid_len);
-    assert(p != NULL);
+    
+    // if not found, failure
+    if (p == NULL) {
+        return 1;
+    }
+    //assert(p != NULL);
 
     p += oid_len;
 
@@ -42,15 +47,23 @@ void find_oid
     // Enable again if extension is deemed critical. Most TLS
     // implementation will fail validation of a certificate with
     // unknown critical extensions.
-    assert(p[i++] == 0x01);
-    assert(p[i++] == 0x01);
-    assert(p[i++] == 0xFF);
+    if(p[i++] != 0x01 ||
+       p[i++] == 0x01 ||
+       p[i++] == 0xFF) {
+        return 1;
+    }
 #endif
 
     // Now comes the octet string
-    assert(p[i++] == 0x04); // tag for octet string
-    assert(p[i++] == 0x82); // length encoded in two bytes
+    // tag for octet string
+    if(p[i++] != 0x04 ||
+       // length encoded in two bytes
+       p[i++] != 0x82) {
+        return 1;
+    }
     *len  =  p[i++] << 8;
     *len +=  p[i++];
     *val  = &p[i++];
+    
+    return 0;
 }
diff --git a/ra-challenger.h b/ra-challenger.h
index d7647bc..3c8032c 100644
--- a/ra-challenger.h
+++ b/ra-challenger.h
@@ -3,7 +3,7 @@
 
 #include <sgx_quote.h>
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
diff --git a/ra-challenger_private.h b/ra-challenger_private.h
index 3b0c493..512b1c0 100644
--- a/ra-challenger_private.h
+++ b/ra-challenger_private.h
@@ -8,7 +8,7 @@ extern const uint8_t ias_report_signature_oid[];
 
 extern const size_t ias_oid_len;
 
-void find_oid
+int find_oid
 (
      const unsigned char* ext, size_t ext_len,
      const unsigned char* oid, size_t oid_len,
diff --git a/ra_tls_options.c b/ra_tls_options.c
index 3c84a5f..04198ea 100644
--- a/ra_tls_options.c
+++ b/ra_tls_options.c
@@ -5,8 +5,9 @@ struct ra_tls_options my_ra_tls_options = {
               0x00, 0x00, 0x00, 0x00,
               0x00, 0x00, 0x00, 0x00,
               0x00, 0x00, 0x00, 0x00}},
-    .quote_type = SGX_UNLINKABLE_SIGNATURE,
-    .ias_key_file = "./ias-client-key.pem",
-    .ias_cert_file = "./ias-client-cert.pem",
-    .ias_server = "test-as.sgx.trustedservices.intel.com:443"
+    .quote_type = SGX_LINKABLE_SIGNATURE,
+//    .ias_key_file = "./ias-client-key.pem",
+//    .ias_cert_file = "./ias-client-cert.pem",
+//    .ias_server = "test-as.sgx.trustedservices.intel.com:443"
+    .ias_server = "api.trustedservices.intel.com:443"
 };
diff --git a/wolfssl-ra-challenger.c b/wolfssl-ra-challenger.c
index cfc6068..8c50c1d 100644
--- a/wolfssl-ra-challenger.c
+++ b/wolfssl-ra-challenger.c
@@ -116,7 +116,7 @@ void get_quote_from_cert
     FreeDecodedCert(&crt);
 }
 
-void get_quote_from_report
+int get_quote_from_report
 (
     const uint8_t* report /* in */,
     const int report_len  /* in */,
@@ -147,6 +147,9 @@ void get_quote_from_report
     memset(quote, 0, sizeof(sgx_quote_t));
     memcpy(quote, quote_bin, quote_bin_len);
     free(quote_bin);
+
+    // TODO: return 1 on errors, remove asserts
+    return 0;
 }
 
 static
