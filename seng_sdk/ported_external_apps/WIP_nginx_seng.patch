diff --git a/auto/feature b/auto/feature
index 1145f28..e12c389 100644
--- a/auto/feature
+++ b/auto/feature
@@ -23,6 +23,7 @@ if test -n "$ngx_feature_path"; then
     for ngx_temp in $ngx_feature_path; do
         ngx_feature_inc_path="$ngx_feature_inc_path -I $ngx_temp"
     done
+    echo "ngx_feature_inc_path: $ngx_feature_inc_path" >> $NGX_AUTOCONF_ERR 2>&1
 fi
 
 cat << END > $NGX_AUTOTEST.c
diff --git a/auto/headers b/auto/headers
index 5a2e6b9..efc6bea 100644
--- a/auto/headers
+++ b/auto/headers
@@ -2,12 +2,15 @@
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
 
-
 ngx_include="unistd.h";      . auto/include
 ngx_include="inttypes.h";    . auto/include
 ngx_include="limits.h";      . auto/include
-ngx_include="sys/filio.h";   . auto/include
-ngx_include="sys/param.h";   . auto/include
-ngx_include="sys/mount.h";   . auto/include
-ngx_include="sys/statvfs.h"; . auto/include
-ngx_include="crypt.h";       . auto/include
+
+if [ "$NGX_PLATFORM" != SENG ]; then            
+    ngx_include="sys/filio.h";   . auto/include
+    ngx_include="sys/param.h";   . auto/include
+    ngx_include="sys/mount.h";   . auto/include
+    ngx_include="sys/statvfs.h"; . auto/include
+    ngx_include="crypt.h";       . auto/include
+fi   
+
diff --git a/auto/include b/auto/include
index e34dabd..0068690 100644
--- a/auto/include
+++ b/auto/include
@@ -27,7 +27,7 @@ int main() {
 END
 
 
-ngx_test="$CC -o $NGX_AUTOTEST $NGX_AUTOTEST.c"
+ngx_test="$CC $CFLAGS -o $NGX_AUTOTEST $NGX_AUTOTEST.c"
 
 eval "$ngx_test >> $NGX_AUTOCONF_ERR 2>&1"
 
diff --git a/auto/make b/auto/make
index 5589bee..3fd717a 100644
--- a/auto/make
+++ b/auto/make
@@ -7,6 +7,7 @@ echo "creating $NGX_MAKEFILE"
 
 mkdir -p $NGX_OBJS/src/core $NGX_OBJS/src/event $NGX_OBJS/src/event/modules \
          $NGX_OBJS/src/os/unix $NGX_OBJS/src/os/win32 \
+         $NGX_OBJS/src/os/seng/trusted/core $NGX_OBJS/src/os/seng/untrusted/nginx \
          $NGX_OBJS/src/http $NGX_OBJS/src/http/v2 $NGX_OBJS/src/http/modules \
          $NGX_OBJS/src/http/modules/perl \
          $NGX_OBJS/src/mail \
diff --git a/auto/os/conf b/auto/os/conf
index 6ad0e74..937ff47 100644
--- a/auto/os/conf
+++ b/auto/os/conf
@@ -15,6 +15,10 @@ case "$NGX_PLATFORM" in
         . auto/os/linux
     ;;
 
+    SENG)
+        . auto/os/seng
+    ;;
+
     SunOS:*)
         . auto/os/solaris
     ;;
diff --git a/auto/os/seng b/auto/os/seng
new file mode 100644
index 0000000..e51f88a
--- /dev/null
+++ b/auto/os/seng
@@ -0,0 +1,523 @@
+have=NGX_SENG . auto/have_headers
+
+#NGX_SYSTEM="SENG"
+NGX_RELEASE=`uname -r 2>/dev/null`
+NGX_MACHINE=`uname -m 2>/dev/null`
+
+# this module requries file mapping which SENG cannot easily support, so disable
+HTTP_GEO=NO
+echo "http_geo_module currently not supported for SENG"
+
+#Based on os/unix/, but adapted to SGX/SENG
+#NOTE: wherever possible we take the unmodified files from os/unix
+SENG_UNIX_INCS="$CORE_INCS $EVENT_INCS src/os/seng/trusted \
+                src/os/seng/trusted/core \
+                src/os/seng/trusted/linux \
+                src/os/unix"
+
+SENG_UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
+                src/os/unix/ngx_time.h \
+                src/os/seng/trusted/ngx_errno.h \
+                src/os/unix/ngx_alloc.h \
+                src/os/seng/trusted/ngx_files.h \
+                src/os/seng/trusted/ngx_shmem.h \
+                src/os/seng/trusted/ngx_process.h \
+                src/os/seng/trusted/ngx_setaffinity.h \
+                src/os/unix/ngx_setproctitle.h \
+                src/os/unix/ngx_atomic.h \
+                src/os/unix/ngx_gcc_atomic_x86.h \
+                src/os/seng/trusted/ngx_thread.h \
+                src/os/seng/trusted/ngx_socket.h \
+                src/os/seng/trusted/ngx_os.h \
+                src/os/seng/trusted/ngx_user.h \
+                src/os/seng/trusted/ngx_dlopen.h \
+                src/os/seng/trusted/ngx_process_cycle.h \
+                src/os/seng/trusted/ngx_seng_t.h"
+
+# for OCALLs
+SENG_UNIX_DEPS="$SENG_UNIX_DEPS \
+                src/os/seng/trusted/t_ngx_time.h \
+                src/os/seng/trusted/t_ngx_files.h \
+                src/os/seng/trusted/t_ngx_process_user.h \
+                src/os/seng/trusted/linux/stat.h \
+                src/os/seng/trusted/t_ngx_rlimit.h \
+                "
+
+
+SENG_UNIX_SRCS="$CORE_SRCS $EVENT_SRCS \
+                src/os/unix/ngx_time.c \
+                src/os/seng/trusted/ngx_errno.c \
+                src/os/unix/ngx_alloc.c \
+                src/os/seng/trusted/ngx_files.c \
+                src/os/seng/trusted/ngx_socket.c \
+                src/os/unix/ngx_recv.c \
+                src/os/seng/trusted/ngx_readv_chain.c \
+                src/os/unix/ngx_udp_recv.c \
+                src/os/unix/ngx_send.c \
+                src/os/seng/trusted/ngx_writev_chain.c \
+                src/os/unix/ngx_udp_send.c \
+                src/os/seng/trusted/ngx_shmem.c \
+                src/os/seng/trusted/ngx_process.c \
+                src/os/seng/trusted/ngx_daemon.c \
+                src/os/seng/trusted/ngx_setaffinity.c \
+                src/os/unix/ngx_setproctitle.c \
+                src/os/unix/ngx_posix_init.c \
+                src/os/seng/trusted/ngx_user.c \
+                src/os/seng/trusted/ngx_process_cycle.c \
+                src/os/seng/trusted/ngx_seng_t.c \
+                src/os/seng/trusted/seng_misc_funcs.c"
+
+# for OCALLs
+SENG_UNIX_SRCS="$SENG_UNIX_SRCS \
+                src/os/seng/trusted/t_ngx_time.c \
+                src/os/seng/trusted/t_ngx_files.c \
+                src/os/seng/trusted/t_ngx_process_user.c \
+                src/os/seng/trusted/t_ngx_rlimit.c \
+                "
+
+# for ECALLs (might later get merged into t_nginx.c instead)
+# currently helpful for the tests
+#SENG_UNIX_SRCS="$SENG_UNIX_SRCS \
+#                src/os/seng/trusted/core/t_ecalls_nginx.c \
+#                "
+
+#TODO: untrusted
+UNTRUSTED_INCS="src/os/seng/untrusted"
+UNTRUSTED_DEPS="src/os/seng/untrusted/ngx_seng_u.h \
+                src/os/seng/untrusted/u_ngx_time.h \
+                src/os/seng/untrusted/u_ngx_files.h \
+                src/os/seng/untrusted/u_ngx_process_user.h \
+                src/os/seng/untrusted/u_ngx_rlimit.h \
+                src/os/seng/untrusted/u_ngx_process.h \
+                "
+UNTRUSTED_SRCS="src/os/seng/untrusted/ngx_seng_u.c \
+                src/os/seng/untrusted/u_ngx_time.c \
+                src/os/seng/untrusted/u_ngx_files.c \
+                src/os/seng/untrusted/u_ngx_process_user.c \
+                src/os/seng/untrusted/u_ngx_rlimit.c \
+                src/os/seng/untrusted/u_ngx_process.c \
+                "
+
+#TODO: untrusted executable
+U_EXEC_INCS="src/os/seng/untrusted/nginx"
+U_EXEC_DEPS="src/os/seng/untrusted/nginx/u_nginx.h \
+             src/os/seng/untrusted/nginx/enclave_load.h"
+U_EXEC_SRCS="src/os/seng/untrusted/nginx/u_nginx.c \
+             src/os/seng/untrusted/nginx/enclave_load.c"
+
+#echo "\n\n gcc -c -I${UNTRUSTED_INCS} -I${U_EXEC_INCS} ${UNTRUSTED_SRCS} ${U_EXEC_SRCS} \n\n"
+
+
+
+#TODO: SENG_DEPS/SRCS
+#TODO: if we overwrite that, we should be able to only include SGX-SDK headers [if desired]; note however, that failing '-nostdinc' probably will still be required!; though we might miss quite some struct/type definitions in src/os/unix/ files ...!
+SDK_PATH="/opt/intel/sgxsdk"
+SGX_INCS="$SDK_PATH/include $SDK_PATH/include/tlibc"
+SENG_INCS="../../enclave/seng/include"
+LWIP_INCS="../../external/include ../../external/seng_lwip_port/include ../../external/lwip/src/include"
+RATLS_INCS="../../external/sgx-ra-tls/include"
+SGXSSL_INCS="../../external/sgxssl/Linux/package/include"
+
+
+CORE_INCS="$SENG_UNIX_INCS $SGX_INCS \
+            $SENG_INCS \
+            $LWIP_INCS $RATLS_INCS \
+            $SGXSSL_INCS"
+CORE_DEPS="$SENG_UNIX_DEPS $SENG_DEPS"
+CORE_SRCS="$SENG_UNIX_SRCS $SENG_SRCS"
+
+ngx_spacer='
+'
+
+# exclude standard headers, bcs. we build enclave library [NOTE: don't see how untrusted+trusted split with this build system, yet]
+CFLAGS="$CFLAGS -nostdinc"
+
+
+
+# TODO: Add all (trusted) SENG libraries: SDK, SGX-SSL, lwIP, SENG and co.
+SENG_LIB_PATHS=""
+SENG_LD_LIBS=""
+
+# SENG
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L../../build/enclave/seng/src"
+SENG_LD_LIBS="$SENG_LD_LIBS -lseng_truntime"
+
+# SENG-specific dependencies
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L../../build/external"
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L../../build/external/protobuf-c-1.2.1/build-cmake/tlib"
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L../../build/external"
+SENG_LD_LIBS="$SENG_LD_LIBS -lratls_ossl_trusted"
+SENG_LD_LIBS="$SENG_LD_LIBS -ltprotobuf-c"
+SENG_LD_LIBS="$SENG_LD_LIBS -llwip"
+
+# SGX-SSL
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L../../external/sgxssl/Linux/package/lib64"
+SENG_LD_LIBS="$SENG_LD_LIBS -Wl,--start-group -lsgx_tsgxssl -lsgx_ttls -lsgx_tsgxssl_crypto -Wl,--end-group"
+
+# SGX-SDK
+SENG_LIB_PATHS="$SENG_LIB_PATHS -L/opt/intel/sgxsdk/lib64"
+SENG_LD_LIBS="$SENG_LD_LIBS -Wl,--whole-archive -lsgx_tswitchless -lsgx_trts -Wl,--no-whole-archive"
+SENG_LD_LIBS="$SENG_LD_LIBS -Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tkey_exchange -lsgx_tcrypto -lsgx_tservice -Wl,--end-group"
+
+
+# Q: does that have an effect? ==> yes, bcs. it made sizeof fail ((SURE?!, bcs. not sure if REUSEPORT for instance is affected by it!))
+# auto/cc/conf:NGX_TEST_LD_OPT="$NGX_LD_OPT"
+#     ==> I guess this might be too late for feature tests
+#     ==> sizeof uses $NGX_LD_OPT directly
+NGX_LD_OPT_CLEAN="$NGX_LD_OPT"
+NGX_LD_OPT="$NGX_LD_OPT -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -pie"
+NGX_LD_OPT="$NGX_LD_OPT -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles"
+
+# TODO: new
+NGX_LD_OPT="$NGX_LD_OPT -fno-builtin-printf -Wno-implicit-function-declaration"
+
+# LDS file for correct enclave symbol exposure
+LDSCRIPT_FLAG="-Wl,--version-script=src/os/seng/trusted/ngx_seng.lds"
+NGX_LD_OPT="$NGX_LD_OPT -Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined -Wl,-pie,-eenclave_entry -Wl,--export-dynamic ${LDSCRIPT_FLAG} -Wl,--defsym,__ImageBase=0"
+NGX_LD_OPT="$NGX_LD_OPT -m64"
+# TODO: change to RELEASE
+#NGX_LD_OPT="$NGX_LD_OPT -O0 -g -DDEBUG -UNDEBUG -UEDEBUG"
+NGX_LD_OPT="$NGX_LD_OPT -O3 -UDEBUG -DNDEBUG -UEDEBUG"
+# -O2 -UDEBUG -DNDEBUG -UEDEBUG
+
+NGX_LD_OPT="$NGX_LD_OPT $SENG_LIB_PATHS"
+CORE_LIBS="$CORE_LIBS $SENG_LD_LIBS"
+
+  #"-nostdinc" "-fvisibility=hidden" "-fpic" "-fpie" "-fstack-protector"
+  #  "-fno-builtin-printf" "-Wformat" "-Wformat-security" "-Wno-implicit-function-declaration"
+  #  "-std=c11" "-std=c++11" "-nostdinc++"
+
+# TODO: might break others again?
+# TODO: ngx_seng_t.c currently only hacky include for tests
+NGX_TEST_LD_OPT="$NGX_LD_OPT src/os/seng/trusted/ngx_seng_t.c \
+                        src/os/seng/trusted/core/dummy_ecalls_for_tests.c"
+                        #src/os/seng/trusted/core/t_ecalls_nginx.c"
+
+
+#note: seems to be only used for "ngx_test"
+cc_aux_flags="$CC_AUX_FLAGS"
+CC_AUX_FLAGS="$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64"
+
+#Q: what about include paths for tests?
+# TODO: loop to add paths with '-I' prefix
+# alternative: set per test/feature
+CC_AUX_FLAGS="$CC_AUX_FLAGS \
+        -nostdinc -I$SDK_PATH/include -I$SDK_PATH/include/tlibc \
+        -I$SENG_INCS -I$RATLS_INCS -I../../external/include \
+        -I../../external/seng_lwip_port/include \
+        -I../../external/lwip/src/include \
+        -Isrc/os/seng/trusted -Isrc/os/seng/trusted/core \
+        -Isrc/core"
+#CC_AUX_FLAGS="$CC_AUX_FLAGS -nostdinc"
+#CC_AUX_FLAGS="$CC_AUX_FLAGS $SENG_LIBS" #TODO: only test
+
+
+# Linux kernel version
+
+version=$((`uname -r \
+    | sed -n -e 's/^\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\).*/ \
+                                                 \1*256*256+\2*256+\3/p' \
+             -e 's/^\([0-9][0-9]*\)\.\([0-9][0-9]*\).*/\1*256*256+\2*256/p'`))
+
+version=${version:-0}
+
+
+# os/unix # os/unix # os/unix # os/unix # os/unix # os/unix # os/unix # os/unix # os/unix # os/unix 
+
+
+
+NGX_USER=${NGX_USER:-nobody}
+
+if [ -z "$NGX_GROUP" ]; then
+    if [ $NGX_USER = nobody ]; then
+        if grep nobody /etc/group 2>&1 >/dev/null; then
+            echo "checking for nobody group ... found"
+            NGX_GROUP=nobody
+        else
+            echo "checking for nobody group ... not found"
+
+            if grep nogroup /etc/group 2>&1 >/dev/null; then
+                echo "checking for nogroup group ... found"
+                NGX_GROUP=nogroup
+            else
+                echo "checking for nogroup group ... not found"
+                NGX_GROUP=nobody
+            fi
+        fi
+    else
+        NGX_GROUP=$NGX_USER
+    fi
+fi
+
+
+ngx_feature="poll()"
+ngx_feature_name=
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="int  n; struct pollfd  pl;
+                  pl.fd = 0;
+                  pl.events = 0;
+                  pl.revents = 0;
+                  n = seng_poll(&pl, 1, 0);
+                  if (n == -1) return 1"
+. auto/feature
+
+if [ $ngx_found = no ]; then
+    EVENT_POLL=NONE
+fi
+
+
+if [ "$NGX_SYSTEM" = "NetBSD" ]; then
+
+    # NetBSD 2.0 incompatibly defines kevent.udata as "intptr_t"
+
+    cat << END >> $NGX_AUTO_CONFIG_H
+
+#define NGX_KQUEUE_UDATA_T
+
+END
+
+else
+    cat << END >> $NGX_AUTO_CONFIG_H
+
+#define NGX_KQUEUE_UDATA_T  (void *)
+
+END
+
+fi
+
+
+
+#if [ $ngx_found = yes -a "$NGX_SYSTEM" = "Linux" ]; then
+#    have=NGX_HAVE_ALIGNED_DIRECTIO . auto/have
+#fi
+
+  
+
+
+ngx_feature="SO_REUSEPORT"
+ngx_feature_name="NGX_HAVE_REUSEPORT"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="seng_setsockopt(0, SOL_SOCKET, SO_REUSEPORT, NULL, 0)"
+. auto/feature
+
+
+# Linux way to get IPv4 datagram destination address
+
+ngx_feature="IP_PKTINFO"
+ngx_feature_name="NGX_HAVE_IP_PKTINFO"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="seng_setsockopt(0, IPPROTO_IP, IP_PKTINFO, NULL, 0)"
+. auto/feature
+
+
+ngx_feature="TCP_KEEPIDLE"
+ngx_feature_name="NGX_HAVE_KEEPALIVE_TUNABLE"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="seng_setsockopt(0, IPPROTO_TCP, TCP_KEEPIDLE, NULL, 0);
+                  seng_setsockopt(0, IPPROTO_TCP, TCP_KEEPINTVL, NULL, 0);
+                  seng_setsockopt(0, IPPROTO_TCP, TCP_KEEPCNT, NULL, 0)"
+. auto/feature
+
+
+ngx_feature="accept4()"
+ngx_feature_name="NGX_HAVE_ACCEPT4"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="seng_accept4(0, NULL, NULL, SOCK_NONBLOCK)"
+. auto/feature
+
+# TODO: !!
+#have=NGX_HAVE_UNIX_DOMAIN . auto/have
+
+ngx_feature_libs=
+
+# CAUTION: enable Linux stdlibs for the moment to pass sizeof tests
+CC_AUX_BACKUP="$CC_AUX_FLAGS"
+CC_AUX_FLAGS="$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64"
+NGX_LD_OPT_BACKUP="$NGX_LD_OPT"
+NGX_LD_OPT="$NGX_LD_OPT_CLEAN"
+
+
+# C types
+
+ngx_type="int"; . auto/types/sizeof
+
+ngx_type="long"; . auto/types/sizeof
+
+ngx_type="long long"; . auto/types/sizeof
+
+ngx_type="void *"; . auto/types/sizeof; ngx_ptr_size=$ngx_size
+ngx_param=NGX_PTR_SIZE; ngx_value=$ngx_size; . auto/types/value
+
+
+
+# TODO: need to add our POSIX patch to lwIP, because otherwise will mismatch!
+# POSIX types
+
+NGX_INCLUDE_AUTO_CONFIG_H="#include \"ngx_auto_config.h\""
+
+ngx_type="uint32_t"; ngx_types="u_int32_t"; . auto/types/typedef
+ngx_type="uint64_t"; ngx_types="u_int64_t"; . auto/types/typedef
+
+ngx_type="sig_atomic_t"; ngx_types="int"; . auto/types/typedef
+. auto/types/sizeof
+ngx_param=NGX_SIG_ATOMIC_T_SIZE; ngx_value=$ngx_size; . auto/types/value
+
+ngx_type="socklen_t"; ngx_types="int"; . auto/types/typedef
+
+ngx_type="in_addr_t"; ngx_types="uint32_t u_int32_t"; . auto/types/typedef
+
+ngx_type="in_port_t"; ngx_types="u_short"; . auto/types/typedef
+
+ngx_type="rlim_t"; ngx_types="int"; . auto/types/typedef
+
+. auto/types/uintptr_t
+
+. auto/endianness
+
+ngx_type="size_t"; . auto/types/sizeof
+ngx_param=NGX_MAX_SIZE_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value
+ngx_param=NGX_SIZE_T_LEN; ngx_value=$ngx_max_len; . auto/types/value
+
+ngx_type="off_t"; . auto/types/sizeof
+ngx_param=NGX_MAX_OFF_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value
+ngx_param=NGX_OFF_T_LEN; ngx_value=$ngx_max_len; . auto/types/value
+
+ngx_type="time_t"; . auto/types/sizeof
+ngx_param=NGX_TIME_T_SIZE; ngx_value=$ngx_size; . auto/types/value
+ngx_param=NGX_TIME_T_LEN; ngx_value=$ngx_max_len; . auto/types/value
+ngx_param=NGX_MAX_TIME_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value
+
+
+
+
+# TODO: restore here?
+CC_AUX_FLAGS="$CC_AUX_BACKUP"
+NGX_LD_OPT="$NGX_LD_OPT_BACKUP"
+
+
+
+
+# syscalls, libc calls and some features
+
+
+# TODO: add wrapper !!
+ngx_feature="localtime_r()"
+ngx_feature_name="NGX_HAVE_LOCALTIME_R"
+ngx_feature_run=no
+ngx_feature_incs="#include <time.h>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="struct tm t; time_t c=0; localtime_r(&c, &t)"
+. auto/feature
+
+
+
+# TODO: memalign exists in tlibc/stdlib.h
+ngx_feature="memalign()"
+ngx_feature_name="NGX_HAVE_MEMALIGN"
+ngx_feature_run=no
+ngx_feature_incs="#include <stdlib.h>"
+# also ok
+#ngx_feature_path=
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="void *p; p = memalign(4096, 4096);
+                  if (p == NULL) return 1"
+. auto/feature
+
+
+
+
+# TODO: ??
+ngx_feature='mmap("/dev/zero", MAP_SHARED)'
+ngx_feature_name="NGX_HAVE_MAP_DEVZERO"
+ngx_feature_run=yes
+ngx_feature_incs="#include <sys/mman.h>
+                  #include <sys/stat.h>
+                  #include <fcntl.h>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test='void *p; int  fd;
+                  fd = open("/dev/zero", O_RDWR);
+                  p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+                  if (p == MAP_FAILED) return 1;'
+. auto/feature
+
+
+
+# TODO: add if required via SDK mutex ++ condition variable
+ngx_feature="POSIX semaphores"
+ngx_feature_name="NGX_HAVE_POSIX_SEM"
+ngx_feature_run=yes
+ngx_feature_incs="#include <semaphore.h>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="sem_t  sem;
+                  if (sem_init(&sem, 1, 0) == -1) return 1;
+                  sem_destroy(&sem);"
+. auto/feature
+
+
+
+
+
+ngx_feature="struct msghdr.msg_control"
+ngx_feature_name="NGX_HAVE_MSGHDR_MSG_CONTROL"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="struct msghdr  msg;
+                  printf(\"%d\", (int) sizeof(msg.msg_control))"
+. auto/feature
+
+
+ngx_feature="ioctl(FIONBIO)"
+ngx_feature_name="NGX_HAVE_FIONBIO"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="int i = FIONBIO; printf(\"%d\", i)"
+. auto/feature
+
+
+# TODO?
+ngx_feature="struct tm.tm_gmtoff"
+ngx_feature_name="NGX_HAVE_GMTOFF"
+ngx_feature_run=no
+ngx_feature_incs="#include <time.h>
+                  #include <stdio.h>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test="struct tm  tm; tm.tm_gmtoff = 0;
+                  printf(\"%d\", (int) tm.tm_gmtoff)"
+. auto/feature
+
+
+
+ngx_feature="getaddrinfo()"
+ngx_feature_name="NGX_HAVE_GETADDRINFO"
+ngx_feature_run=no
+ngx_feature_incs="#include <seng_api.hpp>"
+ngx_feature_path=
+ngx_feature_libs="$CORE_LIBS"
+ngx_feature_test='struct addrinfo *res;
+                  if (seng_getaddrinfo("localhost", NULL, NULL, &res) != 0) return 1;
+                  seng_freeaddrinfo(res)'
+. auto/feature
diff --git a/auto/sources b/auto/sources
index 27849e6..02fc0c4 100644
--- a/auto/sources
+++ b/auto/sources
@@ -7,7 +7,18 @@ CORE_MODULES="ngx_core_module ngx_errlog_module ngx_conf_module"
 
 CORE_INCS="src/core"
 
-CORE_DEPS="src/core/nginx.h \
+if [ "$NGX_PLATFORM" = SENG ]; then
+    CORE_INCS="$CORE_INCS src/os/seng/trusted/core"
+fi
+
+
+if [ "$NGX_PLATFORM" = SENG ]; then
+    CORE_DEPS="src/os/seng/trusted/core/t_nginx.h"
+else
+    CORE_DEPS="src/core/nginx.h"
+fi
+
+CORE_DEPS="$CORE_DEPS \
            src/core/ngx_config.h \
            src/core/ngx_core.h \
            src/core/ngx_log.h \
@@ -44,7 +55,15 @@ CORE_DEPS="src/core/nginx.h \
            src/core/ngx_syslog.h"
 
 
-CORE_SRCS="src/core/nginx.c \
+if [ "$NGX_PLATFORM" = SENG ]; then
+    CORE_SRCS="src/os/seng/trusted/core/t_nginx.c \
+               src/os/seng/trusted/core/t_ngx_cycle.c"
+else
+    CORE_SRCS="src/core/nginx.c \
+               src/core/ngx_cycle.c"
+fi
+
+CORE_SRCS="$CORE_SRCS \
            src/core/ngx_log.c \
            src/core/ngx_palloc.c \
            src/core/ngx_array.c \
@@ -67,7 +86,6 @@ CORE_SRCS="src/core/nginx.c \
            src/core/ngx_times.c \
            src/core/ngx_shmtx.c \
            src/core/ngx_connection.c \
-           src/core/ngx_cycle.c \
            src/core/ngx_spinlock.c \
            src/core/ngx_rwlock.c \
            src/core/ngx_cpuinfo.c \
@@ -181,10 +199,21 @@ POSIX_DEPS=src/os/unix/ngx_posix_config.h
 
 THREAD_POOL_MODULE=ngx_thread_pool_module
 THREAD_POOL_DEPS=src/core/ngx_thread_pool.h
-THREAD_POOL_SRCS="src/core/ngx_thread_pool.c
-                  src/os/unix/ngx_thread_cond.c
-                  src/os/unix/ngx_thread_mutex.c
-                  src/os/unix/ngx_thread_id.c"
+
+if [ "$NGX_PLATFORM" = SENG ]; then
+    THREAD_POOL_SRCS="src/os/seng/trusted/core/t_ngx_thread_pool.c \
+        src/os/seng/trusted/ngx_thread_cond.c \
+        src/os/seng/trusted/ngx_thread_mutex.c \
+        src/os/seng_trusted/ngx_thread_id.c"
+else
+    THREAD_POOL_SRCS="src/core/ngx_thread_pool.c \
+        src/os/unix/ngx_thread_cond.c \
+        src/os/unix/ngx_thread_mutex.c \
+        src/os/unix/ngx_thread_id.c"
+fi
+
+
+                  
 
 FREEBSD_DEPS="src/os/unix/ngx_freebsd_config.h src/os/unix/ngx_freebsd.h"
 FREEBSD_SRCS=src/os/unix/ngx_freebsd_init.c
@@ -194,6 +223,11 @@ LINUX_DEPS="src/os/unix/ngx_linux_config.h src/os/unix/ngx_linux.h"
 LINUX_SRCS=src/os/unix/ngx_linux_init.c
 LINUX_SENDFILE_SRCS=src/os/unix/ngx_linux_sendfile_chain.c
 
+SENG_DEPS="src/os/seng/trusted/ngx_seng_config.h \
+           src/os/seng/trusted/ngx_seng.h \
+           ../../enclave/seng/include/seng_api.hpp \
+           ../../external/include/lwipopts.h"
+SENG_SRCS=src/os/seng/trusted/ngx_seng_init.c
 
 SOLARIS_DEPS="src/os/unix/ngx_solaris_config.h src/os/unix/ngx_solaris.h"
 SOLARIS_SRCS=src/os/unix/ngx_solaris_init.c
diff --git a/auto/threads b/auto/threads
index 381f07a..0ad74a7 100644
--- a/auto/threads
+++ b/auto/threads
@@ -13,8 +13,27 @@ END
         exit 1
     fi
 
+    if [ "$NGX_PLATFORM" = SENG ]; then
+        cat << END
+
+$0: --with-threads is not yet supported for SENG-SGX
+
+END
+        exit 1
+    fi
+
+
+
+
     have=NGX_THREADS . auto/have
     CORE_DEPS="$CORE_DEPS $THREAD_POOL_DEPS"
     CORE_SRCS="$CORE_SRCS $THREAD_POOL_SRCS"
+
+if [ "$NGX_PLATFORM" = SENG ]; then
+    # TODO: no extra SGX SDK lib for threads, right?
+    CORE_LIBS="$CORE_LIBS"
+else
     CORE_LIBS="$CORE_LIBS -lpthread"
 fi
+
+fi
diff --git a/auto/unix b/auto/unix
index 8c0e813..3e51cd4 100755
--- a/auto/unix
+++ b/auto/unix
@@ -354,6 +354,18 @@ ngx_feature_libs=
 ngx_feature_test="setsockopt(0, IPPROTO_IP, IP_PKTINFO, NULL, 0)"
 . auto/feature
 
+#TODO: SENG version based on lwIP?! --> NOTE: lwIP has support for IP_PKTINFO!
+# SENG/lwIP way to get IPv4 datagram destination address
+
+#ngx_feature="IP_PKTINFO"
+#ngx_feature_name="NGX_HAVE_IP_PKTINFO"
+#ngx_feature_run=no
+#ngx_features_incs="#include <seng_api.hpp>"
+#ngx_feature_path=
+#ngx_feature_libs=
+#ngx_feature_test="setsockopt(0, IPPROTO_IP, IP_PKTINFO, NULL, 0)"
+#. auto/feature
+
 
 # RFC 3542 way to get IPv6 datagram destination address
 
@@ -424,6 +436,8 @@ ngx_feature_test="socklen_t optlen = sizeof(struct tcp_info);
 . auto/feature
 
 
+# TODO: need to get rid of features like that for SENG/SGX, bcs. they will be wrongly included!
+#       maybe we can somehow change the include directories to SGX-SDK, SENG, SYS-SENG and SGXSSL only, s.t. it will naturally fail such tests!
 ngx_feature="accept4()"
 ngx_feature_name="NGX_HAVE_ACCEPT4"
 ngx_feature_run=no
diff --git a/configure b/configure
index ceff15e..2c66697 100755
--- a/configure
+++ b/configure
@@ -9,20 +9,6 @@ export LC_ALL
 
 . auto/options
 . auto/init
-. auto/sources
-
-test -d $NGX_OBJS || mkdir -p $NGX_OBJS
-
-echo > $NGX_AUTO_HEADERS_H
-echo > $NGX_AUTOCONF_ERR
-
-echo "#define NGX_CONFIGURE \"$NGX_CONFIGURE\"" > $NGX_AUTO_CONFIG_H
-
-
-if [ $NGX_DEBUG = YES ]; then
-    have=NGX_DEBUG . auto/have
-fi
-
 
 if test -z "$NGX_PLATFORM"; then
     echo "checking for OS"
@@ -44,17 +30,37 @@ if test -z "$NGX_PLATFORM"; then
 else
     echo "building for $NGX_PLATFORM"
     NGX_SYSTEM=$NGX_PLATFORM
+
+    case "$NGX_SYSTEM" in
+        SENG:*)
+            NGX_PLATFORM=SENG
+        ;;
+    esac
+fi
+
+. auto/sources
+
+test -d $NGX_OBJS || mkdir -p $NGX_OBJS
+
+echo > $NGX_AUTO_HEADERS_H
+echo > $NGX_AUTOCONF_ERR
+
+echo "#define NGX_CONFIGURE \"$NGX_CONFIGURE\"" > $NGX_AUTO_CONFIG_H
+
+
+if [ $NGX_DEBUG = YES ]; then
+    have=NGX_DEBUG . auto/have
 fi
 
 . auto/cc/conf
 
-if [ "$NGX_PLATFORM" != win32 ]; then
+if [ "$NGX_PLATFORM" != win32 ] || [ "$NGX_PLATFORM" == SENG ]; then
     . auto/headers
 fi
 
 . auto/os/conf
 
-if [ "$NGX_PLATFORM" != win32 ]; then
+if [ "$NGX_PLATFORM" != win32 ] && [ "$NGX_PLATFORM" != SENG ]; then
     . auto/unix
 fi
 
diff --git a/src/core/ngx_config.h b/src/core/ngx_config.h
index a0bfa63..56d32bf 100644
--- a/src/core/ngx_config.h
+++ b/src/core/ngx_config.h
@@ -25,6 +25,8 @@
 #elif (NGX_LINUX)
 #include <ngx_linux_config.h>
 
+#elif (NGX_SENG)
+#include <ngx_seng_config.h>
 
 #elif (NGX_SOLARIS)
 #include <ngx_solaris_config.h>
diff --git a/src/core/ngx_connection.c b/src/core/ngx_connection.c
index 5a53bac..d0772ca 100644
--- a/src/core/ngx_connection.c
+++ b/src/core/ngx_connection.c
@@ -1034,7 +1034,11 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
 
     /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */
 
+#if !(NGX_SENG)
     if (ngx_cycle->files && (ngx_uint_t) s >= ngx_cycle->files_n) {
+#else
+    if (ngx_cycle->files && ((ngx_uint_t) s - LWIP_SOCKET_OFFSET) >= ngx_cycle->files_n) {
+#endif
         ngx_log_error(NGX_LOG_ALERT, log, 0,
                       "the new socket has number %d, "
                       "but only %ui files are available",
@@ -1060,9 +1064,15 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
     ngx_cycle->free_connections = c->data;
     ngx_cycle->free_connection_n--;
 
+#if !(NGX_SENG)
     if (ngx_cycle->files && ngx_cycle->files[s] == NULL) {
         ngx_cycle->files[s] = c;
     }
+#else
+    if (ngx_cycle->files && ngx_cycle->files[s - LWIP_SOCKET_OFFSET] == NULL) {
+        ngx_cycle->files[s - LWIP_SOCKET_OFFSET] = c;
+    }
+#endif
 
     rev = c->read;
     wev = c->write;
@@ -1101,9 +1111,15 @@ ngx_free_connection(ngx_connection_t *c)
     ngx_cycle->free_connections = c;
     ngx_cycle->free_connection_n++;
 
+#if !(NGX_SENG)
     if (ngx_cycle->files && ngx_cycle->files[c->fd] == c) {
         ngx_cycle->files[c->fd] = NULL;
     }
+#else
+    if (ngx_cycle->files && ngx_cycle->files[c->fd - LWIP_SOCKET_OFFSET] == c) {
+        ngx_cycle->files[c->fd - LWIP_SOCKET_OFFSET] = NULL;
+    }
+#endif
 }
 
 
diff --git a/src/core/ngx_log.c b/src/core/ngx_log.c
index 8e9408d..ceb4e6a 100644
--- a/src/core/ngx_log.c
+++ b/src/core/ngx_log.c
@@ -111,6 +111,9 @@ ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
     ssize_t      n;
     ngx_uint_t   wrote_stderr, debug_connection;
     u_char       errstr[NGX_MAX_ERROR_STR];
+#if (NGX_SENG)
+    int errno_backup = errno;
+#endif
 
     last = errstr + NGX_MAX_ERROR_STR;
 
@@ -199,6 +202,9 @@ ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
         || level > NGX_LOG_WARN
         || wrote_stderr)
     {
+#if (NGX_SENG)
+        errno = errno_backup;
+#endif
         return;
     }
 
@@ -207,6 +213,10 @@ ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
     (void) ngx_sprintf(msg, "nginx: [%V] ", &err_levels[level]);
 
     (void) ngx_write_console(ngx_stderr, msg, p - msg);
+
+#if (NGX_SENG)
+    errno = errno_backup;
+#endif
 }
 
 
diff --git a/src/event/modules/ngx_poll_module.c b/src/event/modules/ngx_poll_module.c
index 4370950..1e9fddc 100644
--- a/src/event/modules/ngx_poll_module.c
+++ b/src/event/modules/ngx_poll_module.c
@@ -205,7 +205,11 @@ ngx_poll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
 
             event_list[ev->index] = event_list[nevents];
 
+#if !(NGX_SENG)
             c = ngx_cycle->files[event_list[nevents].fd];
+#else
+            c = ngx_cycle->files[event_list[nevents].fd - LWIP_SOCKET_OFFSET];
+#endif
 
             if (c->fd == -1) {
                 ngx_log_error(NGX_LOG_ALERT, ev->log, 0,
@@ -334,7 +338,11 @@ ngx_poll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
             continue;
         }
 
+#if !(NGX_SENG)
         c = ngx_cycle->files[event_list[i].fd];
+#else
+        c = ngx_cycle->files[event_list[i].fd - LWIP_SOCKET_OFFSET];
+#endif
 
         if (c->fd == -1) {
             ngx_log_error(NGX_LOG_ALERT, cycle->log, 0, "unexpected event");
diff --git a/src/event/ngx_event.c b/src/event/ngx_event.c
index c8ae5b2..52796e2 100644
--- a/src/event/ngx_event.c
+++ b/src/event/ngx_event.c
@@ -36,6 +36,7 @@ static char *ngx_event_core_init_conf(ngx_cycle_t *cycle, void *conf);
 
 
 static ngx_uint_t     ngx_timer_resolution;
+
 sig_atomic_t          ngx_event_timer_alarm;
 
 static ngx_uint_t     ngx_event_max_module;
@@ -550,7 +551,7 @@ ngx_event_module_init(ngx_cycle_t *cycle)
 }
 
 
-#if !(NGX_WIN32)
+#if !(NGX_WIN32) && !(NGX_SENG)
 
 static void
 ngx_timer_signal_handler(int signo)
@@ -625,7 +626,7 @@ ngx_event_process_init(ngx_cycle_t *cycle)
         break;
     }
 
-#if !(NGX_WIN32)
+#if !(NGX_WIN32) && !(NGX_SENG)
 
     if (ngx_timer_resolution && !(ngx_event_flags & NGX_USE_TIMER_EVENT)) {
         struct sigaction  sa;
@@ -651,8 +652,12 @@ ngx_event_process_init(ngx_cycle_t *cycle)
                           "setitimer() failed");
         }
     }
+#endif
 
+#if !(NGX_WIN32)
     if (ngx_event_flags & NGX_USE_FD_EVENT) {
+
+#if !(NGX_SENG)
         struct rlimit  rlmt;
 
         if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
@@ -662,6 +667,9 @@ ngx_event_process_init(ngx_cycle_t *cycle)
         }
 
         cycle->files_n = (ngx_uint_t) rlmt.rlim_cur;
+#else
+        cycle->files_n = (ngx_uint_t) MAX_LWIP_SOCKETS;
+#endif /* !(NGX_SENG) */
 
         cycle->files = ngx_calloc(sizeof(ngx_connection_t *) * cycle->files_n,
                                   cycle->log);
@@ -669,8 +677,10 @@ ngx_event_process_init(ngx_cycle_t *cycle)
             return NGX_ERROR;
         }
     }
+#endif /* !(NGX_WIN32) */
 
-#else
+
+#if (NGX_WIN32) || (NGX_SENG)
 
     if (ngx_timer_resolution && !(ngx_event_flags & NGX_USE_TIMER_EVENT)) {
         ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
diff --git a/src/os/seng/.gitignore b/src/os/seng/.gitignore
new file mode 100644
index 0000000..016c215
--- /dev/null
+++ b/src/os/seng/.gitignore
@@ -0,0 +1,4 @@
+trusted/ngx_seng_t.c
+trusted/ngx_seng_t.h
+untrusted/ngx_seng_u.c
+untrusted/ngx_seng_u.h
diff --git a/src/os/seng/trusted/core/dummy_ecalls_for_tests.c b/src/os/seng/trusted/core/dummy_ecalls_for_tests.c
new file mode 100644
index 0000000..a4302a2
--- /dev/null
+++ b/src/os/seng/trusted/core/dummy_ecalls_for_tests.c
@@ -0,0 +1,3 @@
+#include "ngx_seng_t.h" // ECALL(s)
+
+int ecall_run_nginx(int u_argc, char **u_argv, char **envp) { return 0; }
\ No newline at end of file
diff --git a/src/os/seng/trusted/core/t_nginx.c b/src/os/seng/trusted/core/t_nginx.c
new file mode 100644
index 0000000..1e9178d
--- /dev/null
+++ b/src/os/seng/trusted/core/t_nginx.c
@@ -0,0 +1,1597 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <t_nginx.h>
+
+#include "ngx_seng_t.h" // ECALL(s)
+
+#include <sgx_trts.h>
+
+static void ngx_show_version_info(void);
+static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);
+static ngx_int_t ngx_get_options(int argc, char *const *argv);
+static ngx_int_t ngx_process_options(ngx_cycle_t *cycle);
+static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);
+static void *ngx_core_module_create_conf(ngx_cycle_t *cycle);
+static char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);
+static char *ngx_no_seng_support(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+#if (NGX_HAVE_DLOPEN)
+static void ngx_unload_module(void *data);
+#endif
+
+
+static ngx_conf_enum_t  ngx_debug_points[] = {
+    { ngx_string("stop"), NGX_DEBUG_POINTS_STOP },
+    { ngx_string("abort"), NGX_DEBUG_POINTS_ABORT },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_command_t  ngx_core_commands[] = {
+
+    { ngx_string("daemon"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
+      ngx_no_seng_support,
+      0,
+      offsetof(ngx_core_conf_t, daemon),
+      NULL },
+
+    { ngx_string("master_process"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
+      ngx_no_seng_support,
+      0,
+      offsetof(ngx_core_conf_t, master),
+      NULL },
+
+    { ngx_string("timer_resolution"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      0,
+      offsetof(ngx_core_conf_t, timer_resolution),
+      NULL },
+
+    { ngx_string("pid"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_core_conf_t, pid),
+      NULL },
+
+    { ngx_string("lock_file"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_core_conf_t, lock_file),
+      NULL },
+
+    { ngx_string("worker_processes"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_set_worker_processes,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("debug_points"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_enum_slot,
+      0,
+      offsetof(ngx_core_conf_t, debug_points),
+      &ngx_debug_points },
+
+    { ngx_string("user"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE12,
+      ngx_set_user,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("worker_priority"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_set_priority,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("worker_cpu_affinity"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,
+      ngx_set_cpu_affinity,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("worker_rlimit_nofile"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_core_conf_t, rlimit_nofile),
+      NULL },
+
+    { ngx_string("worker_rlimit_core"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_off_slot,
+      0,
+      offsetof(ngx_core_conf_t, rlimit_core),
+      NULL },
+
+    { ngx_string("working_directory"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_core_conf_t, working_directory),
+      NULL },
+
+    { ngx_string("env"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_set_env,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("load_module"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_load_module,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+static char *
+ngx_no_seng_support(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                        "\"%s\" is not yet supported by SENG, ignored", 
+                        cmd->name.data);
+    return NGX_CONF_OK;
+}
+
+
+static ngx_core_module_t  ngx_core_module_ctx = {
+    ngx_string("core"),
+    ngx_core_module_create_conf,
+    ngx_core_module_init_conf
+};
+
+
+ngx_module_t  ngx_core_module = {
+    NGX_MODULE_V1,
+    &ngx_core_module_ctx,                  /* module context */
+    ngx_core_commands,                     /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_uint_t   ngx_show_help;
+static ngx_uint_t   ngx_show_version;
+static ngx_uint_t   ngx_show_configure;
+static u_char      *ngx_prefix;
+static u_char      *ngx_conf_file;
+static u_char      *ngx_conf_params;
+static char        *ngx_signal;
+
+
+static char **ngx_os_environ;
+
+// global replacement for environ (untrusted)
+char **u_environ;
+char **environ;
+
+
+int ngx_cdecl trusted_nginx_main(int argc, char *const *argv);
+
+// ECALL
+int ecall_run_nginx(int u_argc, char **u_argv, char **envp) {
+    // TODO: sanity check u_argv
+    // TODO: prob. copy in argv
+    // Alternative: do both below in the parsing code
+
+    u_environ = envp;
+    // TODO: could check and copy to create "trusted" environ
+    environ = u_environ;
+
+    // The sig_atomic_t variables reside in untrusted memory!
+    struct seng_ngx_sigatomics atomics;
+    long int ret = -1;
+    ocall_init_signal_atomics(&ret, &atomics);
+    if (ret == NGX_ERROR) abort();
+
+    uptr_ngx_quit = atomics.uptr_quit;
+    uptr_ngx_terminate = atomics.uptr_terminate;
+    uptr_ngx_reopen = atomics.uptr_reopen;
+    uptr_ngx_reconfigure = atomics.uptr_reconfigure;
+    
+    // Check that they indeed point to untrusted memory
+    if (!uptr_ngx_quit || !uptr_ngx_terminate || !uptr_ngx_reopen || !uptr_ngx_reconfigure ||
+        !sgx_is_outside_enclave(uptr_ngx_quit, sizeof(sig_atomic_t)) ||
+        !sgx_is_outside_enclave(uptr_ngx_terminate, sizeof(sig_atomic_t)) ||
+        !sgx_is_outside_enclave(uptr_ngx_reopen, sizeof(sig_atomic_t)) ||
+        !sgx_is_outside_enclave(uptr_ngx_reconfigure, sizeof(sig_atomic_t))) {
+            abort();
+    }
+
+    return trusted_nginx_main(u_argc, u_argv);
+}
+
+
+int ngx_cdecl
+trusted_nginx_main(int argc, char *const *argv)
+{
+    ngx_buf_t        *b;
+    ngx_log_t        *log;
+    ngx_uint_t        i;
+    ngx_cycle_t      *cycle, init_cycle;
+    ngx_conf_dump_t  *cd;
+    ngx_core_conf_t  *ccf;
+
+    ngx_debug_init();
+
+    if (ngx_strerror_init() != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_get_options(argc, argv) != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_show_version) {
+        ngx_show_version_info();
+
+        if (!ngx_test_config) {
+            return 0;
+        }
+    }
+
+    /* TODO */ ngx_max_sockets = -1;
+
+    ngx_time_init();
+
+#if (NGX_PCRE)
+    ngx_regex_init();
+#endif
+
+    ngx_pid = ngx_getpid();
+
+    log = ngx_log_init(ngx_prefix);
+    if (log == NULL) {
+        return 1;
+    }
+
+    /* STUB */
+#if (NGX_OPENSSL)
+    ngx_ssl_init(log);
+#endif
+
+    /*
+     * init_cycle->log is required for signal handlers and
+     * ngx_process_options()
+     */
+
+    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
+    init_cycle.log = log;
+    ngx_cycle = &init_cycle;
+
+    init_cycle.pool = ngx_create_pool(1024, log);
+    if (init_cycle.pool == NULL) {
+        return 1;
+    }
+
+    if (ngx_save_argv(&init_cycle, argc, argv) != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_process_options(&init_cycle) != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_os_init(log) != NGX_OK) {
+        return 1;
+    }
+
+    /*
+     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()
+     */
+
+    if (ngx_crc32_table_init() != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_add_inherited_sockets(&init_cycle) != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_preinit_modules() != NGX_OK) {
+        return 1;
+    }
+
+    cycle = ngx_init_cycle(&init_cycle);
+    if (cycle == NULL) {
+        if (ngx_test_config) {
+            ngx_log_stderr(0, "configuration file %s test failed",
+                           init_cycle.conf_file.data);
+        }
+
+        return 1;
+    }
+
+    if (ngx_test_config) {
+        if (!ngx_quiet_mode) {
+            ngx_log_stderr(0, "configuration file %s test is successful",
+                           cycle->conf_file.data);
+        }
+
+        if (ngx_dump_config) {
+            cd = cycle->config_dump.elts;
+
+            for (i = 0; i < cycle->config_dump.nelts; i++) {
+
+                ngx_write_stdout("# configuration file ");
+                (void) ngx_write_fd(ngx_stdout, cd[i].name.data,
+                                    cd[i].name.len);
+                ngx_write_stdout(":" NGX_LINEFEED);
+
+                b = cd[i].buffer;
+
+                (void) ngx_write_fd(ngx_stdout, b->pos, b->last - b->pos);
+                ngx_write_stdout(NGX_LINEFEED);
+            }
+        }
+
+        return 0;
+    }
+
+    if (ngx_signal) {
+        return ngx_signal_process(cycle, ngx_signal);
+    }
+
+    ngx_os_status(cycle->log);
+
+    ngx_cycle = cycle;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {
+        ngx_process = NGX_PROCESS_MASTER;
+    }
+
+#if !(NGX_WIN32)
+
+    if (ngx_init_signals(cycle->log) != NGX_OK) {
+        return 1;
+    }
+
+    if (!ngx_inherited && ccf->daemon) {
+        if (ngx_daemon(cycle->log) != NGX_OK) {
+            return 1;
+        }
+
+        ngx_daemonized = 1;
+    }
+
+    if (ngx_inherited) {
+        ngx_daemonized = 1;
+    }
+
+#endif
+
+    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {
+        return 1;
+    }
+
+    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {
+        return 1;
+    }
+
+    if (log->file->fd != ngx_stderr) {
+        if (ngx_close_file(log->file->fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                          ngx_close_file_n " built-in log failed");
+        }
+    }
+
+    ngx_use_stderr = 0;
+
+    if (ngx_process == NGX_PROCESS_SINGLE) {
+        ngx_single_process_cycle(cycle);
+
+    } else {
+        ngx_master_process_cycle(cycle);
+    }
+
+    return 0;
+}
+
+
+static void
+ngx_show_version_info(void)
+{
+    ngx_write_stderr("nginx version: " NGINX_VER_BUILD NGX_LINEFEED);
+
+    if (ngx_show_help) {
+        ngx_write_stderr(
+            "Usage: nginx [-?hvVtTq] [-s signal] [-c filename] "
+                         "[-p prefix] [-g directives]" NGX_LINEFEED
+                         NGX_LINEFEED
+            "Options:" NGX_LINEFEED
+            "  -?,-h         : this help" NGX_LINEFEED
+            "  -v            : show version and exit" NGX_LINEFEED
+            "  -V            : show version and configure options then exit"
+                               NGX_LINEFEED
+            "  -t            : test configuration and exit" NGX_LINEFEED
+            "  -T            : test configuration, dump it and exit"
+                               NGX_LINEFEED
+            "  -q            : suppress non-error messages "
+                               "during configuration testing" NGX_LINEFEED
+            "  -s signal     : send signal to a master process: "
+                               "stop, quit, reopen, reload" NGX_LINEFEED
+#ifdef NGX_PREFIX
+            "  -p prefix     : set prefix path (default: " NGX_PREFIX ")"
+                               NGX_LINEFEED
+#else
+            "  -p prefix     : set prefix path (default: NONE)" NGX_LINEFEED
+#endif
+            "  -c filename   : set configuration file (default: " NGX_CONF_PATH
+                               ")" NGX_LINEFEED
+            "  -g directives : set global directives out of configuration "
+                               "file" NGX_LINEFEED NGX_LINEFEED
+        );
+    }
+
+    if (ngx_show_configure) {
+
+#ifdef NGX_COMPILER
+        ngx_write_stderr("built by " NGX_COMPILER NGX_LINEFEED);
+#endif
+
+#if (NGX_SSL)
+        if (ngx_strcmp(ngx_ssl_version(), OPENSSL_VERSION_TEXT) == 0) {
+            ngx_write_stderr("built with " OPENSSL_VERSION_TEXT NGX_LINEFEED);
+        } else {
+            ngx_write_stderr("built with " OPENSSL_VERSION_TEXT
+                             " (running with ");
+            ngx_write_stderr((char *) (uintptr_t) ngx_ssl_version());
+            ngx_write_stderr(")" NGX_LINEFEED);
+        }
+#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+        ngx_write_stderr("TLS SNI support enabled" NGX_LINEFEED);
+#else
+        ngx_write_stderr("TLS SNI support disabled" NGX_LINEFEED);
+#endif
+#endif
+
+        ngx_write_stderr("configure arguments:" NGX_CONFIGURE NGX_LINEFEED);
+    }
+}
+
+
+static ngx_int_t
+ngx_add_inherited_sockets(ngx_cycle_t *cycle)
+{
+    u_char           *p, *v, *inherited;
+    ngx_int_t         s;
+    ngx_listening_t  *ls;
+
+    inherited = (u_char *) getenv(NGINX_VAR);
+
+    if (inherited == NULL) {
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
+                  "using inherited sockets from \"%s\"", inherited);
+
+    if (ngx_array_init(&cycle->listening, cycle->pool, 10,
+                       sizeof(ngx_listening_t))
+        != NGX_OK)
+    {
+        return NGX_ERROR;
+    }
+
+    for (p = inherited, v = p; *p; p++) {
+        if (*p == ':' || *p == ';') {
+            s = ngx_atoi(v, p - v);
+            if (s == NGX_ERROR) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "invalid socket number \"%s\" in " NGINX_VAR
+                              " environment variable, ignoring the rest"
+                              " of the variable", v);
+                break;
+            }
+
+            v = p + 1;
+
+            ls = ngx_array_push(&cycle->listening);
+            if (ls == NULL) {
+                return NGX_ERROR;
+            }
+
+            ngx_memzero(ls, sizeof(ngx_listening_t));
+
+            ls->fd = (ngx_socket_t) s;
+        }
+    }
+
+    if (v != p) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid socket number \"%s\" in " NGINX_VAR
+                      " environment variable, ignoring", v);
+    }
+
+    ngx_inherited = 1;
+
+    return ngx_set_inherited_sockets(cycle);
+}
+
+
+char **
+ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)
+{
+    char             **p, **env;
+    ngx_str_t         *var;
+    ngx_uint_t         i, n;
+    ngx_core_conf_t   *ccf;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    if (last == NULL && ccf->environment) {
+        return ccf->environment;
+    }
+
+    var = ccf->env.elts;
+
+    for (i = 0; i < ccf->env.nelts; i++) {
+        if (ngx_strcmp(var[i].data, "TZ") == 0
+            || ngx_strncmp(var[i].data, "TZ=", 3) == 0)
+        {
+            goto tz_found;
+        }
+    }
+
+    var = ngx_array_push(&ccf->env);
+    if (var == NULL) {
+        return NULL;
+    }
+
+    var->len = 2;
+    var->data = (u_char *) "TZ";
+
+    var = ccf->env.elts;
+
+tz_found:
+
+    n = 0;
+
+    for (i = 0; i < ccf->env.nelts; i++) {
+
+        if (var[i].data[var[i].len] == '=') {
+            n++;
+            continue;
+        }
+
+        for (p = ngx_os_environ; *p; p++) {
+
+            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0
+                && (*p)[var[i].len] == '=')
+            {
+                n++;
+                break;
+            }
+        }
+    }
+
+    if (last) {
+        env = ngx_alloc((*last + n + 1) * sizeof(char *), cycle->log);
+        *last = n;
+
+    } else {
+        env = ngx_palloc(cycle->pool, (n + 1) * sizeof(char *));
+    }
+
+    if (env == NULL) {
+        return NULL;
+    }
+
+    n = 0;
+
+    for (i = 0; i < ccf->env.nelts; i++) {
+
+        if (var[i].data[var[i].len] == '=') {
+            env[n++] = (char *) var[i].data;
+            continue;
+        }
+
+        for (p = ngx_os_environ; *p; p++) {
+
+            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0
+                && (*p)[var[i].len] == '=')
+            {
+                env[n++] = *p;
+                break;
+            }
+        }
+    }
+
+    env[n] = NULL;
+
+    if (last == NULL) {
+        ccf->environment = env;
+        environ = env;
+    }
+
+    return env;
+}
+
+
+ngx_pid_t
+ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)
+{
+    char             **env, *var;
+    u_char            *p;
+    ngx_uint_t         i, n;
+    ngx_pid_t          pid;
+    ngx_exec_ctx_t     ctx;
+    ngx_core_conf_t   *ccf;
+    ngx_listening_t   *ls;
+
+    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));
+
+    ctx.path = argv[0];
+    ctx.name = "new binary process";
+    ctx.argv = argv;
+
+    n = 2;
+    env = ngx_set_environment(cycle, &n);
+    if (env == NULL) {
+        return NGX_INVALID_PID;
+    }
+
+    var = ngx_alloc(sizeof(NGINX_VAR)
+                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,
+                    cycle->log);
+    if (var == NULL) {
+        ngx_free(env);
+        return NGX_INVALID_PID;
+    }
+
+    p = ngx_cpymem(var, NGINX_VAR "=", sizeof(NGINX_VAR));
+
+    ls = cycle->listening.elts;
+    for (i = 0; i < cycle->listening.nelts; i++) {
+        p = ngx_sprintf(p, "%ud;", ls[i].fd);
+    }
+
+    *p = '\0';
+
+    env[n++] = var;
+
+#if (NGX_SETPROCTITLE_USES_ENV)
+
+    /* allocate the spare 300 bytes for the new binary process title */
+
+    env[n++] = "SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
+               "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
+               "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
+               "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
+               "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
+
+#endif
+
+    env[n] = NULL;
+
+#if (NGX_DEBUG)
+    {
+    char  **e;
+    for (e = env; *e; e++) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, "env: %s", *e);
+    }
+    }
+#endif
+
+    ctx.envp = (char *const *) env;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                      ngx_rename_file_n " %s to %s failed "
+                      "before executing new binary process \"%s\"",
+                      ccf->pid.data, ccf->oldpid.data, argv[0]);
+
+        ngx_free(env);
+        ngx_free(var);
+
+        return NGX_INVALID_PID;
+    }
+
+    pid = ngx_execute(cycle, &ctx);
+
+    if (pid == NGX_INVALID_PID) {
+        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data)
+            == NGX_FILE_ERROR)
+        {
+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                          ngx_rename_file_n " %s back to %s failed after "
+                          "an attempt to execute new binary process \"%s\"",
+                          ccf->oldpid.data, ccf->pid.data, argv[0]);
+        }
+    }
+
+    ngx_free(env);
+    ngx_free(var);
+
+    return pid;
+}
+
+
+static ngx_int_t
+ngx_get_options(int argc, char *const *argv)
+{
+    u_char     *p;
+    ngx_int_t   i;
+
+    for (i = 1; i < argc; i++) {
+
+        p = (u_char *) argv[i];
+
+        if (*p++ != '-') {
+            ngx_log_stderr(0, "invalid option: \"%s\"", argv[i]);
+            return NGX_ERROR;
+        }
+
+        while (*p) {
+
+            switch (*p++) {
+
+            case '?':
+            case 'h':
+                ngx_show_version = 1;
+                ngx_show_help = 1;
+                break;
+
+            case 'v':
+                ngx_show_version = 1;
+                break;
+
+            case 'V':
+                ngx_show_version = 1;
+                ngx_show_configure = 1;
+                break;
+
+            case 't':
+                ngx_test_config = 1;
+                break;
+
+            case 'T':
+                ngx_test_config = 1;
+                ngx_dump_config = 1;
+                break;
+
+            case 'q':
+                ngx_quiet_mode = 1;
+                break;
+
+            case 'p':
+                if (*p) {
+                    ngx_prefix = p;
+                    goto next;
+                }
+
+                if (argv[++i]) {
+                    ngx_prefix = (u_char *) argv[i];
+                    goto next;
+                }
+
+                ngx_log_stderr(0, "option \"-p\" requires directory name");
+                return NGX_ERROR;
+
+            case 'c':
+                if (*p) {
+                    ngx_conf_file = p;
+                    goto next;
+                }
+
+                if (argv[++i]) {
+                    ngx_conf_file = (u_char *) argv[i];
+                    goto next;
+                }
+
+                ngx_log_stderr(0, "option \"-c\" requires file name");
+                return NGX_ERROR;
+
+            case 'g':
+                if (*p) {
+                    ngx_conf_params = p;
+                    goto next;
+                }
+
+                if (argv[++i]) {
+                    ngx_conf_params = (u_char *) argv[i];
+                    goto next;
+                }
+
+                ngx_log_stderr(0, "option \"-g\" requires parameter");
+                return NGX_ERROR;
+
+            case 's':
+                if (*p) {
+                    ngx_signal = (char *) p;
+
+                } else if (argv[++i]) {
+                    ngx_signal = argv[i];
+
+                } else {
+                    ngx_log_stderr(0, "option \"-s\" requires parameter");
+                    return NGX_ERROR;
+                }
+
+                if (ngx_strcmp(ngx_signal, "stop") == 0
+                    || ngx_strcmp(ngx_signal, "quit") == 0
+                    || ngx_strcmp(ngx_signal, "reopen") == 0
+                    || ngx_strcmp(ngx_signal, "reload") == 0)
+                {
+                    ngx_process = NGX_PROCESS_SIGNALLER;
+                    goto next;
+                }
+
+                ngx_log_stderr(0, "invalid option: \"-s %s\"", ngx_signal);
+                return NGX_ERROR;
+
+            default:
+                ngx_log_stderr(0, "invalid option: \"%c\"", *(p - 1));
+                return NGX_ERROR;
+            }
+        }
+
+    next:
+
+        continue;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)
+{
+#if (NGX_FREEBSD)
+
+    ngx_os_argv = (char **) argv;
+    ngx_argc = argc;
+    ngx_argv = (char **) argv;
+
+#else
+    size_t     len;
+    ngx_int_t  i;
+
+    ngx_os_argv = (char **) argv;
+    ngx_argc = argc;
+
+    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);
+    if (ngx_argv == NULL) {
+        return NGX_ERROR;
+    }
+
+    for (i = 0; i < argc; i++) {
+        len = ngx_strlen(argv[i]) + 1;
+
+        ngx_argv[i] = ngx_alloc(len, cycle->log);
+        if (ngx_argv[i] == NULL) {
+            return NGX_ERROR;
+        }
+
+        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);
+    }
+
+    ngx_argv[i] = NULL;
+
+#endif
+
+    ngx_os_environ = environ;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_process_options(ngx_cycle_t *cycle)
+{
+    u_char  *p;
+    size_t   len;
+
+    if (ngx_prefix) {
+        len = ngx_strlen(ngx_prefix);
+        p = ngx_prefix;
+
+        if (len && !ngx_path_separator(p[len - 1])) {
+            p = ngx_pnalloc(cycle->pool, len + 1);
+            if (p == NULL) {
+                return NGX_ERROR;
+            }
+
+            ngx_memcpy(p, ngx_prefix, len);
+            p[len++] = '/';
+        }
+
+        cycle->conf_prefix.len = len;
+        cycle->conf_prefix.data = p;
+        cycle->prefix.len = len;
+        cycle->prefix.data = p;
+
+    } else {
+
+#ifndef NGX_PREFIX
+
+        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {
+            ngx_log_stderr(ngx_errno, "[emerg]: " ngx_getcwd_n " failed");
+            return NGX_ERROR;
+        }
+
+        len = ngx_strlen(p);
+
+        p[len++] = '/';
+
+        cycle->conf_prefix.len = len;
+        cycle->conf_prefix.data = p;
+        cycle->prefix.len = len;
+        cycle->prefix.data = p;
+
+#else
+
+#ifdef NGX_CONF_PREFIX
+        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);
+#else
+        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);
+#endif
+        ngx_str_set(&cycle->prefix, NGX_PREFIX);
+
+#endif
+    }
+
+    if (ngx_conf_file) {
+        cycle->conf_file.len = ngx_strlen(ngx_conf_file);
+        cycle->conf_file.data = ngx_conf_file;
+
+    } else {
+        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);
+    }
+
+    if (ngx_conf_full_name(cycle, &cycle->conf_file, 0) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;
+         p > cycle->conf_file.data;
+         p--)
+    {
+        if (ngx_path_separator(*p)) {
+            cycle->conf_prefix.len = p - ngx_cycle->conf_file.data + 1;
+            cycle->conf_prefix.data = ngx_cycle->conf_file.data;
+            break;
+        }
+    }
+
+    if (ngx_conf_params) {
+        cycle->conf_param.len = ngx_strlen(ngx_conf_params);
+        cycle->conf_param.data = ngx_conf_params;
+    }
+
+    if (ngx_test_config) {
+        cycle->log->log_level = NGX_LOG_INFO;
+    }
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_core_module_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_core_conf_t  *ccf;
+
+    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));
+    if (ccf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc()
+     *
+     *     ccf->pid = NULL;
+     *     ccf->oldpid = NULL;
+     *     ccf->priority = 0;
+     *     ccf->cpu_affinity_auto = 0;
+     *     ccf->cpu_affinity_n = 0;
+     *     ccf->cpu_affinity = NULL;
+     */
+
+    ccf->daemon = NGX_CONF_UNSET;
+    ccf->master = NGX_CONF_UNSET;
+    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;
+
+    ccf->worker_processes = NGX_CONF_UNSET;
+    ccf->debug_points = NGX_CONF_UNSET;
+
+    ccf->rlimit_nofile = NGX_CONF_UNSET;
+    ccf->rlimit_core = NGX_CONF_UNSET;
+
+    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;
+    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;
+
+    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    return ccf;
+}
+
+
+static char *
+ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_core_conf_t  *ccf = conf;
+
+    // SENG: currently only single-proccess mode
+    ngx_conf_init_value(ccf->daemon, 0);
+    ngx_conf_init_value(ccf->master, 0);
+
+    ngx_conf_init_msec_value(ccf->timer_resolution, 0);
+
+    ngx_conf_init_value(ccf->worker_processes, 1);
+    ngx_conf_init_value(ccf->debug_points, 0);
+
+#if (NGX_HAVE_CPU_AFFINITY)
+
+    if (!ccf->cpu_affinity_auto
+        && ccf->cpu_affinity_n
+        && ccf->cpu_affinity_n != 1
+        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)
+    {
+        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
+                      "the number of \"worker_processes\" is not equal to "
+                      "the number of \"worker_cpu_affinity\" masks, "
+                      "using last mask for remaining worker processes");
+    }
+
+#endif
+
+
+    if (ccf->pid.len == 0) {
+        ngx_str_set(&ccf->pid, NGX_PID_PATH);
+    }
+
+    if (ngx_conf_full_name(cycle, &ccf->pid, 0) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    ccf->oldpid.len = ccf->pid.len + sizeof(NGX_OLDPID_EXT);
+
+    ccf->oldpid.data = ngx_pnalloc(cycle->pool, ccf->oldpid.len);
+    if (ccf->oldpid.data == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memcpy(ngx_cpymem(ccf->oldpid.data, ccf->pid.data, ccf->pid.len),
+               NGX_OLDPID_EXT, sizeof(NGX_OLDPID_EXT));
+
+
+#if !(NGX_WIN32)
+
+    if (ccf->user == (uid_t) NGX_CONF_UNSET_UINT && geteuid() == 0) {
+        struct group   *grp;
+        struct passwd  *pwd;
+
+        ngx_set_errno(0);
+        pwd = getpwnam(NGX_USER);
+        if (pwd == NULL) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "getpwnam(\"" NGX_USER "\") failed");
+            return NGX_CONF_ERROR;
+        }
+
+        ccf->username = NGX_USER;
+        ccf->user = pwd->pw_uid;
+
+        ngx_set_errno(0);
+        grp = getgrnam(NGX_GROUP);
+        if (grp == NULL) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "getgrnam(\"" NGX_GROUP "\") failed");
+            return NGX_CONF_ERROR;
+        }
+
+        ccf->group = grp->gr_gid;
+    }
+
+
+    if (ccf->lock_file.len == 0) {
+        ngx_str_set(&ccf->lock_file, NGX_LOCK_PATH);
+    }
+
+    if (ngx_conf_full_name(cycle, &ccf->lock_file, 0) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    {
+    ngx_str_t  lock_file;
+
+    lock_file = cycle->old_cycle->lock_file;
+
+    if (lock_file.len) {
+        lock_file.len--;
+
+        if (ccf->lock_file.len != lock_file.len
+            || ngx_strncmp(ccf->lock_file.data, lock_file.data, lock_file.len)
+               != 0)
+        {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"lock_file\" could not be changed, ignored");
+        }
+
+        cycle->lock_file.len = lock_file.len + 1;
+        lock_file.len += sizeof(".accept");
+
+        cycle->lock_file.data = ngx_pstrdup(cycle->pool, &lock_file);
+        if (cycle->lock_file.data == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+    } else {
+        cycle->lock_file.len = ccf->lock_file.len + 1;
+        cycle->lock_file.data = ngx_pnalloc(cycle->pool,
+                                      ccf->lock_file.len + sizeof(".accept"));
+        if (cycle->lock_file.data == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        ngx_memcpy(ngx_cpymem(cycle->lock_file.data, ccf->lock_file.data,
+                              ccf->lock_file.len),
+                   ".accept", sizeof(".accept"));
+    }
+    }
+
+#endif
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+#if (NGX_WIN32)
+
+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                       "\"user\" is not supported, ignored");
+
+    return NGX_CONF_OK;
+
+#else
+
+    ngx_core_conf_t  *ccf = conf;
+
+    char             *group;
+    struct passwd    *pwd;
+    struct group     *grp;
+    ngx_str_t        *value;
+
+    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {
+        return "is duplicate";
+    }
+
+    if (geteuid() != 0) {
+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                           "the \"user\" directive makes sense only "
+                           "if the master process runs "
+                           "with super-user privileges, ignored");
+        return NGX_CONF_OK;
+    }
+
+    value = cf->args->elts;
+
+    ccf->username = (char *) value[1].data;
+
+    ngx_set_errno(0);
+    pwd = getpwnam((const char *) value[1].data);
+    if (pwd == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
+                           "getpwnam(\"%s\") failed", value[1].data);
+        return NGX_CONF_ERROR;
+    }
+
+    ccf->user = pwd->pw_uid;
+
+    group = (char *) ((cf->args->nelts == 2) ? value[1].data : value[2].data);
+
+    ngx_set_errno(0);
+    grp = getgrnam(group);
+    if (grp == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
+                           "getgrnam(\"%s\") failed", group);
+        return NGX_CONF_ERROR;
+    }
+
+    ccf->group = grp->gr_gid;
+
+    return NGX_CONF_OK;
+
+#endif
+}
+
+
+static char *
+ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_core_conf_t  *ccf = conf;
+
+    ngx_str_t   *value, *var;
+    ngx_uint_t   i;
+
+    var = ngx_array_push(&ccf->env);
+    if (var == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    value = cf->args->elts;
+    *var = value[1];
+
+    for (i = 0; i < value[1].len; i++) {
+
+        if (value[1].data[i] == '=') {
+
+            var->len = i;
+
+            return NGX_CONF_OK;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_core_conf_t  *ccf = conf;
+
+    ngx_str_t        *value;
+    ngx_uint_t        n, minus;
+
+    if (ccf->priority != 0) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (value[1].data[0] == '-') {
+        n = 1;
+        minus = 1;
+
+    } else if (value[1].data[0] == '+') {
+        n = 1;
+        minus = 0;
+
+    } else {
+        n = 0;
+        minus = 0;
+    }
+
+    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);
+    if (ccf->priority == NGX_ERROR) {
+        return "invalid number";
+    }
+
+    if (minus) {
+        ccf->priority = -ccf->priority;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+#if (NGX_HAVE_CPU_AFFINITY)
+    ngx_core_conf_t  *ccf = conf;
+
+    u_char            ch, *p;
+    ngx_str_t        *value;
+    ngx_uint_t        i, n;
+    ngx_cpuset_t     *mask;
+
+    if (ccf->cpu_affinity) {
+        return "is duplicate";
+    }
+
+    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));
+    if (mask == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ccf->cpu_affinity_n = cf->args->nelts - 1;
+    ccf->cpu_affinity = mask;
+
+    value = cf->args->elts;
+
+    if (ngx_strcmp(value[1].data, "auto") == 0) {
+
+        if (cf->args->nelts > 3) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid number of arguments in "
+                               "\"worker_cpu_affinity\" directive");
+            return NGX_CONF_ERROR;
+        }
+
+        ccf->cpu_affinity_auto = 1;
+
+        CPU_ZERO(&mask[0]);
+        for (i = 0; i < (ngx_uint_t) ngx_min(ngx_ncpu, CPU_SETSIZE); i++) {
+            CPU_SET(i, &mask[0]);
+        }
+
+        n = 2;
+
+    } else {
+        n = 1;
+    }
+
+    for ( /* void */ ; n < cf->args->nelts; n++) {
+
+        if (value[n].len > CPU_SETSIZE) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                         "\"worker_cpu_affinity\" supports up to %d CPUs only",
+                         CPU_SETSIZE);
+            return NGX_CONF_ERROR;
+        }
+
+        i = 0;
+        CPU_ZERO(&mask[n - 1]);
+
+        for (p = value[n].data + value[n].len - 1;
+             p >= value[n].data;
+             p--)
+        {
+            ch = *p;
+
+            if (ch == ' ') {
+                continue;
+            }
+
+            i++;
+
+            if (ch == '0') {
+                continue;
+            }
+
+            if (ch == '1') {
+                CPU_SET(i - 1, &mask[n - 1]);
+                continue;
+            }
+
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                          "invalid character \"%c\" in \"worker_cpu_affinity\"",
+                          ch);
+            return NGX_CONF_ERROR;
+        }
+    }
+
+#else
+
+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                       "\"worker_cpu_affinity\" is not supported "
+                       "on this platform, ignored");
+#endif
+
+    return NGX_CONF_OK;
+}
+
+
+ngx_cpuset_t *
+ngx_get_cpu_affinity(ngx_uint_t n)
+{
+#if (NGX_HAVE_CPU_AFFINITY)
+    ngx_uint_t        i, j;
+    ngx_cpuset_t     *mask;
+    ngx_core_conf_t  *ccf;
+
+    static ngx_cpuset_t  result;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,
+                                           ngx_core_module);
+
+    if (ccf->cpu_affinity == NULL) {
+        return NULL;
+    }
+
+    if (ccf->cpu_affinity_auto) {
+        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];
+
+        for (i = 0, j = n; /* void */ ; i++) {
+
+            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {
+                break;
+            }
+
+            if (i == CPU_SETSIZE && j == n) {
+                /* empty mask */
+                return NULL;
+            }
+
+            /* void */
+        }
+
+        CPU_ZERO(&result);
+        CPU_SET(i % CPU_SETSIZE, &result);
+
+        return &result;
+    }
+
+    if (ccf->cpu_affinity_n > n) {
+        return &ccf->cpu_affinity[n];
+    }
+
+    return &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];
+
+#else
+
+    return NULL;
+
+#endif
+}
+
+
+static char *
+ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t        *value;
+    ngx_core_conf_t  *ccf;
+
+    ccf = (ngx_core_conf_t *) conf;
+
+    if (ccf->worker_processes != NGX_CONF_UNSET) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    if (ngx_strcmp(value[1].data, "auto") == 0) {
+        ccf->worker_processes = ngx_ncpu;
+        return NGX_CONF_OK;
+    }
+
+    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);
+
+    if (ccf->worker_processes == NGX_ERROR) {
+        return "invalid value";
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+#if (NGX_HAVE_DLOPEN)
+    void                *handle;
+    char               **names, **order;
+    ngx_str_t           *value, file;
+    ngx_uint_t           i;
+    ngx_module_t        *module, **modules;
+    ngx_pool_cleanup_t  *cln;
+
+    if (cf->cycle->modules_used) {
+        return "is specified too late";
+    }
+
+    value = cf->args->elts;
+
+    file = value[1];
+
+    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    handle = ngx_dlopen(file.data);
+    if (handle == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           ngx_dlopen_n " \"%s\" failed (%s)",
+                           file.data, ngx_dlerror());
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_unload_module;
+    cln->data = handle;
+
+    modules = ngx_dlsym(handle, "ngx_modules");
+    if (modules == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           ngx_dlsym_n " \"%V\", \"%s\" failed (%s)",
+                           &value[1], "ngx_modules", ngx_dlerror());
+        return NGX_CONF_ERROR;
+    }
+
+    names = ngx_dlsym(handle, "ngx_module_names");
+    if (names == NULL) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           ngx_dlsym_n " \"%V\", \"%s\" failed (%s)",
+                           &value[1], "ngx_module_names", ngx_dlerror());
+        return NGX_CONF_ERROR;
+    }
+
+    order = ngx_dlsym(handle, "ngx_module_order");
+
+    for (i = 0; modules[i]; i++) {
+        module = modules[i];
+        module->name = names[i];
+
+        if (ngx_add_module(cf, &file, module, order) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cf->log, 0, "module: %s i:%ui",
+                       module->name, module->index);
+    }
+
+    return NGX_CONF_OK;
+
+#else
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "\"load_module\" is not supported "
+                       "on this platform");
+    return NGX_CONF_ERROR;
+
+#endif
+}
+
+
+#if (NGX_HAVE_DLOPEN)
+
+static void
+ngx_unload_module(void *data)
+{
+    void  *handle = data;
+
+    if (ngx_dlclose(handle) != 0) {
+        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,
+                      ngx_dlclose_n " failed (%s)", ngx_dlerror());
+    }
+}
+
+#endif
diff --git a/src/os/seng/trusted/core/t_nginx.h b/src/os/seng/trusted/core/t_nginx.h
new file mode 100644
index 0000000..a6a9b2f
--- /dev/null
+++ b/src/os/seng/trusted/core/t_nginx.h
@@ -0,0 +1,25 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _TNGINX_H_INCLUDED_
+#define _TNGINX_H_INCLUDED_
+
+
+#define nginx_version      1010003
+#define NGINX_VERSION      "1.10.3"
+#define NGINX_VER          "nginx/" NGINX_VERSION
+
+#ifdef NGX_BUILD
+#define NGINX_VER_BUILD    NGINX_VER " (" NGX_BUILD ")"
+#else
+#define NGINX_VER_BUILD    NGINX_VER
+#endif
+
+#define NGINX_VAR          "NGINX"
+#define NGX_OLDPID_EXT     ".oldbin"
+
+#endif /* _NGINX_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/core/t_ngx_cycle.c b/src/os/seng/trusted/core/t_ngx_cycle.c
new file mode 100644
index 0000000..cfd83ef
--- /dev/null
+++ b/src/os/seng/trusted/core/t_ngx_cycle.c
@@ -0,0 +1,1343 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+
+static void ngx_destroy_cycle_pools(ngx_conf_t *conf);
+static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle,
+    ngx_shm_zone_t *shm_zone);
+static ngx_int_t ngx_test_lockfile(u_char *file, ngx_log_t *log);
+static void ngx_clean_old_cycles(ngx_event_t *ev);
+
+
+volatile ngx_cycle_t  *ngx_cycle;
+ngx_array_t            ngx_old_cycles;
+
+static ngx_pool_t     *ngx_temp_pool;
+static ngx_event_t     ngx_cleaner_event;
+
+ngx_uint_t             ngx_test_config;
+ngx_uint_t             ngx_dump_config;
+ngx_uint_t             ngx_quiet_mode;
+
+
+/* STUB NAME */
+static ngx_connection_t  dumb;
+/* STUB */
+
+
+ngx_cycle_t *
+ngx_init_cycle(ngx_cycle_t *old_cycle)
+{
+    void                *rv;
+    char               **senv, **env;
+    ngx_uint_t           i, n;
+    ngx_log_t           *log;
+    ngx_time_t          *tp;
+    ngx_conf_t           conf;
+    ngx_pool_t          *pool;
+    ngx_cycle_t         *cycle, **old;
+    ngx_shm_zone_t      *shm_zone, *oshm_zone;
+    ngx_list_part_t     *part, *opart;
+    ngx_open_file_t     *file;
+    ngx_listening_t     *ls, *nls;
+    ngx_core_conf_t     *ccf, *old_ccf;
+    ngx_core_module_t   *module;
+    char                 hostname[NGX_MAXHOSTNAMELEN];
+
+    ngx_timezone_update();
+
+    /* force localtime update with a new timezone */
+
+    tp = ngx_timeofday();
+    tp->sec = 0;
+
+    ngx_time_update();
+
+
+    log = old_cycle->log;
+
+    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
+    if (pool == NULL) {
+        return NULL;
+    }
+    pool->log = log;
+
+    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
+    if (cycle == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    cycle->pool = pool;
+    cycle->log = log;
+    cycle->old_cycle = old_cycle;
+
+    cycle->conf_prefix.len = old_cycle->conf_prefix.len;
+    cycle->conf_prefix.data = ngx_pstrdup(pool, &old_cycle->conf_prefix);
+    if (cycle->conf_prefix.data == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    cycle->prefix.len = old_cycle->prefix.len;
+    cycle->prefix.data = ngx_pstrdup(pool, &old_cycle->prefix);
+    if (cycle->prefix.data == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    cycle->conf_file.len = old_cycle->conf_file.len;
+    cycle->conf_file.data = ngx_pnalloc(pool, old_cycle->conf_file.len + 1);
+    if (cycle->conf_file.data == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+    ngx_cpystrn(cycle->conf_file.data, old_cycle->conf_file.data,
+                old_cycle->conf_file.len + 1);
+
+    cycle->conf_param.len = old_cycle->conf_param.len;
+    cycle->conf_param.data = ngx_pstrdup(pool, &old_cycle->conf_param);
+    if (cycle->conf_param.data == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
+    n = old_cycle->paths.nelts ? old_cycle->paths.nelts : 10;
+
+    cycle->paths.elts = ngx_pcalloc(pool, n * sizeof(ngx_path_t *));
+    if (cycle->paths.elts == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    cycle->paths.nelts = 0;
+    cycle->paths.size = sizeof(ngx_path_t *);
+    cycle->paths.nalloc = n;
+    cycle->paths.pool = pool;
+
+
+    if (ngx_array_init(&cycle->config_dump, pool, 1, sizeof(ngx_conf_dump_t))
+        != NGX_OK)
+    {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    if (old_cycle->open_files.part.nelts) {
+        n = old_cycle->open_files.part.nelts;
+        for (part = old_cycle->open_files.part.next; part; part = part->next) {
+            n += part->nelts;
+        }
+
+    } else {
+        n = 20;
+    }
+
+    if (ngx_list_init(&cycle->open_files, pool, n, sizeof(ngx_open_file_t))
+        != NGX_OK)
+    {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
+    if (old_cycle->shared_memory.part.nelts) {
+        n = old_cycle->shared_memory.part.nelts;
+        for (part = old_cycle->shared_memory.part.next; part; part = part->next)
+        {
+            n += part->nelts;
+        }
+
+    } else {
+        n = 1;
+    }
+
+    if (ngx_list_init(&cycle->shared_memory, pool, n, sizeof(ngx_shm_zone_t))
+        != NGX_OK)
+    {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    n = old_cycle->listening.nelts ? old_cycle->listening.nelts : 10;
+
+    cycle->listening.elts = ngx_pcalloc(pool, n * sizeof(ngx_listening_t));
+    if (cycle->listening.elts == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    cycle->listening.nelts = 0;
+    cycle->listening.size = sizeof(ngx_listening_t);
+    cycle->listening.nalloc = n;
+    cycle->listening.pool = pool;
+
+
+    ngx_queue_init(&cycle->reusable_connections_queue);
+
+
+    cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));
+    if (cycle->conf_ctx == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
+    if (gethostname(hostname, NGX_MAXHOSTNAMELEN) == -1) {
+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, "gethostname() failed");
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    /* on Linux gethostname() silently truncates name that does not fit */
+
+    hostname[NGX_MAXHOSTNAMELEN - 1] = '\0';
+    cycle->hostname.len = ngx_strlen(hostname);
+
+    cycle->hostname.data = ngx_pnalloc(pool, cycle->hostname.len);
+    if (cycle->hostname.data == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    ngx_strlow(cycle->hostname.data, (u_char *) hostname, cycle->hostname.len);
+
+
+    if (ngx_cycle_modules(cycle) != NGX_OK) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
+    for (i = 0; cycle->modules[i]; i++) {
+        if (cycle->modules[i]->type != NGX_CORE_MODULE) {
+            continue;
+        }
+
+        module = cycle->modules[i]->ctx;
+
+        if (module->create_conf) {
+            rv = module->create_conf(cycle);
+            if (rv == NULL) {
+                ngx_destroy_pool(pool);
+                return NULL;
+            }
+            cycle->conf_ctx[cycle->modules[i]->index] = rv;
+        }
+    }
+
+
+    senv = environ;
+
+
+    ngx_memzero(&conf, sizeof(ngx_conf_t));
+    /* STUB: init array ? */
+    conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t));
+    if (conf.args == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);
+    if (conf.temp_pool == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
+    conf.ctx = cycle->conf_ctx;
+    conf.cycle = cycle;
+    conf.pool = pool;
+    conf.log = log;
+    conf.module_type = NGX_CORE_MODULE;
+    conf.cmd_type = NGX_MAIN_CONF;
+
+#if 0
+    log->log_level = NGX_LOG_DEBUG_ALL;
+#endif
+
+    if (ngx_conf_param(&conf) != NGX_CONF_OK) {
+        environ = senv;
+        ngx_destroy_cycle_pools(&conf);
+        return NULL;
+    }
+
+    if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_CONF_OK) {
+        environ = senv;
+        ngx_destroy_cycle_pools(&conf);
+        return NULL;
+    }
+
+    if (ngx_test_config && !ngx_quiet_mode) {
+        ngx_log_stderr(0, "the configuration file %s syntax is ok",
+                       cycle->conf_file.data);
+    }
+
+    for (i = 0; cycle->modules[i]; i++) {
+        if (cycle->modules[i]->type != NGX_CORE_MODULE) {
+            continue;
+        }
+
+        module = cycle->modules[i]->ctx;
+
+        if (module->init_conf) {
+            if (module->init_conf(cycle,
+                                  cycle->conf_ctx[cycle->modules[i]->index])
+                == NGX_CONF_ERROR)
+            {
+                environ = senv;
+                ngx_destroy_cycle_pools(&conf);
+                return NULL;
+            }
+        }
+    }
+
+    if (ngx_process == NGX_PROCESS_SIGNALLER) {
+        return cycle;
+    }
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    if (ngx_test_config) {
+
+        if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {
+            goto failed;
+        }
+
+    } else if (!ngx_is_init_cycle(old_cycle)) {
+
+        /*
+         * we do not create the pid file in the first ngx_init_cycle() call
+         * because we need to write the demonized process pid
+         */
+
+        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,
+                                                   ngx_core_module);
+        if (ccf->pid.len != old_ccf->pid.len
+            || ngx_strcmp(ccf->pid.data, old_ccf->pid.data) != 0)
+        {
+            /* new pid file name */
+
+            if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {
+                goto failed;
+            }
+
+            ngx_delete_pidfile(old_cycle);
+        }
+    }
+
+
+    if (ngx_test_lockfile(cycle->lock_file.data, log) != NGX_OK) {
+        goto failed;
+    }
+
+
+    if (ngx_create_paths(cycle, ccf->user) != NGX_OK) {
+        goto failed;
+    }
+
+
+    if (ngx_log_open_default(cycle) != NGX_OK) {
+        goto failed;
+    }
+
+    /* open the new files */
+
+    part = &cycle->open_files.part;
+    file = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            file = part->elts;
+            i = 0;
+        }
+
+        if (file[i].name.len == 0) {
+            continue;
+        }
+
+        file[i].fd = ngx_open_file(file[i].name.data,
+                                   NGX_FILE_APPEND,
+                                   NGX_FILE_CREATE_OR_OPEN,
+                                   NGX_FILE_DEFAULT_ACCESS);
+
+        ngx_log_debug3(NGX_LOG_DEBUG_CORE, log, 0,
+                       "log: %p %d \"%s\"",
+                       &file[i], file[i].fd, file[i].name.data);
+
+        if (file[i].fd == NGX_INVALID_FILE) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                          ngx_open_file_n " \"%s\" failed",
+                          file[i].name.data);
+            goto failed;
+        }
+
+#if !(NGX_WIN32)
+        if (seng_file_fcntl3(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                          "fcntl(FD_CLOEXEC) \"%s\" failed",
+                          file[i].name.data);
+            goto failed;
+        }
+#endif
+    }
+
+    cycle->log = &cycle->new_log;
+    pool->log = &cycle->new_log;
+
+
+    /* create shared memory */
+
+    part = &cycle->shared_memory.part;
+    shm_zone = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            shm_zone = part->elts;
+            i = 0;
+        }
+
+        if (shm_zone[i].shm.size == 0) {
+            ngx_log_error(NGX_LOG_EMERG, log, 0,
+                          "zero size shared memory zone \"%V\"",
+                          &shm_zone[i].shm.name);
+            goto failed;
+        }
+
+        shm_zone[i].shm.log = cycle->log;
+
+        opart = &old_cycle->shared_memory.part;
+        oshm_zone = opart->elts;
+
+        for (n = 0; /* void */ ; n++) {
+
+            if (n >= opart->nelts) {
+                if (opart->next == NULL) {
+                    break;
+                }
+                opart = opart->next;
+                oshm_zone = opart->elts;
+                n = 0;
+            }
+
+            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {
+                continue;
+            }
+
+            if (ngx_strncmp(shm_zone[i].shm.name.data,
+                            oshm_zone[n].shm.name.data,
+                            shm_zone[i].shm.name.len)
+                != 0)
+            {
+                continue;
+            }
+
+            if (shm_zone[i].tag == oshm_zone[n].tag
+                && shm_zone[i].shm.size == oshm_zone[n].shm.size
+                && !shm_zone[i].noreuse)
+            {
+                shm_zone[i].shm.addr = oshm_zone[n].shm.addr;
+#if (NGX_WIN32)
+                shm_zone[i].shm.handle = oshm_zone[n].shm.handle;
+#endif
+
+                if (shm_zone[i].init(&shm_zone[i], oshm_zone[n].data)
+                    != NGX_OK)
+                {
+                    goto failed;
+                }
+
+                goto shm_zone_found;
+            }
+
+            ngx_shm_free(&oshm_zone[n].shm);
+
+            break;
+        }
+
+        if (ngx_shm_alloc(&shm_zone[i].shm) != NGX_OK) {
+            goto failed;
+        }
+
+        if (ngx_init_zone_pool(cycle, &shm_zone[i]) != NGX_OK) {
+            goto failed;
+        }
+
+        if (shm_zone[i].init(&shm_zone[i], NULL) != NGX_OK) {
+            goto failed;
+        }
+
+    shm_zone_found:
+
+        continue;
+    }
+
+
+    /* handle the listening sockets */
+
+    if (old_cycle->listening.nelts) {
+        ls = old_cycle->listening.elts;
+        for (i = 0; i < old_cycle->listening.nelts; i++) {
+            ls[i].remain = 0;
+        }
+
+        nls = cycle->listening.elts;
+        for (n = 0; n < cycle->listening.nelts; n++) {
+
+            for (i = 0; i < old_cycle->listening.nelts; i++) {
+                if (ls[i].ignore) {
+                    continue;
+                }
+
+                if (ls[i].remain) {
+                    continue;
+                }
+
+                if (ls[i].type != nls[n].type) {
+                    continue;
+                }
+
+                if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,
+                                     ls[i].sockaddr, ls[i].socklen, 1)
+                    == NGX_OK)
+                {
+                    nls[n].fd = ls[i].fd;
+                    nls[n].previous = &ls[i];
+                    ls[i].remain = 1;
+
+                    if (ls[i].backlog != nls[n].backlog) {
+                        nls[n].listen = 1;
+                    }
+
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
+
+                    /*
+                     * FreeBSD, except the most recent versions,
+                     * could not remove accept filter
+                     */
+                    nls[n].deferred_accept = ls[i].deferred_accept;
+
+                    if (ls[i].accept_filter && nls[n].accept_filter) {
+                        if (ngx_strcmp(ls[i].accept_filter,
+                                       nls[n].accept_filter)
+                            != 0)
+                        {
+                            nls[n].delete_deferred = 1;
+                            nls[n].add_deferred = 1;
+                        }
+
+                    } else if (ls[i].accept_filter) {
+                        nls[n].delete_deferred = 1;
+
+                    } else if (nls[n].accept_filter) {
+                        nls[n].add_deferred = 1;
+                    }
+#endif
+
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)
+
+                    if (ls[i].deferred_accept && !nls[n].deferred_accept) {
+                        nls[n].delete_deferred = 1;
+
+                    } else if (ls[i].deferred_accept != nls[n].deferred_accept)
+                    {
+                        nls[n].add_deferred = 1;
+                    }
+#endif
+
+#if (NGX_HAVE_REUSEPORT)
+                    if (nls[n].reuseport && !ls[i].reuseport) {
+                        nls[n].add_reuseport = 1;
+                    }
+#endif
+
+                    break;
+                }
+            }
+
+            if (nls[n].fd == (ngx_socket_t) -1) {
+                nls[n].open = 1;
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
+                if (nls[n].accept_filter) {
+                    nls[n].add_deferred = 1;
+                }
+#endif
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)
+                if (nls[n].deferred_accept) {
+                    nls[n].add_deferred = 1;
+                }
+#endif
+            }
+        }
+
+    } else {
+        ls = cycle->listening.elts;
+        for (i = 0; i < cycle->listening.nelts; i++) {
+            ls[i].open = 1;
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)
+            if (ls[i].accept_filter) {
+                ls[i].add_deferred = 1;
+            }
+#endif
+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)
+            if (ls[i].deferred_accept) {
+                ls[i].add_deferred = 1;
+            }
+#endif
+        }
+    }
+
+    if (ngx_open_listening_sockets(cycle) != NGX_OK) {
+        goto failed;
+    }
+
+    if (!ngx_test_config) {
+        ngx_configure_listening_sockets(cycle);
+    }
+
+
+    /* commit the new cycle configuration */
+
+    if (!ngx_use_stderr) {
+        (void) ngx_log_redirect_stderr(cycle);
+    }
+
+    pool->log = cycle->log;
+
+    if (ngx_init_modules(cycle) != NGX_OK) {
+        /* fatal */
+        exit(1);
+    }
+
+
+    /* close and delete stuff that lefts from an old cycle */
+
+    /* free the unnecessary shared memory */
+
+    opart = &old_cycle->shared_memory.part;
+    oshm_zone = opart->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= opart->nelts) {
+            if (opart->next == NULL) {
+                goto old_shm_zone_done;
+            }
+            opart = opart->next;
+            oshm_zone = opart->elts;
+            i = 0;
+        }
+
+        part = &cycle->shared_memory.part;
+        shm_zone = part->elts;
+
+        for (n = 0; /* void */ ; n++) {
+
+            if (n >= part->nelts) {
+                if (part->next == NULL) {
+                    break;
+                }
+                part = part->next;
+                shm_zone = part->elts;
+                n = 0;
+            }
+
+            if (oshm_zone[i].shm.name.len == shm_zone[n].shm.name.len
+                && ngx_strncmp(oshm_zone[i].shm.name.data,
+                               shm_zone[n].shm.name.data,
+                               oshm_zone[i].shm.name.len)
+                == 0)
+            {
+                goto live_shm_zone;
+            }
+        }
+
+        ngx_shm_free(&oshm_zone[i].shm);
+
+    live_shm_zone:
+
+        continue;
+    }
+
+old_shm_zone_done:
+
+
+    /* close the unnecessary listening sockets */
+
+    ls = old_cycle->listening.elts;
+    for (i = 0; i < old_cycle->listening.nelts; i++) {
+
+        if (ls[i].remain || ls[i].fd == (ngx_socket_t) -1) {
+            continue;
+        }
+
+        if (ngx_close_socket(ls[i].fd) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,
+                          ngx_close_socket_n " listening socket on %V failed",
+                          &ls[i].addr_text);
+        }
+
+#if (NGX_HAVE_UNIX_DOMAIN)
+
+        if (ls[i].sockaddr->sa_family == AF_UNIX) {
+            u_char  *name;
+
+            name = ls[i].addr_text.data + sizeof("unix:") - 1;
+
+            ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
+                          "deleting socket %s", name);
+
+            if (ngx_delete_file(name) == NGX_FILE_ERROR) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,
+                              ngx_delete_file_n " %s failed", name);
+            }
+        }
+
+#endif
+    }
+
+
+    /* close the unnecessary open files */
+
+    part = &old_cycle->open_files.part;
+    file = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            file = part->elts;
+            i = 0;
+        }
+
+        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {
+            continue;
+        }
+
+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed",
+                          file[i].name.data);
+        }
+    }
+
+    ngx_destroy_pool(conf.temp_pool);
+
+    if (ngx_process == NGX_PROCESS_MASTER || ngx_is_init_cycle(old_cycle)) {
+
+        /*
+         * perl_destruct() frees environ, if it is not the same as it was at
+         * perl_construct() time, therefore we save the previous cycle
+         * environment before ngx_conf_parse() where it will be changed.
+         */
+
+        env = environ;
+        environ = senv;
+
+        ngx_destroy_pool(old_cycle->pool);
+        cycle->old_cycle = NULL;
+
+        environ = env;
+
+        return cycle;
+    }
+
+
+    if (ngx_temp_pool == NULL) {
+        ngx_temp_pool = ngx_create_pool(128, cycle->log);
+        if (ngx_temp_pool == NULL) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "could not create ngx_temp_pool");
+            exit(1);
+        }
+
+        n = 10;
+        ngx_old_cycles.elts = ngx_pcalloc(ngx_temp_pool,
+                                          n * sizeof(ngx_cycle_t *));
+        if (ngx_old_cycles.elts == NULL) {
+            exit(1);
+        }
+        ngx_old_cycles.nelts = 0;
+        ngx_old_cycles.size = sizeof(ngx_cycle_t *);
+        ngx_old_cycles.nalloc = n;
+        ngx_old_cycles.pool = ngx_temp_pool;
+
+        ngx_cleaner_event.handler = ngx_clean_old_cycles;
+        ngx_cleaner_event.log = cycle->log;
+        ngx_cleaner_event.data = &dumb;
+        dumb.fd = (ngx_socket_t) -1;
+    }
+
+    ngx_temp_pool->log = cycle->log;
+
+    old = ngx_array_push(&ngx_old_cycles);
+    if (old == NULL) {
+        exit(1);
+    }
+    *old = old_cycle;
+
+    if (!ngx_cleaner_event.timer_set) {
+        ngx_add_timer(&ngx_cleaner_event, 30000);
+        ngx_cleaner_event.timer_set = 1;
+    }
+
+    return cycle;
+
+
+failed:
+
+    if (!ngx_is_init_cycle(old_cycle)) {
+        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,
+                                                   ngx_core_module);
+        if (old_ccf->environment) {
+            environ = old_ccf->environment;
+        }
+    }
+
+    /* rollback the new cycle configuration */
+
+    part = &cycle->open_files.part;
+    file = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            file = part->elts;
+            i = 0;
+        }
+
+        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {
+            continue;
+        }
+
+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed",
+                          file[i].name.data);
+        }
+    }
+
+    if (ngx_test_config) {
+        ngx_destroy_cycle_pools(&conf);
+        return NULL;
+    }
+
+    ls = cycle->listening.elts;
+    for (i = 0; i < cycle->listening.nelts; i++) {
+        if (ls[i].fd == (ngx_socket_t) -1 || !ls[i].open) {
+            continue;
+        }
+
+        if (ngx_close_socket(ls[i].fd) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,
+                          ngx_close_socket_n " %V failed",
+                          &ls[i].addr_text);
+        }
+    }
+
+    ngx_destroy_cycle_pools(&conf);
+
+    return NULL;
+}
+
+
+static void
+ngx_destroy_cycle_pools(ngx_conf_t *conf)
+{
+    ngx_destroy_pool(conf->temp_pool);
+    ngx_destroy_pool(conf->pool);
+}
+
+
+static ngx_int_t
+ngx_init_zone_pool(ngx_cycle_t *cycle, ngx_shm_zone_t *zn)
+{
+    u_char           *file;
+    ngx_slab_pool_t  *sp;
+
+    sp = (ngx_slab_pool_t *) zn->shm.addr;
+
+    if (zn->shm.exists) {
+
+        if (sp == sp->addr) {
+            return NGX_OK;
+        }
+
+#if (NGX_WIN32)
+
+        /* remap at the required address */
+
+        if (ngx_shm_remap(&zn->shm, sp->addr) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        sp = (ngx_slab_pool_t *) zn->shm.addr;
+
+        if (sp == sp->addr) {
+            return NGX_OK;
+        }
+
+#endif
+
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "shared zone \"%V\" has no equal addresses: %p vs %p",
+                      &zn->shm.name, sp->addr, sp);
+        return NGX_ERROR;
+    }
+
+    sp->end = zn->shm.addr + zn->shm.size;
+    sp->min_shift = 3;
+    sp->addr = zn->shm.addr;
+
+#if (NGX_HAVE_ATOMIC_OPS)
+
+    file = NULL;
+
+#else
+
+    file = ngx_pnalloc(cycle->pool, cycle->lock_file.len + zn->shm.name.len);
+    if (file == NULL) {
+        return NGX_ERROR;
+    }
+
+    (void) ngx_sprintf(file, "%V%V%Z", &cycle->lock_file, &zn->shm.name);
+
+#endif
+
+    if (ngx_shmtx_create(&sp->mutex, &sp->lock, file) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    ngx_slab_init(sp);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)
+{
+    size_t      len;
+    ngx_uint_t  create;
+    ngx_file_t  file;
+    u_char      pid[NGX_INT64_LEN + 2];
+
+    if (ngx_process > NGX_PROCESS_MASTER) {
+        return NGX_OK;
+    }
+
+    ngx_memzero(&file, sizeof(ngx_file_t));
+
+    file.name = *name;
+    file.log = log;
+
+    create = ngx_test_config ? NGX_FILE_CREATE_OR_OPEN : NGX_FILE_TRUNCATE;
+
+    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDWR,
+                            create, NGX_FILE_DEFAULT_ACCESS);
+
+    if (file.fd == NGX_INVALID_FILE) {
+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                      ngx_open_file_n " \"%s\" failed", file.name.data);
+        return NGX_ERROR;
+    }
+
+    if (!ngx_test_config) {
+        len = ngx_snprintf(pid, NGX_INT64_LEN + 2, "%P%N", ngx_pid) - pid;
+
+        if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {
+            return NGX_ERROR;
+        }
+    }
+
+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                      ngx_close_file_n " \"%s\" failed", file.name.data);
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_delete_pidfile(ngx_cycle_t *cycle)
+{
+    u_char           *name;
+    ngx_core_conf_t  *ccf;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    name = ngx_new_binary ? ccf->oldpid.data : ccf->pid.data;
+
+    if (ngx_delete_file(name) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                      ngx_delete_file_n " \"%s\" failed", name);
+    }
+}
+
+
+ngx_int_t
+ngx_signal_process(ngx_cycle_t *cycle, char *sig)
+{
+    ssize_t           n;
+    ngx_pid_t         pid;
+    ngx_file_t        file;
+    ngx_core_conf_t  *ccf;
+    u_char            buf[NGX_INT64_LEN + 2];
+
+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "signal process started");
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
+
+    ngx_memzero(&file, sizeof(ngx_file_t));
+
+    file.name = ccf->pid;
+    file.log = cycle->log;
+
+    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY,
+                            NGX_FILE_OPEN, NGX_FILE_DEFAULT_ACCESS);
+
+    if (file.fd == NGX_INVALID_FILE) {
+        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,
+                      ngx_open_file_n " \"%s\" failed", file.name.data);
+        return 1;
+    }
+
+    n = ngx_read_file(&file, buf, NGX_INT64_LEN + 2, 0);
+
+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                      ngx_close_file_n " \"%s\" failed", file.name.data);
+    }
+
+    if (n == NGX_ERROR) {
+        return 1;
+    }
+
+    while (n-- && (buf[n] == CR || buf[n] == LF)) { /* void */ }
+
+    pid = ngx_atoi(buf, ++n);
+
+    if (pid == (ngx_pid_t) NGX_ERROR) {
+        ngx_log_error(NGX_LOG_ERR, cycle->log, 0,
+                      "invalid PID number \"%*s\" in \"%s\"",
+                      n, buf, file.name.data);
+        return 1;
+    }
+
+    return ngx_os_signal_process(cycle, sig, pid);
+
+}
+
+
+static ngx_int_t
+ngx_test_lockfile(u_char *file, ngx_log_t *log)
+{
+#if !(NGX_HAVE_ATOMIC_OPS)
+    ngx_fd_t  fd;
+
+    fd = ngx_open_file(file, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,
+                       NGX_FILE_DEFAULT_ACCESS);
+
+    if (fd == NGX_INVALID_FILE) {
+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
+                      ngx_open_file_n " \"%s\" failed", file);
+        return NGX_ERROR;
+    }
+
+    if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                      ngx_close_file_n " \"%s\" failed", file);
+    }
+
+    if (ngx_delete_file(file) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                      ngx_delete_file_n " \"%s\" failed", file);
+    }
+
+#endif
+
+    return NGX_OK;
+}
+
+
+void
+ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)
+{
+    ngx_fd_t          fd;
+    ngx_uint_t        i;
+    ngx_list_part_t  *part;
+    ngx_open_file_t  *file;
+
+    part = &cycle->open_files.part;
+    file = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            file = part->elts;
+            i = 0;
+        }
+
+        if (file[i].name.len == 0) {
+            continue;
+        }
+
+        if (file[i].flush) {
+            file[i].flush(&file[i], cycle->log);
+        }
+
+        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,
+                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);
+
+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
+                       "reopen file \"%s\", old:%d new:%d",
+                       file[i].name.data, file[i].fd, fd);
+
+        if (fd == NGX_INVALID_FILE) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          ngx_open_file_n " \"%s\" failed", file[i].name.data);
+            continue;
+        }
+
+#if !(NGX_WIN32)
+        if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {
+            ngx_file_info_t  fi;
+
+            if (ngx_file_info((const char *) file[i].name.data, &fi)
+                == NGX_FILE_ERROR)
+            {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                              ngx_file_info_n " \"%s\" failed",
+                              file[i].name.data);
+
+                if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                                  ngx_close_file_n " \"%s\" failed",
+                                  file[i].name.data);
+                }
+
+                continue;
+            }
+
+            if (fi.st_uid != user) {
+                if (chown((const char *) file[i].name.data, user, -1) == -1) {
+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                                  "chown(\"%s\", %d) failed",
+                                  file[i].name.data, user);
+
+                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                                      ngx_close_file_n " \"%s\" failed",
+                                      file[i].name.data);
+                    }
+
+                    continue;
+                }
+            }
+
+            if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) {
+
+                fi.st_mode |= (S_IRUSR|S_IWUSR);
+
+                if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) {
+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                                  "chmod() \"%s\" failed", file[i].name.data);
+
+                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                                      ngx_close_file_n " \"%s\" failed",
+                                      file[i].name.data);
+                    }
+
+                    continue;
+                }
+            }
+        }
+
+        if (seng_file_fcntl3(fd, F_SETFD, FD_CLOEXEC) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "fcntl(FD_CLOEXEC) \"%s\" failed",
+                          file[i].name.data);
+
+            if (ngx_close_file(fd) == NGX_FILE_ERROR) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                              ngx_close_file_n " \"%s\" failed",
+                              file[i].name.data);
+            }
+
+            continue;
+        }
+#endif
+
+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          ngx_close_file_n " \"%s\" failed",
+                          file[i].name.data);
+        }
+
+        file[i].fd = fd;
+    }
+
+    (void) ngx_log_redirect_stderr(cycle);
+}
+
+
+ngx_shm_zone_t *
+ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name, size_t size, void *tag)
+{
+    ngx_uint_t        i;
+    ngx_shm_zone_t   *shm_zone;
+    ngx_list_part_t  *part;
+
+    part = &cf->cycle->shared_memory.part;
+    shm_zone = part->elts;
+
+    for (i = 0; /* void */ ; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+            part = part->next;
+            shm_zone = part->elts;
+            i = 0;
+        }
+
+        if (name->len != shm_zone[i].shm.name.len) {
+            continue;
+        }
+
+        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)
+            != 0)
+        {
+            continue;
+        }
+
+        if (tag != shm_zone[i].tag) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                            "the shared memory zone \"%V\" is "
+                            "already declared for a different use",
+                            &shm_zone[i].shm.name);
+            return NULL;
+        }
+
+        if (shm_zone[i].shm.size == 0) {
+            shm_zone[i].shm.size = size;
+        }
+
+        if (size && size != shm_zone[i].shm.size) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                            "the size %uz of shared memory zone \"%V\" "
+                            "conflicts with already declared size %uz",
+                            size, &shm_zone[i].shm.name, shm_zone[i].shm.size);
+            return NULL;
+        }
+
+        return &shm_zone[i];
+    }
+
+    shm_zone = ngx_list_push(&cf->cycle->shared_memory);
+
+    if (shm_zone == NULL) {
+        return NULL;
+    }
+
+    shm_zone->data = NULL;
+    shm_zone->shm.log = cf->cycle->log;
+    shm_zone->shm.size = size;
+    shm_zone->shm.name = *name;
+    shm_zone->shm.exists = 0;
+    shm_zone->init = NULL;
+    shm_zone->tag = tag;
+    shm_zone->noreuse = 0;
+
+    return shm_zone;
+}
+
+
+static void
+ngx_clean_old_cycles(ngx_event_t *ev)
+{
+    ngx_uint_t     i, n, found, live;
+    ngx_log_t     *log;
+    ngx_cycle_t  **cycle;
+
+    log = ngx_cycle->log;
+    ngx_temp_pool->log = log;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, "clean old cycles");
+
+    live = 0;
+
+    cycle = ngx_old_cycles.elts;
+    for (i = 0; i < ngx_old_cycles.nelts; i++) {
+
+        if (cycle[i] == NULL) {
+            continue;
+        }
+
+        found = 0;
+
+        for (n = 0; n < cycle[i]->connection_n; n++) {
+            if (cycle[i]->connections[n].fd != (ngx_socket_t) -1) {
+                found = 1;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, "live fd:%ui", n);
+
+                break;
+            }
+        }
+
+        if (found) {
+            live = 1;
+            continue;
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, "clean old cycle: %ui", i);
+
+        ngx_destroy_pool(cycle[i]->pool);
+        cycle[i] = NULL;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, "old cycles status: %ui", live);
+
+    if (live) {
+        ngx_add_timer(ev, 30000);
+
+    } else {
+        ngx_destroy_pool(ngx_temp_pool);
+        ngx_temp_pool = NULL;
+        ngx_old_cycles.nelts = 0;
+    }
+}
diff --git a/src/os/seng/trusted/core/t_ngx_thread_pool.c b/src/os/seng/trusted/core/t_ngx_thread_pool.c
new file mode 100644
index 0000000..f3655aa
--- /dev/null
+++ b/src/os/seng/trusted/core/t_ngx_thread_pool.c
@@ -0,0 +1,634 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ * Copyright (C) Ruslan Ermilov
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_thread_pool.h>
+
+
+typedef struct {
+    ngx_array_t               pools;
+} ngx_thread_pool_conf_t;
+
+
+typedef struct {
+    ngx_thread_task_t        *first;
+    ngx_thread_task_t       **last;
+} ngx_thread_pool_queue_t;
+
+#define ngx_thread_pool_queue_init(q)                                         \
+    (q)->first = NULL;                                                        \
+    (q)->last = &(q)->first
+
+
+struct ngx_thread_pool_s {
+    ngx_thread_mutex_t        mtx;
+    ngx_thread_pool_queue_t   queue;
+    ngx_int_t                 waiting;
+    ngx_thread_cond_t         cond;
+
+    ngx_log_t                *log;
+
+    ngx_str_t                 name;
+    ngx_uint_t                threads;
+    ngx_int_t                 max_queue;
+
+    u_char                   *file;
+    ngx_uint_t                line;
+};
+
+
+static ngx_int_t ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log,
+    ngx_pool_t *pool);
+static void ngx_thread_pool_destroy(ngx_thread_pool_t *tp);
+static void ngx_thread_pool_exit_handler(void *data, ngx_log_t *log);
+
+static void *ngx_thread_pool_cycle(void *data);
+static void ngx_thread_pool_handler(ngx_event_t *ev);
+
+static char *ngx_thread_pool(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+static void *ngx_thread_pool_create_conf(ngx_cycle_t *cycle);
+static char *ngx_thread_pool_init_conf(ngx_cycle_t *cycle, void *conf);
+
+static ngx_int_t ngx_thread_pool_init_worker(ngx_cycle_t *cycle);
+static void ngx_thread_pool_exit_worker(ngx_cycle_t *cycle);
+
+
+static ngx_command_t  ngx_thread_pool_commands[] = {
+
+    { ngx_string("thread_pool"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE23,
+      ngx_thread_pool,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_core_module_t  ngx_thread_pool_module_ctx = {
+    ngx_string("thread_pool"),
+    ngx_thread_pool_create_conf,
+    ngx_thread_pool_init_conf
+};
+
+
+ngx_module_t  ngx_thread_pool_module = {
+    NGX_MODULE_V1,
+    &ngx_thread_pool_module_ctx,           /* module context */
+    ngx_thread_pool_commands,              /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    ngx_thread_pool_init_worker,           /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    ngx_thread_pool_exit_worker,           /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t  ngx_thread_pool_default = ngx_string("default");
+
+static ngx_uint_t               ngx_thread_pool_task_id;
+static ngx_atomic_t             ngx_thread_pool_done_lock;
+static ngx_thread_pool_queue_t  ngx_thread_pool_done;
+
+
+static ngx_int_t
+ngx_thread_pool_init(ngx_thread_pool_t *tp, ngx_log_t *log, ngx_pool_t *pool)
+{
+    int             err;
+    pthread_t       tid;
+    ngx_uint_t      n;
+    pthread_attr_t  attr;
+
+    if (ngx_notify == NULL) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0,
+               "the configured event method cannot be used with thread pools");
+        return NGX_ERROR;
+    }
+
+    ngx_thread_pool_queue_init(&tp->queue);
+
+    if (ngx_thread_mutex_create(&tp->mtx, log) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (ngx_thread_cond_create(&tp->cond, log) != NGX_OK) {
+        (void) ngx_thread_mutex_destroy(&tp->mtx, log);
+        return NGX_ERROR;
+    }
+
+    tp->log = log;
+
+    err = pthread_attr_init(&attr);
+    if (err) {
+        ngx_log_error(NGX_LOG_ALERT, log, err,
+                      "pthread_attr_init() failed");
+        return NGX_ERROR;
+    }
+
+#if 0
+    err = pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN);
+    if (err) {
+        ngx_log_error(NGX_LOG_ALERT, log, err,
+                      "pthread_attr_setstacksize() failed");
+        return NGX_ERROR;
+    }
+#endif
+
+    for (n = 0; n < tp->threads; n++) {
+        err = pthread_create(&tid, &attr, ngx_thread_pool_cycle, tp);
+        if (err) {
+            ngx_log_error(NGX_LOG_ALERT, log, err,
+                          "pthread_create() failed");
+            return NGX_ERROR;
+        }
+    }
+
+    (void) pthread_attr_destroy(&attr);
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_thread_pool_destroy(ngx_thread_pool_t *tp)
+{
+    ngx_uint_t           n;
+    ngx_thread_task_t    task;
+    volatile ngx_uint_t  lock;
+
+    ngx_memzero(&task, sizeof(ngx_thread_task_t));
+
+    task.handler = ngx_thread_pool_exit_handler;
+    task.ctx = (void *) &lock;
+
+    for (n = 0; n < tp->threads; n++) {
+        lock = 1;
+
+        if (ngx_thread_task_post(tp, &task) != NGX_OK) {
+            return;
+        }
+
+        while (lock) {
+            ngx_sched_yield();
+        }
+
+        task.event.active = 0;
+    }
+
+    (void) ngx_thread_cond_destroy(&tp->cond, tp->log);
+
+    (void) ngx_thread_mutex_destroy(&tp->mtx, tp->log);
+}
+
+
+static void
+ngx_thread_pool_exit_handler(void *data, ngx_log_t *log)
+{
+    ngx_uint_t *lock = data;
+
+    *lock = 0;
+
+    pthread_exit(0);
+}
+
+
+ngx_thread_task_t *
+ngx_thread_task_alloc(ngx_pool_t *pool, size_t size)
+{
+    ngx_thread_task_t  *task;
+
+    task = ngx_pcalloc(pool, sizeof(ngx_thread_task_t) + size);
+    if (task == NULL) {
+        return NULL;
+    }
+
+    task->ctx = task + 1;
+
+    return task;
+}
+
+
+ngx_int_t
+ngx_thread_task_post(ngx_thread_pool_t *tp, ngx_thread_task_t *task)
+{
+    if (task->event.active) {
+        ngx_log_error(NGX_LOG_ALERT, tp->log, 0,
+                      "task #%ui already active", task->id);
+        return NGX_ERROR;
+    }
+
+    if (ngx_thread_mutex_lock(&tp->mtx, tp->log) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (tp->waiting >= tp->max_queue) {
+        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
+
+        ngx_log_error(NGX_LOG_ERR, tp->log, 0,
+                      "thread pool \"%V\" queue overflow: %i tasks waiting",
+                      &tp->name, tp->waiting);
+        return NGX_ERROR;
+    }
+
+    task->event.active = 1;
+
+    task->id = ngx_thread_pool_task_id++;
+    task->next = NULL;
+
+    if (ngx_thread_cond_signal(&tp->cond, tp->log) != NGX_OK) {
+        (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
+        return NGX_ERROR;
+    }
+
+    *tp->queue.last = task;
+    tp->queue.last = &task->next;
+
+    tp->waiting++;
+
+    (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp->log, 0,
+                   "task #%ui added to thread pool \"%V\"",
+                   task->id, &tp->name);
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_thread_pool_cycle(void *data)
+{
+    ngx_thread_pool_t *tp = data;
+
+    int                 err;
+    sigset_t            set;
+    ngx_thread_task_t  *task;
+
+#if 0
+    ngx_time_update();
+#endif
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, tp->log, 0,
+                   "thread in pool \"%V\" started", &tp->name);
+
+    sigfillset(&set);
+
+    sigdelset(&set, SIGILL);
+    sigdelset(&set, SIGFPE);
+    sigdelset(&set, SIGSEGV);
+    sigdelset(&set, SIGBUS);
+
+    err = pthread_sigmask(SIG_BLOCK, &set, NULL);
+    if (err) {
+        ngx_log_error(NGX_LOG_ALERT, tp->log, err, "pthread_sigmask() failed");
+        return NULL;
+    }
+
+    for ( ;; ) {
+        if (ngx_thread_mutex_lock(&tp->mtx, tp->log) != NGX_OK) {
+            return NULL;
+        }
+
+        /* the number may become negative */
+        tp->waiting--;
+
+        while (tp->queue.first == NULL) {
+            if (ngx_thread_cond_wait(&tp->cond, &tp->mtx, tp->log)
+                != NGX_OK)
+            {
+                (void) ngx_thread_mutex_unlock(&tp->mtx, tp->log);
+                return NULL;
+            }
+        }
+
+        task = tp->queue.first;
+        tp->queue.first = task->next;
+
+        if (tp->queue.first == NULL) {
+            tp->queue.last = &tp->queue.first;
+        }
+
+        if (ngx_thread_mutex_unlock(&tp->mtx, tp->log) != NGX_OK) {
+            return NULL;
+        }
+
+#if 0
+        ngx_time_update();
+#endif
+
+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp->log, 0,
+                       "run task #%ui in thread pool \"%V\"",
+                       task->id, &tp->name);
+
+        task->handler(task->ctx, tp->log);
+
+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, tp->log, 0,
+                       "complete task #%ui in thread pool \"%V\"",
+                       task->id, &tp->name);
+
+        task->next = NULL;
+
+        ngx_spinlock(&ngx_thread_pool_done_lock, 1, 2048);
+
+        *ngx_thread_pool_done.last = task;
+        ngx_thread_pool_done.last = &task->next;
+
+        ngx_memory_barrier();
+
+        ngx_unlock(&ngx_thread_pool_done_lock);
+
+        (void) ngx_notify(ngx_thread_pool_handler);
+    }
+}
+
+
+static void
+ngx_thread_pool_handler(ngx_event_t *ev)
+{
+    ngx_event_t        *event;
+    ngx_thread_task_t  *task;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, "thread pool handler");
+
+    ngx_spinlock(&ngx_thread_pool_done_lock, 1, 2048);
+
+    task = ngx_thread_pool_done.first;
+    ngx_thread_pool_done.first = NULL;
+    ngx_thread_pool_done.last = &ngx_thread_pool_done.first;
+
+    ngx_memory_barrier();
+
+    ngx_unlock(&ngx_thread_pool_done_lock);
+
+    while (task) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,
+                       "run completion handler for task #%ui", task->id);
+
+        event = &task->event;
+        task = task->next;
+
+        event->complete = 1;
+        event->active = 0;
+
+        event->handler(event);
+    }
+}
+
+
+static void *
+ngx_thread_pool_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_thread_pool_conf_t  *tcf;
+
+    tcf = ngx_pcalloc(cycle->pool, sizeof(ngx_thread_pool_conf_t));
+    if (tcf == NULL) {
+        return NULL;
+    }
+
+    if (ngx_array_init(&tcf->pools, cycle->pool, 4,
+                       sizeof(ngx_thread_pool_t *))
+        != NGX_OK)
+    {
+        return NULL;
+    }
+
+    return tcf;
+}
+
+
+static char *
+ngx_thread_pool_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_thread_pool_conf_t *tcf = conf;
+
+    ngx_uint_t           i;
+    ngx_thread_pool_t  **tpp;
+
+    tpp = tcf->pools.elts;
+
+    for (i = 0; i < tcf->pools.nelts; i++) {
+
+        if (tpp[i]->threads) {
+            continue;
+        }
+
+        if (tpp[i]->name.len == ngx_thread_pool_default.len
+            && ngx_strncmp(tpp[i]->name.data, ngx_thread_pool_default.data,
+                           ngx_thread_pool_default.len)
+               == 0)
+        {
+            tpp[i]->threads = 32;
+            tpp[i]->max_queue = 65536;
+            continue;
+        }
+
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "unknown thread pool \"%V\" in %s:%ui",
+                      &tpp[i]->name, tpp[i]->file, tpp[i]->line);
+
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_thread_pool(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t          *value;
+    ngx_uint_t          i;
+    ngx_thread_pool_t  *tp;
+
+    value = cf->args->elts;
+
+    tp = ngx_thread_pool_add(cf, &value[1]);
+
+    if (tp == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (tp->threads) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "duplicate thread pool \"%V\"", &tp->name);
+        return NGX_CONF_ERROR;
+    }
+
+    tp->max_queue = 65536;
+
+    for (i = 2; i < cf->args->nelts; i++) {
+
+        if (ngx_strncmp(value[i].data, "threads=", 8) == 0) {
+
+            tp->threads = ngx_atoi(value[i].data + 8, value[i].len - 8);
+
+            if (tp->threads == (ngx_uint_t) NGX_ERROR || tp->threads == 0) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "invalid threads value \"%V\"", &value[i]);
+                return NGX_CONF_ERROR;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "max_queue=", 10) == 0) {
+
+            tp->max_queue = ngx_atoi(value[i].data + 10, value[i].len - 10);
+
+            if (tp->max_queue == NGX_ERROR) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "invalid max_queue value \"%V\"", &value[i]);
+                return NGX_CONF_ERROR;
+            }
+
+            continue;
+        }
+    }
+
+    if (tp->threads == 0) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "\"%V\" must have \"threads\" parameter",
+                           &cmd->name);
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+ngx_thread_pool_t *
+ngx_thread_pool_add(ngx_conf_t *cf, ngx_str_t *name)
+{
+    ngx_thread_pool_t       *tp, **tpp;
+    ngx_thread_pool_conf_t  *tcf;
+
+    if (name == NULL) {
+        name = &ngx_thread_pool_default;
+    }
+
+    tp = ngx_thread_pool_get(cf->cycle, name);
+
+    if (tp) {
+        return tp;
+    }
+
+    tp = ngx_pcalloc(cf->pool, sizeof(ngx_thread_pool_t));
+    if (tp == NULL) {
+        return NULL;
+    }
+
+    tp->name = *name;
+    tp->file = cf->conf_file->file.name.data;
+    tp->line = cf->conf_file->line;
+
+    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cf->cycle->conf_ctx,
+                                                  ngx_thread_pool_module);
+
+    tpp = ngx_array_push(&tcf->pools);
+    if (tpp == NULL) {
+        return NULL;
+    }
+
+    *tpp = tp;
+
+    return tp;
+}
+
+
+ngx_thread_pool_t *
+ngx_thread_pool_get(ngx_cycle_t *cycle, ngx_str_t *name)
+{
+    ngx_uint_t                i;
+    ngx_thread_pool_t       **tpp;
+    ngx_thread_pool_conf_t   *tcf;
+
+    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
+                                                  ngx_thread_pool_module);
+
+    tpp = tcf->pools.elts;
+
+    for (i = 0; i < tcf->pools.nelts; i++) {
+
+        if (tpp[i]->name.len == name->len
+            && ngx_strncmp(tpp[i]->name.data, name->data, name->len) == 0)
+        {
+            return tpp[i];
+        }
+    }
+
+    return NULL;
+}
+
+
+static ngx_int_t
+ngx_thread_pool_init_worker(ngx_cycle_t *cycle)
+{
+    ngx_uint_t                i;
+    ngx_thread_pool_t       **tpp;
+    ngx_thread_pool_conf_t   *tcf;
+
+    if (ngx_process != NGX_PROCESS_WORKER
+        && ngx_process != NGX_PROCESS_SINGLE)
+    {
+        return NGX_OK;
+    }
+
+    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
+                                                  ngx_thread_pool_module);
+
+    if (tcf == NULL) {
+        return NGX_OK;
+    }
+
+    ngx_thread_pool_queue_init(&ngx_thread_pool_done);
+
+    tpp = tcf->pools.elts;
+
+    for (i = 0; i < tcf->pools.nelts; i++) {
+        if (ngx_thread_pool_init(tpp[i], cycle->log, cycle->pool) != NGX_OK) {
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_thread_pool_exit_worker(ngx_cycle_t *cycle)
+{
+    ngx_uint_t                i;
+    ngx_thread_pool_t       **tpp;
+    ngx_thread_pool_conf_t   *tcf;
+
+    if (ngx_process != NGX_PROCESS_WORKER
+        && ngx_process != NGX_PROCESS_SINGLE)
+    {
+        return;
+    }
+
+    tcf = (ngx_thread_pool_conf_t *) ngx_get_conf(cycle->conf_ctx,
+                                                  ngx_thread_pool_module);
+
+    if (tcf == NULL) {
+        return;
+    }
+
+    tpp = tcf->pools.elts;
+
+    for (i = 0; i < tcf->pools.nelts; i++) {
+        ngx_thread_pool_destroy(tpp[i]);
+    }
+}
diff --git a/src/os/seng/trusted/linux/stat.h b/src/os/seng/trusted/linux/stat.h
new file mode 120000
index 0000000..d3f1b79
--- /dev/null
+++ b/src/os/seng/trusted/linux/stat.h
@@ -0,0 +1 @@
+/usr/include/linux/stat.h
\ No newline at end of file
diff --git a/src/os/seng/trusted/ngx_daemon.c b/src/os/seng/trusted/ngx_daemon.c
new file mode 100644
index 0000000..da1e388
--- /dev/null
+++ b/src/os/seng/trusted/ngx_daemon.c
@@ -0,0 +1,10 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+ngx_int_t
+ngx_daemon(ngx_log_t *log)
+{
+    // Currently daemon mode is NOT supported
+    return NGX_ERROR;
+}
diff --git a/src/os/seng/trusted/ngx_dlopen.h b/src/os/seng/trusted/ngx_dlopen.h
new file mode 100644
index 0000000..2370848
--- /dev/null
+++ b/src/os/seng/trusted/ngx_dlopen.h
@@ -0,0 +1,24 @@
+#ifndef _NGX_DLOPEN_H_INCLUDED_
+#define _NGX_DLOPEN_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#define ngx_dlopen(path)           NULL
+#define ngx_dlopen_n               "dlopen()"
+
+#define ngx_dlsym(handle, symbol)  NULL
+#define ngx_dlsym_n                "dlsym()"
+
+#define ngx_dlclose(handle)        -1
+#define ngx_dlclose_n              "dlclose()"
+
+
+#if 0 // (NGX_HAVE_DLOPEN)
+char *ngx_dlerror(void);
+#endif
+
+
+#endif /* _NGX_DLOPEN_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_errno.c b/src/os/seng/trusted/ngx_errno.c
new file mode 100644
index 0000000..49f23c2
--- /dev/null
+++ b/src/os/seng/trusted/ngx_errno.c
@@ -0,0 +1,34 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+/* NGINX uses own error string array to be async-safe.
+ *  sys_nerr is not contained in SGX SDK, but we could just enumerate
+ *  all errno values with strerror() until we find the max. number.
+ *  However, as we anyway move signal handlers outside the encalve, and
+ *  it cannot easily access the trusted variables for logging,
+ *  we will take care of the signal handlers and just use strerror_r() here
+ *  for the moment.
+ */
+
+u_char *
+ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
+{
+    // returns int
+    strerror_r(err, (char *)errstr, size);
+    return errstr;
+}
+
+
+ngx_int_t
+ngx_strerror_init(void)
+{
+    return NGX_OK;
+}
diff --git a/src/os/seng/trusted/ngx_errno.h b/src/os/seng/trusted/ngx_errno.h
new file mode 100644
index 0000000..7d6ca76
--- /dev/null
+++ b/src/os/seng/trusted/ngx_errno.h
@@ -0,0 +1,79 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_ERRNO_H_INCLUDED_
+#define _NGX_ERRNO_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+typedef int               ngx_err_t;
+
+#define NGX_EPERM         EPERM
+#define NGX_ENOENT        ENOENT
+#define NGX_ENOPATH       ENOENT
+#define NGX_ESRCH         ESRCH
+#define NGX_EINTR         EINTR
+#define NGX_ECHILD        ECHILD
+#define NGX_ENOMEM        ENOMEM
+#define NGX_EACCES        EACCES
+#define NGX_EBUSY         EBUSY
+#define NGX_EEXIST        EEXIST
+#define NGX_EEXIST_FILE   EEXIST
+#define NGX_EXDEV         EXDEV
+#define NGX_ENOTDIR       ENOTDIR
+#define NGX_EISDIR        EISDIR
+#define NGX_EINVAL        EINVAL
+#define NGX_ENFILE        ENFILE
+#define NGX_EMFILE        EMFILE
+#define NGX_ENOSPC        ENOSPC
+#define NGX_EPIPE         EPIPE
+#define NGX_EINPROGRESS   EINPROGRESS
+#define NGX_ENOPROTOOPT   ENOPROTOOPT
+#define NGX_EOPNOTSUPP    EOPNOTSUPP
+#define NGX_EADDRINUSE    EADDRINUSE
+#define NGX_ECONNABORTED  ECONNABORTED
+#define NGX_ECONNRESET    ECONNRESET
+#define NGX_ENOTCONN      ENOTCONN
+#define NGX_ETIMEDOUT     ETIMEDOUT
+#define NGX_ECONNREFUSED  ECONNREFUSED
+#define NGX_ENAMETOOLONG  ENAMETOOLONG
+#define NGX_ENETDOWN      ENETDOWN
+#define NGX_ENETUNREACH   ENETUNREACH
+#define NGX_EHOSTDOWN     EHOSTDOWN
+#define NGX_EHOSTUNREACH  EHOSTUNREACH
+#define NGX_ENOSYS        ENOSYS
+#define NGX_ECANCELED     ECANCELED
+#define NGX_EILSEQ        EILSEQ
+#define NGX_ENOMOREFILES  0
+#define NGX_ELOOP         ELOOP
+#define NGX_EBADF         EBADF
+
+#if (NGX_HAVE_OPENAT)
+#define NGX_EMLINK        EMLINK
+#endif
+
+#if (__hpux__)
+#define NGX_EAGAIN        EWOULDBLOCK
+#else
+#define NGX_EAGAIN        EAGAIN
+#endif
+
+
+#define ngx_errno                  errno
+#define ngx_socket_errno           errno
+#define ngx_set_errno(err)         errno = err
+#define ngx_set_socket_errno(err)  errno = err
+
+
+u_char *ngx_strerror(ngx_err_t err, u_char *errstr, size_t size);
+ngx_int_t ngx_strerror_init(void);
+
+
+#endif /* _NGX_ERRNO_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_files.c b/src/os/seng/trusted/ngx_files.c
new file mode 100644
index 0000000..a2f30ba
--- /dev/null
+++ b/src/os/seng/trusted/ngx_files.c
@@ -0,0 +1,867 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#if (NGX_THREADS)
+#include <ngx_thread_pool.h>
+static void ngx_thread_read_handler(void *data, ngx_log_t *log);
+static void ngx_thread_write_chain_to_file_handler(void *data, ngx_log_t *log);
+#endif
+
+static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl);
+static ssize_t ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec,
+    off_t offset);
+
+
+#if (NGX_HAVE_FILE_AIO)
+
+ngx_uint_t  ngx_file_aio = 1;
+
+#endif
+
+
+ssize_t
+ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
+{
+    ssize_t  n;
+
+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
+                   "read: %d, %p, %uz, %O", file->fd, buf, size, offset);
+
+#if (NGX_HAVE_PREAD)
+
+    n = pread(file->fd, buf, size, offset);
+
+    if (n == -1) {
+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
+                      "pread() \"%s\" failed", file->name.data);
+        return NGX_ERROR;
+    }
+
+#else
+
+    if (file->sys_offset != offset) {
+        if (seng_lseek(file->fd, offset, SEEK_SET) == -1) {
+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
+                          "lseek() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->sys_offset = offset;
+    }
+
+    n = seng_file_read(file->fd, buf, size);
+
+    if (n == -1) {
+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
+                      "read() \"%s\" failed", file->name.data);
+        return NGX_ERROR;
+    }
+
+    file->sys_offset += n;
+
+#endif
+
+    file->offset += n;
+
+    return n;
+}
+
+
+#if (NGX_THREADS)
+
+typedef struct {
+    ngx_fd_t       fd;
+    ngx_uint_t     write;   /* unsigned  write:1; */
+
+    u_char        *buf;
+    size_t         size;
+    ngx_chain_t   *chain;
+    off_t          offset;
+
+    size_t         nbytes;
+    ngx_err_t      err;
+} ngx_thread_file_ctx_t;
+
+
+ssize_t
+ngx_thread_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,
+    ngx_pool_t *pool)
+{
+    ngx_thread_task_t      *task;
+    ngx_thread_file_ctx_t  *ctx;
+
+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
+                   "thread read: %d, %p, %uz, %O",
+                   file->fd, buf, size, offset);
+
+    task = file->thread_task;
+
+    if (task == NULL) {
+        task = ngx_thread_task_alloc(pool, sizeof(ngx_thread_file_ctx_t));
+        if (task == NULL) {
+            return NGX_ERROR;
+        }
+
+        file->thread_task = task;
+    }
+
+    ctx = task->ctx;
+
+    if (task->event.complete) {
+        task->event.complete = 0;
+
+        if (ctx->write) {
+            ngx_log_error(NGX_LOG_ALERT, file->log, 0,
+                          "invalid thread call, read instead of write");
+            return NGX_ERROR;
+        }
+
+        if (ctx->err) {
+            ngx_log_error(NGX_LOG_CRIT, file->log, ctx->err,
+                          "pread() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        return ctx->nbytes;
+    }
+
+    task->handler = ngx_thread_read_handler;
+
+    ctx->write = 0;
+
+    ctx->fd = file->fd;
+    ctx->buf = buf;
+    ctx->size = size;
+    ctx->offset = offset;
+
+    if (file->thread_handler(task, file) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+#if (NGX_HAVE_PREAD)
+
+static void
+ngx_thread_read_handler(void *data, ngx_log_t *log)
+{
+    ngx_thread_file_ctx_t *ctx = data;
+
+    ssize_t  n;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, "thread read handler");
+
+    n = pread(ctx->fd, ctx->buf, ctx->size, ctx->offset);
+
+    if (n == -1) {
+        ctx->err = ngx_errno;
+
+    } else {
+        ctx->nbytes = n;
+        ctx->err = 0;
+    }
+
+#if 0
+    ngx_time_update();
+#endif
+
+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, log, 0,
+                   "pread: %z (err: %d) of %uz @%O",
+                   n, ctx->err, ctx->size, ctx->offset);
+}
+
+#else
+
+#error pread() is required!
+
+#endif
+
+#endif /* NGX_THREADS */
+
+
+ssize_t
+ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
+{
+    ssize_t    n, written;
+    ngx_err_t  err;
+
+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,
+                   "write: %d, %p, %uz, %O", file->fd, buf, size, offset);
+
+    written = 0;
+
+#if (NGX_HAVE_PWRITE)
+
+    for ( ;; ) {
+        n = pwrite(file->fd, buf + written, size, offset);
+
+        if (n == -1) {
+            err = ngx_errno;
+
+            if (err == NGX_EINTR) {
+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
+                               "pwrite() was interrupted");
+                continue;
+            }
+
+            ngx_log_error(NGX_LOG_CRIT, file->log, err,
+                          "pwrite() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->offset += n;
+        written += n;
+
+        if ((size_t) n == size) {
+            return written;
+        }
+
+        offset += n;
+        size -= n;
+    }
+
+#else
+
+    if (file->sys_offset != offset) {
+        if (seng_lseek(file->fd, offset, SEEK_SET) == -1) {
+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
+                          "lseek() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->sys_offset = offset;
+    }
+
+    for ( ;; ) {
+        n = seng_file_write(file->fd, buf + written, size);
+
+        if (n == -1) {
+            err = ngx_errno;
+
+            if (err == NGX_EINTR) {
+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
+                               "write() was interrupted");
+                continue;
+            }
+
+            ngx_log_error(NGX_LOG_CRIT, file->log, err,
+                          "write() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->sys_offset += n;
+        file->offset += n;
+        written += n;
+
+        if ((size_t) n == size) {
+            return written;
+        }
+
+        size -= n;
+    }
+#endif
+}
+
+
+ngx_fd_t
+ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)
+{
+    ngx_fd_t  fd;
+
+    fd = seng_file_open((const char *) name, O_CREAT|O_EXCL|O_RDWR,
+              access ? access : 0600);
+
+    if (fd != -1 && !persistent) {
+        (void) seng_unlink((const char *) name);
+    }
+
+    return fd;
+}
+
+
+ssize_t
+ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,
+    ngx_pool_t *pool)
+{
+    ssize_t        total, n;
+    ngx_iovec_t    vec;
+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];
+
+    /* use pwrite() if there is the only buf in a chain */
+
+    if (cl->next == NULL) {
+        return ngx_write_file(file, cl->buf->pos,
+                              (size_t) (cl->buf->last - cl->buf->pos),
+                              offset);
+    }
+
+    total = 0;
+
+    vec.iovs = iovs;
+    vec.nalloc = NGX_IOVS_PREALLOCATE;
+
+    do {
+        /* create the iovec and coalesce the neighbouring bufs */
+        cl = ngx_chain_to_iovec(&vec, cl);
+
+        /* use pwrite() if there is the only iovec buffer */
+
+        if (vec.count == 1) {
+            n = ngx_write_file(file, (u_char *) iovs[0].iov_base,
+                               iovs[0].iov_len, offset);
+
+            if (n == NGX_ERROR) {
+                return n;
+            }
+
+            return total + n;
+        }
+
+        n = ngx_writev_file(file, &vec, offset);
+
+        if (n == NGX_ERROR) {
+            return n;
+        }
+
+        offset += n;
+        total += n;
+
+    } while (cl);
+
+    return total;
+}
+
+
+static ngx_chain_t *
+ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl)
+{
+    size_t         total, size;
+    u_char        *prev;
+    ngx_uint_t     n;
+    struct iovec  *iov;
+
+    iov = NULL;
+    prev = NULL;
+    total = 0;
+    n = 0;
+
+    for ( /* void */ ; cl; cl = cl->next) {
+
+        if (ngx_buf_special(cl->buf)) {
+            continue;
+        }
+
+        size = cl->buf->last - cl->buf->pos;
+
+        if (prev == cl->buf->pos) {
+            iov->iov_len += size;
+
+        } else {
+            if (n == vec->nalloc) {
+                break;
+            }
+
+            iov = &vec->iovs[n++];
+
+            iov->iov_base = (void *) cl->buf->pos;
+            iov->iov_len = size;
+        }
+
+        prev = cl->buf->pos + size;
+        total += size;
+    }
+
+    vec->count = n;
+    vec->size = total;
+
+    return cl;
+}
+
+
+static ssize_t
+ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec, off_t offset)
+{
+    ssize_t    n;
+    ngx_err_t  err;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,
+                   "writev: %d, %uz, %O", file->fd, vec->size, offset);
+
+#if (NGX_HAVE_PWRITEV)
+
+eintr:
+
+    n = pwritev(file->fd, vec->iovs, vec->count, offset);
+
+    if (n == -1) {
+        err = ngx_errno;
+
+        if (err == NGX_EINTR) {
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
+                           "pwritev() was interrupted");
+            goto eintr;
+        }
+
+        ngx_log_error(NGX_LOG_CRIT, file->log, err,
+                      "pwritev() \"%s\" failed", file->name.data);
+        return NGX_ERROR;
+    }
+
+    if ((size_t) n != vec->size) {
+        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
+                      "pwritev() \"%s\" has written only %z of %uz",
+                      file->name.data, n, vec->size);
+        return NGX_ERROR;
+    }
+
+#else
+
+    if (file->sys_offset != offset) {
+        if (seng_lseek(file->fd, offset, SEEK_SET) == -1) {
+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
+                          "lseek() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->sys_offset = offset;
+    }
+
+eintr:
+
+    n = seng_file_writev(file->fd, vec->iovs, vec->count);
+
+    if (n == -1) {
+        err = ngx_errno;
+
+        if (err == NGX_EINTR) {
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,
+                           "writev() was interrupted");
+            goto eintr;
+        }
+
+        ngx_log_error(NGX_LOG_CRIT, file->log, err,
+                      "writev() \"%s\" failed", file->name.data);
+        return NGX_ERROR;
+    }
+
+    if ((size_t) n != vec->size) {
+        ngx_log_error(NGX_LOG_CRIT, file->log, 0,
+                      "writev() \"%s\" has written only %z of %uz",
+                      file->name.data, n, vec->size);
+        return NGX_ERROR;
+    }
+
+    file->sys_offset += n;
+
+#endif
+
+    file->offset += n;
+
+    return n;
+}
+
+
+#if (NGX_THREADS)
+
+ssize_t
+ngx_thread_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,
+    ngx_pool_t *pool)
+{
+    ngx_thread_task_t      *task;
+    ngx_thread_file_ctx_t  *ctx;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,
+                   "thread write chain: %d, %p, %O",
+                   file->fd, cl, offset);
+
+    task = file->thread_task;
+
+    if (task == NULL) {
+        task = ngx_thread_task_alloc(pool,
+                                     sizeof(ngx_thread_file_ctx_t));
+        if (task == NULL) {
+            return NGX_ERROR;
+        }
+
+        file->thread_task = task;
+    }
+
+    ctx = task->ctx;
+
+    if (task->event.complete) {
+        task->event.complete = 0;
+
+        if (!ctx->write) {
+            ngx_log_error(NGX_LOG_ALERT, file->log, 0,
+                          "invalid thread call, write instead of read");
+            return NGX_ERROR;
+        }
+
+        if (ctx->err || ctx->nbytes == 0) {
+            ngx_log_error(NGX_LOG_CRIT, file->log, ctx->err,
+                          "pwritev() \"%s\" failed", file->name.data);
+            return NGX_ERROR;
+        }
+
+        file->offset += ctx->nbytes;
+        return ctx->nbytes;
+    }
+
+    task->handler = ngx_thread_write_chain_to_file_handler;
+
+    ctx->write = 1;
+
+    ctx->fd = file->fd;
+    ctx->chain = cl;
+    ctx->offset = offset;
+
+    if (file->thread_handler(task, file) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static void
+ngx_thread_write_chain_to_file_handler(void *data, ngx_log_t *log)
+{
+    ngx_thread_file_ctx_t *ctx = data;
+
+#if (NGX_HAVE_PWRITEV)
+
+    off_t          offset;
+    ssize_t        n;
+    ngx_err_t      err;
+    ngx_chain_t   *cl;
+    ngx_iovec_t    vec;
+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];
+
+    vec.iovs = iovs;
+    vec.nalloc = NGX_IOVS_PREALLOCATE;
+
+    cl = ctx->chain;
+    offset = ctx->offset;
+
+    ctx->nbytes = 0;
+    ctx->err = 0;
+
+    do {
+        /* create the iovec and coalesce the neighbouring bufs */
+        cl = ngx_chain_to_iovec(&vec, cl);
+
+eintr:
+
+        n = pwritev(ctx->fd, iovs, vec.count, offset);
+
+        if (n == -1) {
+            err = ngx_errno;
+
+            if (err == NGX_EINTR) {
+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, err,
+                               "pwritev() was interrupted");
+                goto eintr;
+            }
+
+            ctx->err = err;
+            return;
+        }
+
+        if ((size_t) n != vec.size) {
+            ctx->nbytes = 0;
+            return;
+        }
+
+        ctx->nbytes += n;
+        offset += n;
+    } while (cl);
+
+#else
+
+    ctx->err = NGX_ENOSYS;
+    return;
+
+#endif
+}
+
+#endif /* NGX_THREADS */
+
+
+ngx_int_t
+ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s)
+{
+    struct timeval  tv[2];
+
+    tv[0].tv_sec = ngx_time();
+    tv[0].tv_usec = 0;
+    tv[1].tv_sec = s;
+    tv[1].tv_usec = 0;
+
+    if (seng_utimes((char *) name, tv) != -1) {
+        return NGX_OK;
+    }
+
+    return NGX_ERROR;
+}
+
+
+/* NOTE: only "ngx_http_geo_module" usees the file mapping;
+ * so we disable it for the moment
+ */
+
+// TODO: we can not easily support mmap()
+ngx_int_t
+ngx_create_file_mapping(ngx_file_mapping_t *fm)
+{
+    return NGX_ERROR;
+}
+
+
+// TODO: we can not easily support munmap()
+void
+ngx_close_file_mapping(ngx_file_mapping_t *fm)
+{
+}
+
+
+ngx_int_t
+ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)
+{
+    dir->dir = seng_opendir((const char *) name->data);
+
+    if (dir->dir == NULL) {
+        return NGX_ERROR;
+    }
+
+    dir->valid_info = 0;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_read_dir(ngx_dir_t *dir)
+{
+    dir->de = seng_readdir(dir->dir);
+
+    if (dir->de) {
+#if (NGX_HAVE_D_TYPE)
+        dir->type = dir->de->d_type;
+#else
+        dir->type = 0;
+#endif
+        return NGX_OK;
+    }
+
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_open_glob(ngx_glob_t *gl)
+{
+    int  n;
+
+    //n = seng_glob((char *) gl->pattern, 0, NULL, &gl->pglob);
+    n = seng_glob((char *) gl->pattern, &gl->pglob);
+
+    if (n == 0) {
+        return NGX_OK;
+    }
+
+#ifdef GLOB_NOMATCH
+
+    if (n == GLOB_NOMATCH && gl->test) {
+        return NGX_OK;
+    }
+
+#endif
+
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)
+{
+    size_t  count;
+
+#ifdef GLOB_NOMATCH
+    count = (size_t) gl->pglob.gl_pathc;
+#else
+    count = (size_t) gl->pglob.gl_matchc;
+#endif
+
+    if (gl->n < count) {
+
+        name->len = (size_t) ngx_strlen(gl->pglob.gl_pathv[gl->n]);
+        name->data = (u_char *) gl->pglob.gl_pathv[gl->n];
+        gl->n++;
+
+        return NGX_OK;
+    }
+
+    return NGX_DONE;
+}
+
+
+void
+ngx_close_glob(ngx_glob_t *gl)
+{
+    seng_globfree(&gl->pglob);
+}
+
+
+ngx_err_t
+ngx_trylock_fd(ngx_fd_t fd)
+{
+    struct flock  fl;
+
+    ngx_memzero(&fl, sizeof(struct flock));
+    fl.l_type = F_WRLCK;
+    fl.l_whence = SEEK_SET;
+
+    if (seng_flock_operation(fd, F_SETLK, &fl) == -1) {
+        return ngx_errno;
+    }
+
+    return 0;
+}
+
+
+ngx_err_t
+ngx_lock_fd(ngx_fd_t fd)
+{
+    struct flock  fl;
+
+    ngx_memzero(&fl, sizeof(struct flock));
+    fl.l_type = F_WRLCK;
+    fl.l_whence = SEEK_SET;
+
+    if (seng_flock_operation(fd, F_SETLKW, &fl) == -1) {
+        return ngx_errno;
+    }
+
+    return 0;
+}
+
+
+ngx_err_t
+ngx_unlock_fd(ngx_fd_t fd)
+{
+    struct flock  fl;
+
+    ngx_memzero(&fl, sizeof(struct flock));
+    fl.l_type = F_UNLCK;
+    fl.l_whence = SEEK_SET;
+
+    if (seng_flock_operation(fd, F_SETLK, &fl) == -1) {
+        return  ngx_errno;
+    }
+
+    return 0;
+}
+
+
+#if (NGX_HAVE_POSIX_FADVISE) && !(NGX_HAVE_F_READAHEAD)
+
+ngx_int_t
+ngx_read_ahead(ngx_fd_t fd, size_t n)
+{
+    int  err;
+
+    err = posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
+
+    if (err == 0) {
+        return 0;
+    }
+
+    ngx_set_errno(err);
+    return NGX_FILE_ERROR;
+}
+
+#endif
+
+
+#if (NGX_HAVE_O_DIRECT)
+
+ngx_int_t
+ngx_directio_on(ngx_fd_t fd)
+{
+    int  flags;
+
+    flags = seng_file_fcntl2(fd, F_GETFL);
+
+    if (flags == -1) {
+        return NGX_FILE_ERROR;
+    }
+
+    return seng_file_fcntl3(fd, F_SETFL, flags | O_DIRECT);
+}
+
+
+ngx_int_t
+ngx_directio_off(ngx_fd_t fd)
+{
+    int  flags;
+
+    flags = seng_file_fcntl2(fd, F_GETFL);
+
+    if (flags == -1) {
+        return NGX_FILE_ERROR;
+    }
+
+    return seng_file_fcntl3(fd, F_SETFL, flags & ~O_DIRECT);
+}
+
+#endif
+
+
+#if (NGX_HAVE_STATFS)
+
+size_t
+ngx_fs_bsize(u_char *name)
+{
+    struct statfs  fs;
+
+    if (statfs((char *) name, &fs) == -1) {
+        return 512;
+    }
+
+    if ((fs.f_bsize % 512) != 0) {
+        return 512;
+    }
+
+    return (size_t) fs.f_bsize;
+}
+
+#elif (NGX_HAVE_STATVFS)
+
+size_t
+ngx_fs_bsize(u_char *name)
+{
+    struct statvfs  fs;
+
+    if (statvfs((char *) name, &fs) == -1) {
+        return 512;
+    }
+
+    if ((fs.f_frsize % 512) != 0) {
+        return 512;
+    }
+
+    return (size_t) fs.f_frsize;
+}
+
+#else
+
+size_t
+ngx_fs_bsize(u_char *name)
+{
+    return 512;
+}
+
+#endif
diff --git a/src/os/seng/trusted/ngx_files.h b/src/os/seng/trusted/ngx_files.h
new file mode 100644
index 0000000..861f2e3
--- /dev/null
+++ b/src/os/seng/trusted/ngx_files.h
@@ -0,0 +1,379 @@
+#ifndef _NGX_FILES_H_INCLUDED_
+#define _NGX_FILES_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+#include <tSgxSSL_api.h> // STREAM_STDOUT/STDERR
+
+
+typedef int                      ngx_fd_t;
+typedef struct seng_stat_t       ngx_file_info_t;
+typedef ino_t                    ngx_file_uniq_t;
+
+
+typedef struct {
+    u_char                      *name;
+    size_t                       size;
+    void                        *addr;
+    ngx_fd_t                     fd;
+    ngx_log_t                   *log;
+} ngx_file_mapping_t;
+
+
+typedef struct {
+    DIR                         *dir;
+    struct dirent               *de;
+    ngx_file_info_t             info;
+
+    unsigned                     type:8;
+    unsigned                     valid_info:1;
+} ngx_dir_t;
+
+
+typedef struct {
+    size_t                       n;
+    seng_glob_t                  pglob;
+    u_char                      *pattern;
+    ngx_log_t                   *log;
+    ngx_uint_t                   test;
+} ngx_glob_t;
+
+
+#define NGX_INVALID_FILE         -1
+#define NGX_FILE_ERROR           -1
+
+
+#define ngx_open_file(name, mode, create, access)                            \
+    seng_file_open((const char *) name, mode|create, access)
+
+#define ngx_open_file_n          "open()"
+
+#define NGX_FILE_RDONLY          O_RDONLY
+#define NGX_FILE_WRONLY          O_WRONLY
+#define NGX_FILE_RDWR            O_RDWR
+#define NGX_FILE_CREATE_OR_OPEN  O_CREAT
+#define NGX_FILE_OPEN            0
+#define NGX_FILE_TRUNCATE        (O_CREAT|O_TRUNC)
+#define NGX_FILE_APPEND          (O_WRONLY|O_APPEND)
+#define NGX_FILE_NONBLOCK        O_NONBLOCK
+
+#if (NGX_HAVE_OPENAT)
+#define NGX_FILE_NOFOLLOW        O_NOFOLLOW
+
+#if defined(O_DIRECTORY)
+#define NGX_FILE_DIRECTORY       O_DIRECTORY
+#else
+#define NGX_FILE_DIRECTORY       0
+#endif
+
+#if defined(O_SEARCH)
+#define NGX_FILE_SEARCH          (O_SEARCH|NGX_FILE_DIRECTORY)
+
+#elif defined(O_EXEC)
+#define NGX_FILE_SEARCH          (O_EXEC|NGX_FILE_DIRECTORY)
+
+#elif (NGX_HAVE_O_PATH)
+#define NGX_FILE_SEARCH          (O_PATH|O_RDONLY|NGX_FILE_DIRECTORY)
+
+#else
+#define NGX_FILE_SEARCH          (O_RDONLY|NGX_FILE_DIRECTORY)
+#endif
+
+#endif /* NGX_HAVE_OPENAT */
+
+#define NGX_FILE_DEFAULT_ACCESS  0644
+#define NGX_FILE_OWNER_ACCESS    0600
+
+// bcs. cannot mix with seng socket fcntl
+//#define ngx_fcntl_file(fd, cmd)        seng_file_fcntl2(fd, cmd)
+//#define ngx_fcntl_file(fd, cmd, arg)   seng_file_fcntl3(fd, cmd, arg)
+
+#define ngx_close_file           seng_file_close
+#define ngx_close_file_n         "close()"
+
+
+#define ngx_delete_file(name)    seng_unlink((const char *) name)
+#define ngx_delete_file_n        "unlink()"
+
+
+ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,
+    ngx_uint_t access);
+#define ngx_open_tempfile_n      "open()"
+
+
+ssize_t ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset);
+#if (NGX_HAVE_PREAD)
+#define ngx_read_file_n          "pread()"
+#else
+#define ngx_read_file_n          "read()"
+#endif
+
+ssize_t ngx_write_file(ngx_file_t *file, u_char *buf, size_t size,
+    off_t offset);
+
+ssize_t ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *ce,
+    off_t offset, ngx_pool_t *pool);
+
+
+#define ngx_read_fd              seng_file_read
+#define ngx_read_fd_n            "read()"
+
+/*
+ * we use inlined function instead of simple #define
+ * because glibc 2.3 sets warn_unused_result attribute for write()
+ * and in this case gcc 4.3 ignores (void) cast
+ */
+static ngx_inline ssize_t
+ngx_write_fd(ngx_fd_t fd, void *buf, size_t n)
+{
+    return seng_file_write(fd, buf, n);
+}
+
+#define ngx_write_fd_n           "write()"
+
+
+#define ngx_write_console        ngx_write_fd
+
+
+#define ngx_linefeed(p)          *p++ = LF;
+#define NGX_LINEFEED_SIZE        1
+#define NGX_LINEFEED             "\x0a"
+
+
+#define ngx_rename_file(o, n)    seng_rename((const char *) o, (const char *) n)
+#define ngx_rename_file_n        "rename()"
+
+
+#define ngx_change_file_access(n, a) seng_chmod((const char *) n, a)
+#define ngx_change_file_access_n "chmod()"
+
+
+ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);
+#define ngx_set_file_time_n      "utimes()"
+
+
+#define ngx_file_info(file, sb)  seng_stat((const char *) file, sb)
+#define ngx_file_info_n          "stat()"
+
+#define ngx_fd_info(fd, sb)      seng_fstat(fd, sb)
+#define ngx_fd_info_n            "fstat()"
+
+#define ngx_link_info(file, sb)  seng_lstat((const char *) file, sb)
+#define ngx_link_info_n          "lstat()"
+
+#define ngx_is_dir(sb)           (S_ISDIR((sb)->st_mode))
+#define ngx_is_file(sb)          (S_ISREG((sb)->st_mode))
+#define ngx_is_link(sb)          (S_ISLNK((sb)->st_mode))
+#define ngx_is_exec(sb)          (((sb)->st_mode & S_IXUSR) == S_IXUSR)
+#define ngx_file_access(sb)      ((sb)->st_mode & 0777)
+#define ngx_file_size(sb)        (sb)->st_size
+#define ngx_file_fs_size(sb)     ngx_max((sb)->st_size, (sb)->st_blocks * 512)
+#define ngx_file_mtime(sb)       (sb)->st_mtime
+#define ngx_file_uniq(sb)        (sb)->st_ino
+
+
+ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm);
+void ngx_close_file_mapping(ngx_file_mapping_t *fm);
+
+
+#define ngx_realpath(p, r)       (u_char *) seng_realpath((char *) p, (char *) r)
+#define ngx_realpath_n           "realpath()"
+#define ngx_getcwd(buf, size)    (seng_getcwd((char *) buf, size) != NULL)
+#define ngx_getcwd_n             "getcwd()"
+#define ngx_path_separator(c)    ((c) == '/')
+
+
+#if defined(PATH_MAX)
+
+#define NGX_HAVE_MAX_PATH        1
+#define NGX_MAX_PATH             PATH_MAX
+
+#else
+
+#define NGX_MAX_PATH             4096
+
+#endif
+
+
+#define NGX_DIR_MASK_LEN         0
+
+
+ngx_int_t ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir);
+#define ngx_open_dir_n           "opendir()"
+
+
+#define ngx_close_dir(d)         seng_closedir((d)->dir)
+#define ngx_close_dir_n          "closedir()"
+
+
+ngx_int_t ngx_read_dir(ngx_dir_t *dir);
+#define ngx_read_dir_n           "readdir()"
+
+
+#define ngx_create_dir(name, access) seng_mkdir((const char *) name, access)
+#define ngx_create_dir_n         "mkdir()"
+
+
+#define ngx_delete_dir(name)     seng_rmdir((const char *) name)
+#define ngx_delete_dir_n         "rmdir()"
+
+
+#define ngx_dir_access(a)        (a | (a & 0444) >> 2)
+
+
+#define ngx_de_name(dir)         ((u_char *) (dir)->de->d_name)
+#if (NGX_HAVE_D_NAMLEN)
+#define ngx_de_namelen(dir)      (dir)->de->d_namlen
+#else
+#define ngx_de_namelen(dir)      ngx_strlen((dir)->de->d_name)
+#endif
+
+static ngx_inline ngx_int_t
+ngx_de_info(u_char *name, ngx_dir_t *dir)
+{
+    dir->type = 0;
+    return seng_stat((const char *) name, &dir->info);
+}
+
+#define ngx_de_info_n            "stat()"
+#define ngx_de_link_info(name, dir)  seng_lstat((const char *) name, &(dir)->info)
+#define ngx_de_link_info_n       "lstat()"
+
+#if (NGX_HAVE_D_TYPE)
+
+/*
+ * some file systems (e.g. XFS on Linux and CD9660 on FreeBSD)
+ * do not set dirent.d_type
+ */
+
+#define ngx_de_is_dir(dir)                                                   \
+    (((dir)->type) ? ((dir)->type == DT_DIR) : (S_ISDIR((dir)->info.st_mode)))
+#define ngx_de_is_file(dir)                                                  \
+    (((dir)->type) ? ((dir)->type == DT_REG) : (S_ISREG((dir)->info.st_mode)))
+#define ngx_de_is_link(dir)                                                  \
+    (((dir)->type) ? ((dir)->type == DT_LNK) : (S_ISLNK((dir)->info.st_mode)))
+
+#else
+
+#define ngx_de_is_dir(dir)       (S_ISDIR((dir)->info.st_mode))
+#define ngx_de_is_file(dir)      (S_ISREG((dir)->info.st_mode))
+#define ngx_de_is_link(dir)      (S_ISLNK((dir)->info.st_mode))
+
+#endif
+
+#define ngx_de_access(dir)       (((dir)->info.st_mode) & 0777)
+#define ngx_de_size(dir)         (dir)->info.st_size
+#define ngx_de_fs_size(dir)                                                  \
+    ngx_max((dir)->info.st_size, (dir)->info.st_blocks * 512)
+#define ngx_de_mtime(dir)        (dir)->info.st_mtime
+
+
+ngx_int_t ngx_open_glob(ngx_glob_t *gl);
+#define ngx_open_glob_n          "glob()"
+ngx_int_t ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name);
+void ngx_close_glob(ngx_glob_t *gl);
+
+
+ngx_err_t ngx_trylock_fd(ngx_fd_t fd);
+ngx_err_t ngx_lock_fd(ngx_fd_t fd);
+ngx_err_t ngx_unlock_fd(ngx_fd_t fd);
+
+#define ngx_trylock_fd_n         "fcntl(F_SETLK, F_WRLCK)"
+#define ngx_lock_fd_n            "fcntl(F_SETLKW, F_WRLCK)"
+#define ngx_unlock_fd_n          "fcntl(F_SETLK, F_UNLCK)"
+
+
+#if (NGX_HAVE_F_READAHEAD)
+
+#define NGX_HAVE_READ_AHEAD      1
+
+#define ngx_read_ahead(fd, n)    fcntl(fd, F_READAHEAD, (int) n)
+#define ngx_read_ahead_n         "fcntl(fd, F_READAHEAD)"
+
+#elif (NGX_HAVE_POSIX_FADVISE)
+
+#define NGX_HAVE_READ_AHEAD      1
+
+ngx_int_t ngx_read_ahead(ngx_fd_t fd, size_t n);
+#define ngx_read_ahead_n         "posix_fadvise(POSIX_FADV_SEQUENTIAL)"
+
+#else
+
+#define ngx_read_ahead(fd, n)    0
+#define ngx_read_ahead_n         "ngx_read_ahead_n"
+
+#endif
+
+
+#if (NGX_HAVE_O_DIRECT)
+
+ngx_int_t ngx_directio_on(ngx_fd_t fd);
+#define ngx_directio_on_n        "fcntl(O_DIRECT)"
+
+ngx_int_t ngx_directio_off(ngx_fd_t fd);
+#define ngx_directio_off_n       "fcntl(!O_DIRECT)"
+
+#elif (NGX_HAVE_F_NOCACHE)
+
+#define ngx_directio_on(fd)      fcntl(fd, F_NOCACHE, 1)
+#define ngx_directio_on_n        "fcntl(F_NOCACHE, 1)"
+
+#elif (NGX_HAVE_DIRECTIO)
+
+#define ngx_directio_on(fd)      directio(fd, DIRECTIO_ON)
+#define ngx_directio_on_n        "directio(DIRECTIO_ON)"
+
+#else
+
+#define ngx_directio_on(fd)      0
+#define ngx_directio_on_n        "ngx_directio_on_n"
+
+#endif
+
+size_t ngx_fs_bsize(u_char *name);
+
+
+#if (NGX_HAVE_OPENAT)
+
+#define ngx_openat_file(fd, name, mode, create, access)                      \
+    openat(fd, (const char *) name, mode|create, access)
+
+#define ngx_openat_file_n        "openat()"
+
+#define ngx_file_at_info(fd, name, sb, flag)                                 \
+    fstatat(fd, (const char *) name, sb, flag)
+
+#define ngx_file_at_info_n       "fstatat()"
+
+#define NGX_AT_FDCWD             (ngx_fd_t) AT_FDCWD
+
+#endif
+
+
+#define ngx_stdout               STREAM_STDOUT
+#define ngx_stderr               STREAM_STDERR
+#define ngx_set_stderr(fd)       seng_dup2(fd, STREAM_STDERR)
+#define ngx_set_stderr_n         "dup2(STREAM_STDERR)"
+
+
+#if (NGX_HAVE_FILE_AIO)
+
+ngx_int_t ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool);
+ssize_t ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size,
+    off_t offset, ngx_pool_t *pool);
+
+extern ngx_uint_t  ngx_file_aio;
+
+#endif
+
+#if (NGX_THREADS)
+ssize_t ngx_thread_read(ngx_file_t *file, u_char *buf, size_t size,
+    off_t offset, ngx_pool_t *pool);
+ssize_t ngx_thread_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl,
+    off_t offset, ngx_pool_t *pool);
+#endif
+
+
+#endif /* _NGX_FILES_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_os.h b/src/os/seng/trusted/ngx_os.h
new file mode 100644
index 0000000..e22f07c
--- /dev/null
+++ b/src/os/seng/trusted/ngx_os.h
@@ -0,0 +1,99 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_OS_H_INCLUDED_
+#define _NGX_OS_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#define NGX_IO_SENDFILE    1
+
+
+typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);
+typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
+    off_t limit);
+typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);
+typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,
+    off_t limit);
+
+typedef struct {
+    ngx_recv_pt        recv;
+    ngx_recv_chain_pt  recv_chain;
+    ngx_recv_pt        udp_recv;
+    ngx_send_pt        send;
+    ngx_send_pt        udp_send;
+    ngx_send_chain_pt  send_chain;
+    ngx_uint_t         flags;
+} ngx_os_io_t;
+
+
+ngx_int_t ngx_os_init(ngx_log_t *log);
+void ngx_os_status(ngx_log_t *log);
+ngx_int_t ngx_os_specific_init(ngx_log_t *log);
+void ngx_os_specific_status(ngx_log_t *log);
+ngx_int_t ngx_daemon(ngx_log_t *log);
+ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid);
+
+
+ssize_t ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);
+ssize_t ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *entry, off_t limit);
+ssize_t ngx_udp_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);
+ssize_t ngx_unix_send(ngx_connection_t *c, u_char *buf, size_t size);
+ngx_chain_t *ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in,
+    off_t limit);
+ssize_t ngx_udp_unix_send(ngx_connection_t *c, u_char *buf, size_t size);
+
+
+#if (IOV_MAX > 64)
+#define NGX_IOVS_PREALLOCATE  64
+#else
+#define NGX_IOVS_PREALLOCATE  IOV_MAX
+#endif
+
+
+typedef struct {
+    struct iovec  *iovs;
+    ngx_uint_t     count;
+    size_t         size;
+    ngx_uint_t     nalloc;
+} ngx_iovec_t;
+
+ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in,
+    size_t limit, ngx_log_t *log);
+
+
+ssize_t ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec);
+
+
+extern ngx_os_io_t  ngx_os_io;
+extern ngx_int_t    ngx_ncpu;
+extern ngx_int_t    ngx_max_sockets;
+extern ngx_uint_t   ngx_inherited_nonblocking;
+extern ngx_uint_t   ngx_tcp_nodelay_and_tcp_nopush;
+
+
+#if (NGX_FREEBSD)
+#include <ngx_freebsd.h>
+
+
+#elif (NGX_LINUX)
+#include <ngx_linux.h>
+
+
+#elif (NGX_SOLARIS)
+#include <ngx_solaris.h>
+
+
+#elif (NGX_DARWIN)
+#include <ngx_darwin.h>
+#endif
+
+
+#endif /* _NGX_OS_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_process.c b/src/os/seng/trusted/ngx_process.c
new file mode 100644
index 0000000..b5d6033
--- /dev/null
+++ b/src/os/seng/trusted/ngx_process.c
@@ -0,0 +1,87 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+#include "ngx_seng_t.h"
+
+int              ngx_argc;
+char           **ngx_argv;
+char           **ngx_os_argv;
+
+
+ngx_pid_t
+ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,
+    char *name, ngx_int_t respawn)
+{
+    (void)(data);
+    (void)(name);
+    (void)(respawn);
+
+    ngx_log_error(NGX_LOG_ERR, cycle->log, 0, "ngx_spawn_process currently not supported in SENG");
+    abort();
+
+    // NOT REACHED
+    return -1;
+}
+
+
+ngx_pid_t
+ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)
+{
+    (void)(ctx);
+    ngx_log_error(NGX_LOG_ERR, cycle->log, 0, "ngx_execute currently not supported in SENG");
+    abort();
+
+    // NOT REACHED
+    return -1;
+}
+
+ngx_int_t
+ngx_init_signals(ngx_log_t *log)
+{
+    long int ret = NGX_ERROR;
+    ocall_ngx_init_signals(&ret);
+    return ret;
+}
+
+
+void
+ngx_debug_point(void)
+{
+    // TODO: might consider keeping via OCALL for "raise()"
+    ngx_abort();
+
+    // NOT REACHED
+
+/*
+    ngx_core_conf_t  *ccf;
+
+    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,
+                                           ngx_core_module);
+
+    switch (ccf->debug_points) {
+
+    case NGX_DEBUG_POINTS_STOP:
+        raise(SIGSTOP);
+        break;
+
+    case NGX_DEBUG_POINTS_ABORT:
+        ngx_abort();
+    }
+ */
+}
+
+
+ngx_int_t
+ngx_os_signal_process(ngx_cycle_t *cycle, char *name, ngx_pid_t pid)
+{
+    (void)(name);
+    (void)(pid);
+
+    // TODO: implement via OCALL or remove??
+    ngx_log_error(NGX_LOG_ERR, cycle->log, 0, "NOT (YET?) IMPLEMENTED: ngx_os_signal_process");
+    abort();
+
+    // NOT REACHED
+    return 1;
+}
diff --git a/src/os/seng/trusted/ngx_process.h b/src/os/seng/trusted/ngx_process.h
new file mode 100644
index 0000000..4f292cd
--- /dev/null
+++ b/src/os/seng/trusted/ngx_process.h
@@ -0,0 +1,58 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_PROCESS_H_INCLUDED_
+#define _NGX_PROCESS_H_INCLUDED_
+
+
+#include <ngx_setaffinity.h>
+#include <ngx_setproctitle.h>
+
+
+typedef pid_t       ngx_pid_t;
+
+#define NGX_INVALID_PID  -1
+
+typedef void (*ngx_spawn_proc_pt) (ngx_cycle_t *cycle, void *data);
+
+typedef struct {
+    char         *path;
+    char         *name;
+    char *const  *argv;
+    char *const  *envp;
+} ngx_exec_ctx_t;
+
+
+#define ngx_getpid   getpid
+
+#ifndef ngx_log_pid
+#define ngx_log_pid  ngx_pid
+#endif
+
+
+ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle,
+    ngx_spawn_proc_pt proc, void *data, char *name, ngx_int_t respawn);
+ngx_pid_t ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx);
+ngx_int_t ngx_init_signals(ngx_log_t *log);
+void ngx_debug_point(void);
+
+
+#if (NGX_HAVE_SCHED_YIELD)
+#define ngx_sched_yield()  sched_yield()
+#else
+#define ngx_sched_yield()  usleep(1)
+#endif
+
+
+extern int            ngx_argc;
+extern char         **ngx_argv;
+extern char         **ngx_os_argv;
+
+extern ngx_pid_t      ngx_pid;
+
+
+#endif /* _NGX_PROCESS_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_process_cycle.c b/src/os/seng/trusted/ngx_process_cycle.c
new file mode 100644
index 0000000..6d067d7
--- /dev/null
+++ b/src/os/seng/trusted/ngx_process_cycle.c
@@ -0,0 +1,152 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+
+static void ngx_master_process_exit(ngx_cycle_t *cycle);
+
+
+ngx_uint_t    ngx_process;
+ngx_uint_t    ngx_worker;
+ngx_pid_t     ngx_pid;
+
+sig_atomic_t *  uptr_ngx_quit;
+sig_atomic_t *  uptr_ngx_terminate;
+sig_atomic_t *  uptr_ngx_reconfigure;
+sig_atomic_t *  uptr_ngx_reopen;
+
+//sig_atomic_t *ngx_terminate;
+//sig_atomic_t *ngx_quit;
+
+ngx_uint_t    ngx_exiting;
+//sig_atomic_t *ngx_reconfigure;
+//sig_atomic_t *ngx_reopen;
+
+ngx_pid_t     ngx_new_binary;
+ngx_uint_t    ngx_inherited;
+ngx_uint_t    ngx_daemonized;
+
+ngx_uint_t    ngx_noaccepting;
+ngx_uint_t    ngx_restart;
+
+
+static ngx_cycle_t      ngx_exit_cycle;
+static ngx_log_t        ngx_exit_log;
+static ngx_open_file_t  ngx_exit_log_file;
+
+
+void
+ngx_master_process_cycle(ngx_cycle_t *cycle)
+{
+    ngx_log_error(NGX_LOG_ERR, cycle->log, 0, "master process-mode currently not supported in SENG");
+    abort();
+
+    // NOT REACHED
+}
+
+
+void
+ngx_single_process_cycle(ngx_cycle_t *cycle)
+{
+    ngx_uint_t  i;
+
+    if (ngx_set_environment(cycle, NULL) == NULL) {
+        /* fatal */
+        exit(2);
+    }
+
+    for (i = 0; cycle->modules[i]; i++) {
+        if (cycle->modules[i]->init_process) {
+            if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {
+                /* fatal */
+                exit(2);
+            }
+        }
+    }
+
+    for ( ;; ) {
+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, "worker cycle");
+
+        ngx_process_events_and_timers(cycle);
+
+        if (ngx_terminate || ngx_quit) {
+
+            for (i = 0; cycle->modules[i]; i++) {
+                if (cycle->modules[i]->exit_process) {
+                    cycle->modules[i]->exit_process(cycle);
+                }
+            }
+
+            ngx_master_process_exit(cycle);
+        }
+
+        if (ngx_reconfigure) {
+            ngx_reconfigure = 0;
+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");
+
+            cycle = ngx_init_cycle(cycle);
+            if (cycle == NULL) {
+                cycle = (ngx_cycle_t *) ngx_cycle;
+                continue;
+            }
+
+            ngx_cycle = cycle;
+        }
+
+        if (ngx_reopen) {
+            ngx_reopen = 0;
+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
+            ngx_reopen_files(cycle, (ngx_uid_t) -1);
+        }
+    }
+}
+
+
+static void
+ngx_master_process_exit(ngx_cycle_t *cycle)
+{
+    ngx_uint_t  i;
+
+    ngx_delete_pidfile(cycle);
+
+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exit");
+
+    for (i = 0; cycle->modules[i]; i++) {
+        if (cycle->modules[i]->exit_master) {
+            cycle->modules[i]->exit_master(cycle);
+        }
+    }
+
+    ngx_close_listening_sockets(cycle);
+
+    /*
+     * Copy ngx_cycle->log related data to the special static exit cycle,
+     * log, and log file structures enough to allow a signal handler to log.
+     * The handler may be called when standard ngx_cycle->log allocated from
+     * ngx_cycle->pool is already destroyed.
+     */
+
+
+    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);
+
+    ngx_exit_log_file.fd = ngx_exit_log.file->fd;
+    ngx_exit_log.file = &ngx_exit_log_file;
+    ngx_exit_log.next = NULL;
+    ngx_exit_log.writer = NULL;
+
+    ngx_exit_cycle.log = &ngx_exit_log;
+    ngx_exit_cycle.files = ngx_cycle->files;
+    ngx_exit_cycle.files_n = ngx_cycle->files_n;
+    ngx_cycle = &ngx_exit_cycle;
+
+    ngx_destroy_pool(cycle->pool);
+
+    exit(0);
+}
diff --git a/src/os/seng/trusted/ngx_process_cycle.h b/src/os/seng/trusted/ngx_process_cycle.h
new file mode 100644
index 0000000..9848cb1
--- /dev/null
+++ b/src/os/seng/trusted/ngx_process_cycle.h
@@ -0,0 +1,51 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_
+#define _NGX_PROCESS_CYCLE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#define NGX_PROCESS_SINGLE     0
+#define NGX_PROCESS_MASTER     1
+#define NGX_PROCESS_SIGNALLER  2
+#define NGX_PROCESS_WORKER     3
+#define NGX_PROCESS_HELPER     4
+
+
+void ngx_master_process_cycle(ngx_cycle_t *cycle);
+void ngx_single_process_cycle(ngx_cycle_t *cycle);
+
+
+extern ngx_uint_t      ngx_process;
+extern ngx_uint_t      ngx_worker;
+extern ngx_pid_t       ngx_pid;
+extern ngx_pid_t       ngx_new_binary;
+extern ngx_uint_t      ngx_inherited;
+extern ngx_uint_t      ngx_daemonized;
+extern ngx_uint_t      ngx_exiting;
+
+//extern sig_atomic_t *  ngx_quit;
+//extern sig_atomic_t *  ngx_terminate;
+//extern sig_atomic_t *  ngx_reconfigure;
+//extern sig_atomic_t *  ngx_reopen;
+
+extern sig_atomic_t *  uptr_ngx_quit;
+extern sig_atomic_t *  uptr_ngx_terminate;
+extern sig_atomic_t *  uptr_ngx_reconfigure;
+extern sig_atomic_t *  uptr_ngx_reopen;
+
+#define ngx_quit (*uptr_ngx_quit)
+#define ngx_terminate (*uptr_ngx_terminate)
+#define ngx_reconfigure (*uptr_ngx_reconfigure)
+#define ngx_reopen (*uptr_ngx_reopen)
+
+
+#endif /* _NGX_PROCESS_CYCLE_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_readv_chain.c b/src/os/seng/trusted/ngx_readv_chain.c
new file mode 100644
index 0000000..2857dfc
--- /dev/null
+++ b/src/os/seng/trusted/ngx_readv_chain.c
@@ -0,0 +1,182 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+
+ssize_t
+ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)
+{
+    u_char        *prev;
+    ssize_t        n, size;
+    ngx_err_t      err;
+    ngx_array_t    vec;
+    ngx_event_t   *rev;
+    struct iovec  *iov, iovs[NGX_IOVS_PREALLOCATE];
+
+    rev = c->read;
+
+#if (NGX_HAVE_KQUEUE)
+
+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "readv: eof:%d, avail:%d, err:%d",
+                       rev->pending_eof, rev->available, rev->kq_errno);
+
+        if (rev->available == 0) {
+            if (rev->pending_eof) {
+                rev->ready = 0;
+                rev->eof = 1;
+
+                ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,
+                              "kevent() reported about an closed connection");
+
+                if (rev->kq_errno) {
+                    rev->error = 1;
+                    ngx_set_socket_errno(rev->kq_errno);
+                    return NGX_ERROR;
+                }
+
+                return 0;
+
+            } else {
+                return NGX_AGAIN;
+            }
+        }
+    }
+
+#endif
+
+    prev = NULL;
+    iov = NULL;
+    size = 0;
+
+    vec.elts = iovs;
+    vec.nelts = 0;
+    vec.size = sizeof(struct iovec);
+    vec.nalloc = NGX_IOVS_PREALLOCATE;
+    vec.pool = c->pool;
+
+    /* coalesce the neighbouring bufs */
+
+    while (chain) {
+        n = chain->buf->end - chain->buf->last;
+
+        if (limit) {
+            if (size >= limit) {
+                break;
+            }
+
+            if (size + n > limit) {
+                n = (ssize_t) (limit - size);
+            }
+        }
+
+        if (prev == chain->buf->last) {
+            iov->iov_len += n;
+
+        } else {
+            if (vec.nelts >= IOV_MAX) {
+                break;
+            }
+
+            iov = ngx_array_push(&vec);
+            if (iov == NULL) {
+                return NGX_ERROR;
+            }
+
+            iov->iov_base = (void *) chain->buf->last;
+            iov->iov_len = n;
+        }
+
+        size += n;
+        prev = chain->buf->end;
+        chain = chain->next;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "readv: %ui, last:%uz", vec.nelts, iov->iov_len);
+
+    do {
+        n = seng_readv(c->fd, (struct iovec *) vec.elts, vec.nelts);
+
+        if (n == 0) {
+            rev->ready = 0;
+            rev->eof = 1;
+
+#if (NGX_HAVE_KQUEUE)
+
+            /*
+             * on FreeBSD readv() may return 0 on closed socket
+             * even if kqueue reported about available data
+             */
+
+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
+                rev->available = 0;
+            }
+
+#endif
+
+            return 0;
+        }
+
+        if (n > 0) {
+
+#if (NGX_HAVE_KQUEUE)
+
+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
+                rev->available -= n;
+
+                /*
+                 * rev->available may be negative here because some additional
+                 * bytes may be received between kevent() and readv()
+                 */
+
+                if (rev->available <= 0) {
+                    if (!rev->pending_eof) {
+                        rev->ready = 0;
+                    }
+
+                    rev->available = 0;
+                }
+
+                return n;
+            }
+
+#endif
+
+            if (n < size && !(ngx_event_flags & NGX_USE_GREEDY_EVENT)) {
+                rev->ready = 0;
+            }
+
+            return n;
+        }
+
+        err = ngx_socket_errno;
+
+        if (err == NGX_EAGAIN || err == NGX_EINTR) {
+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
+                           "readv() not ready");
+            n = NGX_AGAIN;
+
+        } else {
+            n = ngx_connection_error(c, err, "readv() failed");
+            break;
+        }
+
+    } while (err == NGX_EINTR);
+
+    rev->ready = 0;
+
+    if (n == NGX_ERROR) {
+        c->read->error = 1;
+    }
+
+    return n;
+}
diff --git a/src/os/seng/trusted/ngx_seng.edl b/src/os/seng/trusted/ngx_seng.edl
new file mode 100644
index 0000000..b0b0534
--- /dev/null
+++ b/src/os/seng/trusted/ngx_seng.edl
@@ -0,0 +1,13 @@
+enclave {
+    from "seng.edl" import *;
+    from "ngx_sys_wrappers.edl" import *;
+
+    untrusted {
+        long int ocall_init_signal_atomics([out] struct seng_ngx_sigatomics *atomics);
+        long int ocall_ngx_init_signals(void);
+    };
+
+    trusted {
+        public int ecall_run_nginx(int u_argc, [user_check] char **u_argv, [user_check] char **envp);
+    };
+};
\ No newline at end of file
diff --git a/src/os/seng/trusted/ngx_seng.h b/src/os/seng/trusted/ngx_seng.h
new file mode 100644
index 0000000..103a7c2
--- /dev/null
+++ b/src/os/seng/trusted/ngx_seng.h
@@ -0,0 +1,10 @@
+#ifndef _NGX_SENG_H_INCLUDED_
+#define _NGX_SENG_H_INCLUDED_
+
+
+// not supported by lwIP
+/*ngx_chain_t *ngx_seng_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,
+    off_t limit);*/
+
+
+#endif /* _NGX_SENG_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_seng.lds b/src/os/seng/trusted/ngx_seng.lds
new file mode 100644
index 0000000..48371a6
--- /dev/null
+++ b/src/os/seng/trusted/ngx_seng.lds
@@ -0,0 +1,12 @@
+ngx_seng.so
+{
+    global:
+        enclave_entry;
+        g_global_data_sim;
+        g_global_data;
+        g_peak_heap_used;
+    local:
+        *;
+};
+
+# NOTE(!): if g_global_data not there, will fail signing with no useful error msg!!
diff --git a/src/os/seng/trusted/ngx_seng_config.h b/src/os/seng/trusted/ngx_seng_config.h
new file mode 100644
index 0000000..5af7eac
--- /dev/null
+++ b/src/os/seng/trusted/ngx_seng_config.h
@@ -0,0 +1,343 @@
+#ifndef _NGX_SENG_CONFIG_H_INCLUDED_
+#define _NGX_SENG_CONFIG_H_INCLUDED_
+
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE             /* pread(), pwrite(), gethostname() */
+#endif
+
+#define _FILE_OFFSET_BITS  64
+
+// place this first, bcs. then we get less LITTLE_ENDIAN redefinition errors (and co.)
+#include <seng_api.hpp>
+
+#include "ngx_seng_t.h"
+
+// The SENG implementation that are currently mostly direct OCALL wrappers
+#include "t_ngx_process_user.h"
+#include "t_ngx_time.h"
+#include "t_ngx_rlimit.h"
+
+// TODO: how to handle?
+#define exit(v) abort()
+
+// TODO: if typedef tests in auto/os/seng would work correctly, woudl be auto-added
+#ifndef rlim_t
+typedef int rlim_t;
+#endif
+
+// Define same way as in Linux
+typedef int sig_atomic_t;
+
+// Files
+typedef unsigned long int   ino_t;
+typedef void*            DIR; // opaque
+#define dirent seng_dirent
+
+// ++ File Locks
+#define flock seng_flock
+#ifndef F_RDLCK
+#define F_RDLCK     0
+#define F_WRLCK     1
+#define F_UNLCK     2
+#endif
+#ifndef F_SETLK
+#define F_SETLK     6
+#define F_SETLKW    7
+#endif
+#include "t_ngx_files.h" // OCALL wrappers
+
+// for constant defines
+#include "linux/stat.h"
+
+// lseek
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif
+
+// fcntl and co.
+#ifndef O_EXCL
+#define O_EXCL 0200
+#endif
+
+#ifndef O_CREAT
+#define O_CREAT 0100
+#endif
+
+#ifndef O_TRUNC
+#define O_TRUNC 01000
+#endif
+
+#ifndef O_APPEND
+#define O_APPEND 02000
+#endif
+
+#ifndef FD_CLOEXEC
+#define FD_CLOEXEC 1
+#endif
+
+#ifndef F_SETFD
+#define F_SETFD 2
+#endif
+
+// Glob
+#ifndef GLOB_NOSPACE
+#define GLOB_NOSPACE    1   /* Ran out of memory.  */
+#define GLOB_ABORTED    2   /* Read error.  */
+#define GLOB_NOMATCH    3   /* No matches found.  */
+#define GLOB_NOSYS  4   /* Not implemented.  */
+#endif
+
+// TODO: because direct use @ core/ngx_file.c (which is inconsistent!!)
+//      should instead use the portable "ngx_change_file_access" of
+#define chmod seng_chmod
+
+// Process, User, Group
+typedef int pid_t;
+typedef unsigned int gid_t;
+typedef unsigned int uid_t;
+
+#define chown seng_chown
+
+// todo: typedefs not working
+#define passwd seng_passwd
+#define group seng_group
+
+#define getpid seng_getpid
+#define geteuid seng_geteuid
+#define getuid seng_getuid
+#define getenv seng_getenv_copy
+#define getpwnam seng_getpwnam
+#define getgrnam seng_getgrnam
+
+
+//#include <sys/types.h> // LITTLE_ENDIAN redefined
+//#include <sys/time.h> // TODO: OCALLs
+#include <unistd.h>
+#include <stdarg.h>
+#include <stddef.h>             /* offsetof() */
+#include <stdio.h>
+//#include <stdlib.h> // LITTLE_ENDIAN redefined
+//#include <ctype.h>
+#include <errno.h>
+#include <string.h>
+
+// TODO: does enclave auto-resume after signal handler returns? --> cf. sgxssl/sdk
+//#include <signal.h> // TODO: untrusted nginx code with handlers; 
+
+//#include <pwd.h> // missing
+//#include <grp.h> // missing
+//#include <dirent.h> // missing
+//#include <glob.h> // missing
+//#include <sys/vfs.h>            /* statfs() */ // missing
+
+//#include <sys/uio.h> // missing
+//#include <sys/stat.h> // missing
+//#include <fcntl.h> // missing
+
+//#include <sys/wait.h> // missing
+//#include <sys/mman.h> // missing
+//#include <sys/resource.h> // missing
+//#include <sched.h> // missing
+
+/*
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>        // TCP_NODELAY, TCP_CORK
+#include <arpa/inet.h>
+#include <netdb.h>*/
+//#include <sys/un.h> // missing
+
+#include <time.h>               /* tzset() */ // NOTE: hits header exists in tlibc!
+//#include <malloc.h>             /* memalign() */ // missing
+#include <limits.h>             /* IOV_MAX */ // NOTE: exists in tlibc and tlibc/sys/
+//#include <sys/ioctl.h> // TODO: conflict with lwIP files vs sockets (+ missing in sdk)
+
+//#include <crypt.h> // TODO: either <sgx_tcrypto.h>, SGX-SSL or OpenSSL inside SGX-SSL
+
+//#include <sys/utsname.h>        /* uname() */ // missing
+
+//#include <dlfcn.h> // -> dlopen() ==> of course NOT supported
+
+#include <ngx_auto_config.h>
+
+// Currently not supported by SENG
+#define AF_UNIX 1
+
+// TODO: add defines for libc functions to seng variants
+// TODO: problem --> might have to re-introduce FD-types to some extend for overloaded file+socket fcts,
+//          or have to adapt those function separately
+// NOTE: could also in theory provide own versions of i/o fct ptrs
+//#define send seng_send
+#define getsockname seng_getsockname
+#define getpeername seng_getpeername
+
+#define getaddrinfo seng_getaddrinfo
+#define freeaddrinfo seng_freeaddrinfo
+
+// TODO: overload with files
+// not yet sure whether only used on sockets, but it seems so; add wrapper with check
+int seng_checked_poll(struct pollfd *fds, nfds_t nfds, int timeout);
+#define poll seng_checked_poll
+//#define poll seng_poll // #if (NGX_HAVE_POLL)
+//#define select seng_select
+
+#define recv seng_recv
+#define recvfrom seng_recvfrom
+#define recvmsg seng_recvmsg
+
+// TODO: overload with files
+//#define read seng_read(int fd, void *buf, size_t count);
+
+
+//#define readv seng_readv
+// seng_readv --> @ recv_chain()
+
+// TODO: needed? ++ overloaded
+//#define __recv_chk __seng_recv_chk
+//#define __read_chk __seng_read_chk
+
+#define send seng_send
+#define sendto seng_sendto
+#define sendmsg seng_sendmsg
+
+// TODO: overloaded with files
+//#define write seng_write
+
+//#define writev seng_writev
+// seng_writev --> @ send_chain()
+// seng_file_writev --> @ ngx_writev_file()
+// #define iovec seng_iovec // -- lwIP has own 'struct iovec' definition
+
+// TODO: probably have to check used options and co. (whether supported)
+// TODO: ++ overload with files
+//#define ioctl seng_ioctl(int fd, unsigned long request, va_list args)
+//#define fcntl seng_fcntl(int fd, int cmd, ...)
+
+#define getsockopt seng_getsockopt
+#define setsockopt seng_setsockopt
+
+// No POSIX/Linux/GNU, right?
+//int seng_isfdtype(int fd, int fdtype);
+
+#define socket seng_socket
+
+#define connect seng_connect
+
+#define bind seng_bind
+
+#define listen seng_listen
+#define accept seng_accept
+#define accept4 seng_accept4
+
+// TODO: overload with files
+//#define close seng_close
+
+#define shutdown seng_shutdown
+
+
+
+
+// For time
+// TODO: unclear whether that will work out --> defined @ sgxssl/Linux/sgx/
+struct tm* sgxssl_gmtime(const time_t* timep);
+struct tm* sgxssl_gmtime_r(const time_t* timep, struct tm *result);
+#define gmtime sgxssl_gmtime
+#define gmtime_r sgxssl_gmtime_r
+
+#define gettimeofday(tvp, tzp) seng_gettimeofday((struct seng_timeval *)tvp, (void *) tzp)
+
+#define localtime (struct tm*)seng_localtime
+#define sleep seng_sleep
+#define usleep seng_usleep
+
+#define mktime(tmp) seng_mktime((struct seng_tm*)tmp)
+
+
+
+// For DNS
+#define gethostbyname seng_gethostbyname
+
+#define gethostname seng_gethostname
+
+#define htonl lwip_htonl
+#define htons lwip_htons
+#define ntohs lwip_ntohs
+#define ntohl lwip_ntohl
+
+
+// MISC
+long int seng_random(void);
+#define random seng_random
+
+void seng_srandom(unsigned int seed);
+#define srandom seng_srandom
+
+
+// Resource Limits
+typedef unsigned long int rlimt_t; // todo: wrong type?
+#define rlimit seng_rlimit
+#define getrlimit seng_getrlimit
+#define RLIMIT_NOFILE 7
+
+
+
+// TODO: either have to switch off / remove if possible; otherwise might need to work around it / ocall them where possible
+// Not supported in lwIP at the moment:
+
+//int seng_ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);
+//int seng_pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);
+//int seng_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
+
+//int seng_recvmmsgs(int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags, struct timespec *timeout);
+//int seng_sendmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags);
+
+//ssize_t seng_sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
+
+//int seng_dup(int oldfd) throw();
+//int seng_dup2(int oldfd, int newfd);
+//int seng_dup3(int oldfd, int newfd, int flags);  // Linux-specific
+
+//int seng_sockatmark(int sockfd);
+
+
+
+
+// TODO: missing in SGX SDK, but could be easily added via Locks 
+//      + Cond. Variables if required! [cf. also sys-arch lwIP implementation]
+//#if (NGX_HAVE_POSIX_SEM)
+//#include <semaphore.h>
+//#endif
+
+
+// missing --> should disable header!
+//#if (NGX_HAVE_SYS_PRCTL_H)
+//#include <sys/prctl.h>
+//#endif
+
+
+//#include <sys/syscall.h> // obviously missing
+
+
+#define NGX_LISTEN_BACKLOG        511
+
+
+#ifndef NGX_HAVE_SO_SNDLOWAT
+/* setsockopt(SO_SNDLOWAT) returns ENOPROTOOPT */
+#define NGX_HAVE_SO_SNDLOWAT         0
+#endif
+
+
+#ifndef NGX_HAVE_INHERITED_NONBLOCK
+#define NGX_HAVE_INHERITED_NONBLOCK  0
+#endif
+
+
+#define NGX_HAVE_OS_SPECIFIC_INIT    1
+#define ngx_debug_init()
+
+
+extern char **environ;
+
+
+#endif /* _NGX_SENG_CONFIG_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_seng_init.c b/src/os/seng/trusted/ngx_seng_init.c
new file mode 100644
index 0000000..dd0097c
--- /dev/null
+++ b/src/os/seng/trusted/ngx_seng_init.c
@@ -0,0 +1,57 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+// TODO: add "uname"-OCALL to fill it dynamically
+const char *ngx_seng_kern_ostype = "Linux";
+const char *ngx_seng_kern_osrelease = "4.15.0";
+
+
+static ngx_os_io_t ngx_seng_io = {
+    ngx_unix_recv,
+    ngx_readv_chain,
+    ngx_udp_unix_recv,
+    ngx_unix_send,
+    ngx_udp_unix_send,
+    ngx_writev_chain,
+    0
+};
+
+
+ngx_int_t
+ngx_os_specific_init(ngx_log_t *log)
+{
+// TODO: add "uname"-OCALL
+/*
+    struct utsname  u;
+
+    if (uname(&u) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, "uname() failed");
+        return NGX_ERROR;
+    }
+
+    (void) ngx_cpystrn(ngx_seng_kern_ostype, (u_char *) u.sysname,
+                       sizeof(ngx_seng_kern_ostype));
+
+    (void) ngx_cpystrn(ngx_seng_kern_osrelease, (u_char *) u.release,
+                       sizeof(ngx_seng_kern_osrelease));
+*/
+
+    // Initialize the SENG runtime
+    // TODO: add possiblity to configure tunnel IP+port via NGINX config file
+    if (0 != init_seng_runtime("127.0.0.1", 12345)) {
+        return NGX_ERROR;
+    }
+
+    ngx_os_io = ngx_seng_io;
+
+    return NGX_OK;
+}
+
+
+void
+ngx_os_specific_status(ngx_log_t *log)
+{
+    ngx_log_error(NGX_LOG_NOTICE, log, 0, "OS: %s %s",
+                  ngx_seng_kern_ostype, ngx_seng_kern_osrelease);
+}
diff --git a/src/os/seng/trusted/ngx_setaffinity.c b/src/os/seng/trusted/ngx_setaffinity.c
new file mode 100644
index 0000000..34ec390
--- /dev/null
+++ b/src/os/seng/trusted/ngx_setaffinity.c
@@ -0,0 +1,53 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#if (NGX_HAVE_CPUSET_SETAFFINITY)
+
+void
+ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log)
+{
+    ngx_uint_t  i;
+
+    for (i = 0; i < CPU_SETSIZE; i++) {
+        if (CPU_ISSET(i, cpu_affinity)) {
+            ngx_log_error(NGX_LOG_NOTICE, log, 0,
+                          "cpuset_setaffinity(): using cpu #%ui", i);
+        }
+    }
+
+    if (cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,
+                           sizeof(cpuset_t), cpu_affinity) == -1)
+    {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                      "cpuset_setaffinity() failed");
+    }
+}
+
+#elif (NGX_HAVE_SCHED_SETAFFINITY)
+
+void
+ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log)
+{
+    ngx_uint_t  i;
+
+    for (i = 0; i < CPU_SETSIZE; i++) {
+        if (CPU_ISSET(i, cpu_affinity)) {
+            ngx_log_error(NGX_LOG_NOTICE, log, 0,
+                          "sched_setaffinity(): using cpu #%ui", i);
+        }
+    }
+
+    if (sched_setaffinity(0, sizeof(cpu_set_t), cpu_affinity) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,
+                      "sched_setaffinity() failed");
+    }
+}
+
+#endif
diff --git a/src/os/seng/trusted/ngx_setaffinity.h b/src/os/seng/trusted/ngx_setaffinity.h
new file mode 100644
index 0000000..a4139ed
--- /dev/null
+++ b/src/os/seng/trusted/ngx_setaffinity.h
@@ -0,0 +1,37 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ */
+
+#ifndef _NGX_SETAFFINITY_H_INCLUDED_
+#define _NGX_SETAFFINITY_H_INCLUDED_
+
+
+#if (NGX_HAVE_SCHED_SETAFFINITY || NGX_HAVE_CPUSET_SETAFFINITY)
+
+#define NGX_HAVE_CPU_AFFINITY 1
+
+#if (NGX_HAVE_SCHED_SETAFFINITY)
+
+typedef cpu_set_t  ngx_cpuset_t;
+
+#elif (NGX_HAVE_CPUSET_SETAFFINITY)
+
+#include <sys/cpuset.h>
+
+typedef cpuset_t  ngx_cpuset_t;
+
+#endif
+
+void ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log);
+
+#else
+
+#define ngx_setaffinity(cpu_affinity, log)
+
+typedef uint64_t  ngx_cpuset_t;
+
+#endif
+
+
+#endif /* _NGX_SETAFFINITY_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_shmem.c b/src/os/seng/trusted/ngx_shmem.c
new file mode 100644
index 0000000..2aacb1c
--- /dev/null
+++ b/src/os/seng/trusted/ngx_shmem.c
@@ -0,0 +1,29 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+// NOTE: currently no shared memory in SENG, because SGX only supports untrusted shared memory
+// 1 way to solve it would be to distinguish trusted vs. untrusted shared memory, and protect trusted shared memory
+// via authenticated encryption / integrity from untrusted code ++ accessor API
+
+// currently the memory is process-local ++ enclave-only
+
+ngx_int_t
+ngx_shm_alloc(ngx_shm_t *shm)
+{
+    shm->addr = (u_char *) calloc(1, shm->size);
+    if (shm->addr == NULL) {
+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,
+                      "calloc(%uz) failed", shm->size);
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_shm_free(ngx_shm_t *shm)
+{
+    free((void *) shm->addr);
+}
\ No newline at end of file
diff --git a/src/os/seng/trusted/ngx_shmem.h b/src/os/seng/trusted/ngx_shmem.h
new file mode 100644
index 0000000..490f314
--- /dev/null
+++ b/src/os/seng/trusted/ngx_shmem.h
@@ -0,0 +1,30 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_SHMEM_H_INCLUDED_
+#define _NGX_SHMEM_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+// TODO: could add type: {trusted, untrusted} ++ enc/sign key ptr(s)
+typedef struct {
+    u_char      *addr;
+    size_t       size;
+    ngx_str_t    name;
+    ngx_log_t   *log;
+    ngx_uint_t   exists;   /* unsigned  exists:1;  */
+} ngx_shm_t;
+
+
+ngx_int_t ngx_shm_alloc(ngx_shm_t *shm);
+void ngx_shm_free(ngx_shm_t *shm);
+
+
+#endif /* _NGX_SHMEM_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_socket.c b/src/os/seng/trusted/ngx_socket.c
new file mode 100644
index 0000000..3bcb7b0
--- /dev/null
+++ b/src/os/seng/trusted/ngx_socket.c
@@ -0,0 +1,116 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+/*
+ * ioctl(FIONBIO) sets a non-blocking mode with the single syscall
+ * while fcntl(F_SETFL, O_NONBLOCK) needs to learn the current state
+ * using fcntl(F_GETFL).
+ *
+ * ioctl() and fcntl() are syscalls at least in FreeBSD 2.x, Linux 2.2
+ * and Solaris 7.
+ *
+ * ioctl() in Linux 2.4 and 2.6 uses BKL, however, fcntl(F_SETFL) uses it too.
+ */
+
+
+#if (NGX_HAVE_FIONBIO)
+
+int
+ngx_nonblocking(ngx_socket_t s)
+{
+    int  nb;
+
+    nb = 1;
+
+    return lwip_ioctl(s, FIONBIO, &nb);
+}
+
+
+int
+ngx_blocking(ngx_socket_t s)
+{
+    int  nb;
+
+    nb = 0;
+
+    return lwip_ioctl(s, FIONBIO, &nb);
+}
+
+#endif
+
+
+#if (NGX_FREEBSD)
+
+int
+ngx_tcp_nopush(ngx_socket_t s)
+{
+    int  tcp_nopush;
+
+    tcp_nopush = 1;
+
+    return setsockopt(s, IPPROTO_TCP, TCP_NOPUSH,
+                      (const void *) &tcp_nopush, sizeof(int));
+}
+
+
+int
+ngx_tcp_push(ngx_socket_t s)
+{
+    int  tcp_nopush;
+
+    tcp_nopush = 0;
+
+    return setsockopt(s, IPPROTO_TCP, TCP_NOPUSH,
+                      (const void *) &tcp_nopush, sizeof(int));
+}
+
+#elif (NGX_LINUX)
+
+
+int
+ngx_tcp_nopush(ngx_socket_t s)
+{
+    int  cork;
+
+    cork = 1;
+
+    return setsockopt(s, IPPROTO_TCP, TCP_CORK,
+                      (const void *) &cork, sizeof(int));
+}
+
+
+int
+ngx_tcp_push(ngx_socket_t s)
+{
+    int  cork;
+
+    cork = 0;
+
+    return setsockopt(s, IPPROTO_TCP, TCP_CORK,
+                      (const void *) &cork, sizeof(int));
+}
+
+#else
+
+int
+ngx_tcp_nopush(ngx_socket_t s)
+{
+    return 0;
+}
+
+
+int
+ngx_tcp_push(ngx_socket_t s)
+{
+    return 0;
+}
+
+#endif
diff --git a/src/os/seng/trusted/ngx_socket.h b/src/os/seng/trusted/ngx_socket.h
new file mode 100644
index 0000000..c3412e2
--- /dev/null
+++ b/src/os/seng/trusted/ngx_socket.h
@@ -0,0 +1,45 @@
+#ifndef _NGX_SOCKET_H_INCLUDED_
+#define _NGX_SOCKET_H_INCLUDED_
+
+
+#include <ngx_config.h>
+
+
+#define NGX_WRITE_SHUTDOWN SHUT_WR
+
+typedef int  ngx_socket_t;
+
+#define ngx_socket          seng_socket
+#define ngx_socket_n        "socket()"
+
+
+int ngx_nonblocking(ngx_socket_t s);
+int ngx_blocking(ngx_socket_t s);
+
+#define ngx_nonblocking_n   "ioctl(FIONBIO)"
+#define ngx_blocking_n      "ioctl(!FIONBIO)"
+
+int ngx_tcp_nopush(ngx_socket_t s);
+int ngx_tcp_push(ngx_socket_t s);
+
+#if (NGX_LINUX)
+
+#define ngx_tcp_nopush_n   "setsockopt(TCP_CORK)"
+#define ngx_tcp_push_n     "setsockopt(!TCP_CORK)"
+
+#else
+
+#define ngx_tcp_nopush_n   "setsockopt(TCP_NOPUSH)"
+#define ngx_tcp_push_n     "setsockopt(!TCP_NOPUSH)"
+
+#endif
+
+
+#define ngx_shutdown_socket    seng_shutdown
+#define ngx_shutdown_socket_n  "shutdown()"
+
+#define ngx_close_socket    seng_close
+#define ngx_close_socket_n  "close() socket"
+
+
+#endif /* _NGX_SOCKET_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_sys_wrappers.edl b/src/os/seng/trusted/ngx_sys_wrappers.edl
new file mode 100644
index 0000000..01ba222
--- /dev/null
+++ b/src/os/seng/trusted/ngx_sys_wrappers.edl
@@ -0,0 +1,89 @@
+enclave {
+    #include "ocall_defs.h"
+
+    untrusted {
+        /* TIME */
+        //struct tm *ocall_localtime([in] const time_t *timep);
+        struct seng_tm *ocall_localtime([in] const long int *timep) propagate_errno transition_using_threads;
+        unsigned int ocall_sleep(unsigned int seconds);
+        int ocall_usleep(unsigned int usec) propagate_errno;
+
+        long int ocall_mktime([out] struct seng_tm *tm) propagate_errno transition_using_threads;
+        // TODO: sgxssl actually already has it!
+        int ocall_gettimeofday_no_zone([out] struct seng_timeval *tv) propagate_errno transition_using_threads;
+
+
+        /* FILES */
+        int ocall_file_open([in, string] const char *pathname, int flags, unsigned int mode) propagate_errno transition_using_threads;
+        int ocall_file_close(int fd) propagate_errno transition_using_threads;
+        long ocall_file_read(int fd, [out, size=count] void *buf, size_t count) propagate_errno transition_using_threads;
+        long ocall_file_write(int fd, [in, size=count] const void *buf, size_t count) propagate_errno transition_using_threads;
+
+        int ocall_unlink([in, string] const char *pathname) propagate_errno;
+        int ocall_rename([in, string] const char *oldpath, [in, string] const char *newpath) propagate_errno;
+        int ocall_chmod([in, string] const char *pathname, unsigned int mode) propagate_errno;
+        int ocall_utimes([in, string] const char *filename, [in, count=2] const struct seng_timeval *times) propagate_errno;
+
+        char *ocall_realpath([in, string] const char *path, [in, out, string] char *resolved_path) propagate_errno;
+        char *ocall_getcwd([out, size=len] char *buf, size_t len) propagate_errno;
+
+        int ocall_dup2(int oldfd, int newfd) propagate_errno;
+
+        long int ocall_lseek(int fd, long int offset, int whence) propagate_errno;
+
+        // writev -- nested pointers
+        long ocall_file_writev(int fd, [user_check] const struct seng_iovec *iov, int iovcnt) propagate_errno;
+
+        // stat, fstat, lstat
+        int ocall_stat([in, string] const char *pathname, [out] struct seng_stat_t *statbuf) propagate_errno transition_using_threads;
+        int ocall_fstat(int fd, [out] struct seng_stat_t *statbuf) propagate_errno transition_using_threads;
+        int ocall_lstat([in, string]const char *pathname, [out] struct seng_stat_t *statbuf) propagate_errno transition_using_threads;
+
+        // opaque return pointer, so no copying required
+        void *ocall_opendir([in, string] const char *name) propagate_errno;
+        // opaqure argument pointer, so no copying required
+        int ocall_closedir([user_check] void *dirp) propagate_errno;
+        int ocall_mkdir([in, string] const char *pathname, unsigned int mode) propagate_errno;
+        int ocall_rmdir([in, string] const char *pathname) propagate_errno;
+
+        // readdir
+        struct seng_dirent *ocall_readdir([user_check] void *dirp) propagate_errno;
+
+        // glob, globfree -- TODO: CB function "errfunc" (anyway unused)
+        // PROBLEM: 'glob_t' contains 'char **'
+        // TODO: prop. errno, or not?
+        int ocall_glob([in, string] const char *pattern, [user_check] seng_glob_t *pglob);
+        void ocall_globfree([user_check] seng_glob_t *pglob);
+        // --> user by "ngx_conf_include"
+
+        // fcntl -- TODO: how variable #args?!
+        // int ocall_fcntl(int fd, int cmd, ... );
+        int ocall_file_fcntl3(int fd, int cmd, int arg) propagate_errno;
+        int ocall_file_fcntl2(int fd, int cmd) propagate_errno;
+
+        // PROBLEM?!: struct flock, fcntl(F_SETLK), NOT "flock()"
+        //int ocall_set_flock(int fd, void *flock, size_t flock_len);
+        int ocall_flock_operation(int fd, int cmd, [in] struct seng_flock *flock) propagate_errno;
+
+        /* PROCESS ++ USER/GROUP */
+        unsigned int ocall_getpid(void);
+        unsigned int ocall_geteuid(void);
+        unsigned int ocall_getuid(void);
+
+        // TODO: return pointer handling
+        char * ocall_getenv([in, string] const char *name);
+
+        // TODO: return pointer handling
+        struct seng_passwd *ocall_getpwnam([in, string] const char *name) propagate_errno;
+        struct seng_group *ocall_getgrnam([in, string] const char *name) propagate_errno;
+
+        int ocall_chown([in, string] const char *pathname, unsigned int owner, unsigned int group) propagate_errno;
+
+        int ocall_gethostname([user_check] char *name, size_t len) propagate_errno;
+
+        /* RESOURCE LIMITS */
+        int ocall_getrlimit(int resource, [out] struct seng_rlimit *rlim) propagate_errno;
+    };
+
+    trusted {};
+};
diff --git a/src/os/seng/trusted/ngx_thread.h b/src/os/seng/trusted/ngx_thread.h
new file mode 100644
index 0000000..7a77d32
--- /dev/null
+++ b/src/os/seng/trusted/ngx_thread.h
@@ -0,0 +1,48 @@
+#ifndef _NGX_THREAD_H_INCLUDED_
+#define _NGX_THREAD_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+#if (NGX_THREADS)
+
+#include <sgx_thread.h>
+#include <sgx_spinlock.h>
+
+typedef sgx_thread_mutex_t  ngx_thread_mutex_t;
+
+ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log);
+ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log);
+ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log);
+ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log);
+
+
+typedef sgx_thread_cond_t  ngx_thread_cond_t;
+
+ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log);
+ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log);
+ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log);
+ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,
+    ngx_log_t *log);
+
+
+//TODO: typedef uint64_t   ngx_tid_t;
+// TODO: trusted thread ID, not untrusted one
+typedef sgx_thread_t ngx_tid_t;
+#define NGX_TID_T_FMT         "%uA"
+
+ngx_tid_t ngx_thread_tid(void);
+
+#define ngx_log_tid           ngx_thread_tid()
+
+#else
+
+#define ngx_log_tid           0
+#define NGX_TID_T_FMT         "%d"
+
+#endif
+
+
+#endif /* _NGX_THREAD_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_thread_cond.c b/src/os/seng/trusted/ngx_thread_cond.c
new file mode 100644
index 0000000..c183c6d
--- /dev/null
+++ b/src/os/seng/trusted/ngx_thread_cond.c
@@ -0,0 +1,87 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+ngx_int_t
+ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    err = sgx_thread_cond_init(cond, NULL);
+    if (err == 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                       "sgx_thread_cond_init(%p)", cond);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_EMERG, log, err, "sgx_thread_cond_init() failed");
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    err = sgx_thread_cond_destroy(cond);
+    if (err == 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                       "sgx_thread_cond_destroy(%p)", cond);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_EMERG, log, err, "sgx_thread_cond_destroy() failed");
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    err = sgx_thread_cond_signal(cond);
+    if (err == 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                       "sgx_thread_cond_signal(%p)", cond);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_EMERG, log, err, "sgx_thread_cond_signal() failed");
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,
+    ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                   "sgx_thread_cond_wait(%p) enter", cond);
+
+    err = sgx_thread_cond_wait(cond, mtx);
+
+#if 0
+    ngx_time_update();
+#endif
+
+    if (err == 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                       "sgx_thread_cond_wait(%p) exit", cond);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_ALERT, log, err, "sgx_thread_cond_wait() failed");
+
+    return NGX_ERROR;
+}
diff --git a/src/os/seng/trusted/ngx_thread_id.c b/src/os/seng/trusted/ngx_thread_id.c
new file mode 100644
index 0000000..435464c
--- /dev/null
+++ b/src/os/seng/trusted/ngx_thread_id.c
@@ -0,0 +1,10 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_thread_pool.h>
+
+
+ngx_tid_t
+ngx_thread_tid(void)
+{
+    return sgx_thread_self();
+}
diff --git a/src/os/seng/trusted/ngx_thread_mutex.c b/src/os/seng/trusted/ngx_thread_mutex.c
new file mode 100644
index 0000000..99ed079
--- /dev/null
+++ b/src/os/seng/trusted/ngx_thread_mutex.c
@@ -0,0 +1,82 @@
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+ngx_int_t
+ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)
+{
+    ngx_err_t            err;
+    // TODO: this is just a dummy in SGX SDK
+    sgx_thread_mutexattr_t  attr {};
+
+    err = sgx_thread_mutex_init(mtx, &attr);
+    if (err != 0) {
+        ngx_log_error(NGX_LOG_EMERG, log, err,
+                      "sgx_thread_mutex_init() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                   "sgx_thread_mutex_init(%p)", mtx);
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    err = sgx_thread_mutex_destroy(mtx);
+    if (err != 0) {
+        ngx_log_error(NGX_LOG_ALERT, log, err,
+                      "sgx_thread_mutex_destroy() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                   "sgx_thread_mutex_destroy(%p)", mtx);
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                   "sgx_thread_mutex_lock(%p) enter", mtx);
+
+    err = sgx_thread_mutex_lock(mtx);
+    if (err == 0) {
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_ALERT, log, err, "sgx_thread_mutex_lock() failed");
+
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log)
+{
+    ngx_err_t  err;
+
+    err = sgx_thread_mutex_unlock(mtx);
+
+#if 0
+    ngx_time_update();
+#endif
+
+    if (err == 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0,
+                       "sgx_thread_mutex_unlock(%p) exit", mtx);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_ALERT, log, err, "sgx_thread_mutex_unlock() failed");
+
+    return NGX_ERROR;
+}
diff --git a/src/os/seng/trusted/ngx_user.c b/src/os/seng/trusted/ngx_user.c
new file mode 100644
index 0000000..27c76ef
--- /dev/null
+++ b/src/os/seng/trusted/ngx_user.c
@@ -0,0 +1,90 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+/*
+ * Solaris has thread-safe crypt()
+ * Linux has crypt_r(); "struct crypt_data" is more than 128K
+ * FreeBSD needs the mutex to protect crypt()
+ *
+ * TODO:
+ *     ngx_crypt_init() to init mutex
+ */
+
+
+#if (NGX_CRYPT)
+
+#if (NGX_HAVE_GNU_CRYPT_R)
+
+ngx_int_t
+ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)
+{
+    char               *value;
+    size_t              len;
+    struct crypt_data   cd;
+
+    cd.initialized = 0;
+#ifdef __GLIBC__
+    /* work around the glibc bug */
+    cd.current_salt[0] = ~salt[0];
+#endif
+
+    value = crypt_r((char *) key, (char *) salt, &cd);
+
+    if (value) {
+        len = ngx_strlen(value) + 1;
+
+        *encrypted = ngx_pnalloc(pool, len);
+        if (*encrypted == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(*encrypted, value, len);
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_CRIT, pool->log, ngx_errno, "crypt_r() failed");
+
+    return NGX_ERROR;
+}
+
+#else
+
+ngx_int_t
+ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)
+{
+    char       *value;
+    size_t      len;
+    ngx_err_t   err;
+
+    value = crypt((char *) key, (char *) salt);
+
+    if (value) {
+        len = ngx_strlen(value) + 1;
+
+        *encrypted = ngx_pnalloc(pool, len);
+        if (*encrypted == NULL) {
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(*encrypted, value, len);
+        return NGX_OK;
+    }
+
+    err = ngx_errno;
+
+    ngx_log_error(NGX_LOG_CRIT, pool->log, err, "crypt() failed");
+
+    return NGX_ERROR;
+}
+
+#endif
+
+#endif /* NGX_CRYPT */
diff --git a/src/os/seng/trusted/ngx_user.h b/src/os/seng/trusted/ngx_user.h
new file mode 100644
index 0000000..6e82204
--- /dev/null
+++ b/src/os/seng/trusted/ngx_user.h
@@ -0,0 +1,24 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_USER_H_INCLUDED_
+#define _NGX_USER_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+typedef uid_t  ngx_uid_t;
+typedef gid_t  ngx_gid_t;
+
+
+ngx_int_t ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,
+    u_char **encrypted);
+
+
+#endif /* _NGX_USER_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/ngx_writev_chain.c b/src/os/seng/trusted/ngx_writev_chain.c
new file mode 100644
index 0000000..96889bc
--- /dev/null
+++ b/src/os/seng/trusted/ngx_writev_chain.c
@@ -0,0 +1,216 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+
+ngx_chain_t *
+ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
+{
+    ssize_t        n, sent;
+    off_t          send, prev_send;
+    ngx_chain_t   *cl;
+    ngx_event_t   *wev;
+    ngx_iovec_t    vec;
+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];
+
+    wev = c->write;
+
+    if (!wev->ready) {
+        return in;
+    }
+
+#if (NGX_HAVE_KQUEUE)
+
+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {
+        (void) ngx_connection_error(c, wev->kq_errno,
+                               "kevent() reported about an closed connection");
+        wev->error = 1;
+        return NGX_CHAIN_ERROR;
+    }
+
+#endif
+
+    /* the maximum limit size is the maximum size_t value - the page size */
+
+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {
+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;
+    }
+
+    send = 0;
+
+    vec.iovs = iovs;
+    vec.nalloc = NGX_IOVS_PREALLOCATE;
+
+    for ( ;; ) {
+        prev_send = send;
+
+        /* create the iovec and coalesce the neighbouring bufs */
+
+        cl = ngx_output_chain_to_iovec(&vec, in, limit - send, c->log);
+
+        if (cl == NGX_CHAIN_ERROR) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        if (cl && cl->buf->in_file) {
+            ngx_log_error(NGX_LOG_ALERT, c->log, 0,
+                          "file buf in writev "
+                          "t:%d r:%d f:%d %p %p-%p %p %O-%O",
+                          cl->buf->temporary,
+                          cl->buf->recycled,
+                          cl->buf->in_file,
+                          cl->buf->start,
+                          cl->buf->pos,
+                          cl->buf->last,
+                          cl->buf->file,
+                          cl->buf->file_pos,
+                          cl->buf->file_last);
+
+            ngx_debug_point();
+
+            return NGX_CHAIN_ERROR;
+        }
+
+        send += vec.size;
+
+        n = ngx_writev(c, &vec);
+
+        if (n == NGX_ERROR) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        sent = (n == NGX_AGAIN) ? 0 : n;
+
+        c->sent += sent;
+
+        in = ngx_chain_update_sent(in, sent);
+
+        if (send - prev_send != sent) {
+            wev->ready = 0;
+            return in;
+        }
+
+        if (send >= limit || in == NULL) {
+            return in;
+        }
+    }
+}
+
+
+ngx_chain_t *
+ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,
+    ngx_log_t *log)
+{
+    size_t         total, size;
+    u_char        *prev;
+    ngx_uint_t     n;
+    struct iovec  *iov;
+
+    iov = NULL;
+    prev = NULL;
+    total = 0;
+    n = 0;
+
+    for ( /* void */ ; in && total < limit; in = in->next) {
+
+        if (ngx_buf_special(in->buf)) {
+            continue;
+        }
+
+        if (in->buf->in_file) {
+            break;
+        }
+
+        if (!ngx_buf_in_memory(in->buf)) {
+            ngx_log_error(NGX_LOG_ALERT, log, 0,
+                          "bad buf in output chain "
+                          "t:%d r:%d f:%d %p %p-%p %p %O-%O",
+                          in->buf->temporary,
+                          in->buf->recycled,
+                          in->buf->in_file,
+                          in->buf->start,
+                          in->buf->pos,
+                          in->buf->last,
+                          in->buf->file,
+                          in->buf->file_pos,
+                          in->buf->file_last);
+
+            ngx_debug_point();
+
+            return NGX_CHAIN_ERROR;
+        }
+
+        size = in->buf->last - in->buf->pos;
+
+        if (size > limit - total) {
+            size = limit - total;
+        }
+
+        if (prev == in->buf->pos) {
+            iov->iov_len += size;
+
+        } else {
+            if (n == vec->nalloc) {
+                break;
+            }
+
+            iov = &vec->iovs[n++];
+
+            iov->iov_base = (void *) in->buf->pos;
+            iov->iov_len = size;
+        }
+
+        prev = in->buf->pos + size;
+        total += size;
+    }
+
+    vec->count = n;
+    vec->size = total;
+
+    return in;
+}
+
+
+ssize_t
+ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec)
+{
+    ssize_t    n;
+    ngx_err_t  err;
+
+eintr:
+
+    n = seng_writev(c->fd, vec->iovs, vec->count);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "writev: %z of %uz", n, vec->size);
+
+    if (n == -1) {
+        err = ngx_errno;
+
+        switch (err) {
+        case NGX_EAGAIN:
+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
+                           "writev() not ready");
+            return NGX_AGAIN;
+
+        case NGX_EINTR:
+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,
+                           "writev() was interrupted");
+            goto eintr;
+
+        default:
+            c->write->error = 1;
+            ngx_connection_error(c, err, "writev() failed");
+            return NGX_ERROR;
+        }
+    }
+
+    return n;
+}
diff --git a/src/os/seng/trusted/ocall_defs.h b/src/os/seng/trusted/ocall_defs.h
new file mode 100644
index 0000000..5808d95
--- /dev/null
+++ b/src/os/seng/trusted/ocall_defs.h
@@ -0,0 +1,115 @@
+#ifndef _SENG_OCALL_DEFS_H_INCLUDED_
+#define _SENG_OCALL_DEFS_H_INCLUDED_
+
+
+struct seng_tm
+{
+  int tm_sec;
+  int tm_min;
+  int tm_hour;
+  int tm_mday;
+  int tm_mon;
+  int tm_year;
+  int tm_wday;
+  int tm_yday;
+  int tm_isdst;
+
+  long int tm_gmtoff;
+  char *tm_zone; // const
+};
+
+struct seng_timeval {
+  long int  tv_sec;         /* seconds */
+  long      tv_usec;        /* and microseconds */
+};
+
+struct seng_stat_t {
+    unsigned long int st_dev;		/* Device.  */
+    unsigned long int st_ino;		/* File serial number.	*/
+    unsigned long int st_nlink;		/* Link count.  */
+    unsigned int st_mode;		/* File mode.  */
+    unsigned int st_uid;		/* User ID of the file's owner.	*/
+    unsigned int st_gid;		/* Group ID of the file's group.*/
+    int __pad0;
+    unsigned long int st_rdev;		/* Device number, if device.  */
+    long int st_size;			/* Size of file, in bytes.  */
+    long int st_blksize;	/* Optimal block size for I/O.  */
+    long int st_blocks;		/* Number 512-byte blocks allocated. */
+    long int st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    long int st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    long int st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+    long int __glibc_reserved[3];
+};
+
+
+struct seng_dirent {
+  unsigned long int d_ino;
+  long int d_off;
+  unsigned short int d_reclen;
+  unsigned char d_type;
+  char d_name[256];       /* We must not include limits.h! */
+};
+
+
+struct seng_glob_t {
+    size_t gl_pathc;		/* Count of paths matched by the pattern.  */
+    char **gl_pathv;		/* List of matched pathnames.  */
+    size_t gl_offs;		/* Slots to reserve in `gl_pathv'.  */
+    int gl_flags;		/* Set to FLAGS, maybe | GLOB_MAGCHAR.  */
+
+    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
+       are used instead of the normal file access functions.  */
+    void *gl_closedir;
+    void *gl_readdir;
+    void *gl_opendir;
+    void *gl_lstat;
+    void *gl_stat;
+};
+
+struct seng_passwd {
+  char *pw_name;        /* Username.  */
+  char *pw_passwd;      /* Password.  */
+  unsigned int pw_uid;       /* User ID.  */
+  unsigned int pw_gid;       /* Group ID.  */
+  char *pw_gecos;       /* Real name.  */
+  char *pw_dir;         /* Home directory.  */
+  char *pw_shell;       /* Shell program.  */
+ };
+
+struct seng_group {
+  char *gr_name;      /* Group name.  */
+  char *gr_passwd;        /* Password.    */
+  unsigned int gr_gid;     /* Group ID.    */
+  char **gr_mem;      /* Member list. */
+};
+
+// todo: wrong member type?
+struct seng_rlimit {
+  unsigned long int rlim_cur;  /* Soft limit */
+  unsigned long int rlim_max;  /* Hard limit (ceiling for rlim_cur) */
+};
+
+struct seng_flock {
+  short l_type;
+  short l_whence;
+  long  l_start;
+  long  l_len;
+  int   l_pid;
+};
+
+struct seng_iovec {
+  void *iov_base;
+  unsigned long iov_len;
+};
+
+struct seng_ngx_sigatomics {
+  int *uptr_quit;
+  int *uptr_terminate;
+  int *uptr_reconfigure;
+  int *uptr_reopen;
+};
+
+#endif /* _SENG_OCALL_DEFS_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/seng_misc_funcs.c b/src/os/seng/trusted/seng_misc_funcs.c
new file mode 100644
index 0000000..0caf263
--- /dev/null
+++ b/src/os/seng/trusted/seng_misc_funcs.c
@@ -0,0 +1,28 @@
+#include "ngx_seng_config.h"
+
+#include <sgx_trts.h> // sgx_read_rand
+
+#define CHECK_POLL
+
+long int seng_random(void) {
+    unsigned char buf[64];
+    if (sizeof(long int) != sizeof(buf)/8) abort();
+    if (sgx_read_rand(buf, 8) != SGX_SUCCESS) abort();
+    return *((long int *)buf);
+}
+
+// no seed required
+void seng_srandom(unsigned int seed) {}
+
+#ifdef CHECK_POLL
+int seng_checked_poll(struct pollfd *fds, nfds_t nfds, int timeout) {
+    if (fds && nfds > 0) {
+        for (unsigned int i = 0; i < nfds; i++) {
+            if (fds[i].fd < LWIP_SOCKET_OFFSET) abort();
+        }
+    }
+#else
+inline int seng_checked_poll(struct pollfd *fds, nfds_t nfds, int timeout) {
+#endif
+    return seng_poll(fds, nfds, timeout);
+}
diff --git a/src/os/seng/trusted/t_ngx_files.c b/src/os/seng/trusted/t_ngx_files.c
new file mode 100644
index 0000000..b399494
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_files.c
@@ -0,0 +1,306 @@
+#include "t_ngx_files.h"
+
+#include <sgx_trts.h> // sgx_is_outside_enclave
+#include <string.h> // memcpy
+
+#include <sgx_edger8r.h> // sgx_ocalloc()
+
+
+int seng_file_open(const char *pathname, int flags, unsigned int mode) {
+    int ret = -1;
+    ocall_file_open(&ret, pathname, flags, mode);
+    return ret;
+}
+int seng_file_close(int fd) {
+    int ret = -1;
+    ocall_file_close(&ret, fd);
+    return ret;
+}
+ssize_t seng_file_read(int fd, void *buf, size_t count) {
+    ssize_t ret = -1;
+    ocall_file_read(&ret, fd, buf, count);
+    return ret;
+}
+ssize_t seng_file_write(int fd, const void *buf, size_t count) {
+    ssize_t ret = -1;
+    ocall_file_write(&ret, fd, buf, count);
+    return ret;
+}
+
+int seng_unlink(const char *pathname) {
+    int ret = -1;
+    ocall_unlink(&ret, pathname);
+    return ret;
+}
+int seng_rename(const char *oldpath, const char *newpath) {
+    int ret = -1;
+    ocall_rename(&ret, oldpath, newpath);
+    return ret;
+}
+int seng_chmod(const char *pathname, unsigned int mode) {
+    int ret = -1;
+    ocall_chmod(&ret, pathname, mode);
+    return ret;
+}
+int seng_utimes(const char *filename, const struct timeval times[2]) {
+    int ret = -1;
+    ocall_utimes(&ret, filename, (const struct seng_timeval *) times);
+    return ret;
+}
+
+char *seng_realpath(const char *path, char *resolved_path) {
+    char *ret = NULL;
+    ocall_realpath(&ret, path, resolved_path);
+    int err = errno;
+    if (ret == NULL) return NULL;
+
+    // If resolved_path != NULL, return ptr to trusted[!] buffer
+    if (resolved_path != NULL) return resolved_path;
+//  NOTE: following check prob. always fails, bcs. I guess 'ret' would point to tmp untrusted buffer
+//        if (ret != resolved_path) abort;
+
+    // No resolved_path, i.e. realpath used malloc() @ OCALL
+    // get untrusted string length ++ check range
+    size_t u_res_len = strlen(ret);
+    if (! sgx_is_outside_enclave(ret, u_res_len)) {
+        abort();
+    }
+
+    // allocate trusted memory, and explicitly null-terminate
+    char *result_path = malloc(u_res_len + 1);
+    if (result_path == NULL) return NULL;
+    result_path[u_res_len] = '\0';
+
+    // copy untrusted string w/o null-byte
+    memcpy(result_path, ret, u_res_len);
+    errno = err;
+    return result_path;
+}
+char *seng_getcwd(char *buf, size_t size) {
+    char *ret = NULL;
+    ocall_getcwd(&ret, buf, size);
+    int err = errno;
+    if (ret == NULL) return NULL;
+
+    // If buf != NULL, uses that buffer
+    if (buf != NULL) return buf;
+
+    // If buf == NULL, uses malloc(size) if size!=0, else fitting len
+    size_t u_res_len = (size != 0) ? (size - 1) : strlen(ret);
+    if (! sgx_is_outside_enclave(ret, u_res_len)) {
+        abort();
+    }
+
+    // allocate trusted memory, and explicitly null-terminate
+    char *result_cwd = malloc(u_res_len + 1);
+    if (result_cwd == NULL) return NULL;
+    result_cwd[u_res_len] = '\0';
+
+    // copy untrusted string w/o null-byte
+    memcpy(result_cwd, ret, u_res_len);
+    errno = err;
+    return result_cwd;
+}
+
+int seng_dup2(int oldfd, int newfd) {
+    int ret = -1;
+    ocall_dup2(&ret, oldfd, newfd);
+    return ret;
+}
+
+long int seng_lseek(int fd, long int offset, int whence) {
+    long int ret = -1;
+    ocall_lseek(&ret, fd, offset, whence);
+    return ret;
+}
+
+// writev -- nested pointers (iovec --> lwIP, seng_iovec --> ecall def)
+ssize_t seng_file_writev(int fd, const struct iovec *iov, int iovcnt) {
+    struct seng_iovec *__tmp_iov = NULL;
+    if (iov && iovcnt > 0) {
+        __tmp_iov = (struct seng_iovec *) sgx_ocalloc(iovcnt * sizeof(struct seng_iovec));
+        if (!__tmp_iov) abort();
+        // copy buffers
+        for (int i=0; i<iovcnt; i++) {
+            struct seng_iovec *__entry = &__tmp_iov[i];
+            __entry->iov_base = sgx_ocalloc(iov[i].iov_len);
+            if (!__entry->iov_base) abort();
+            memcpy(__entry->iov_base, iov[i].iov_base, iov[i].iov_len);
+            __entry->iov_len = iov[i].iov_len;
+        }
+    }
+
+    ssize_t ret = -1;
+    ocall_file_writev(&ret, fd, __tmp_iov, iovcnt);
+    sgx_ocfree(); // TODO: problem if no previous sgx_ocalloc() ?
+    return ret;
+}
+
+int seng_stat(const char *pathname, struct seng_stat_t *statbuf) {
+    int ret = 1;
+    ocall_stat(&ret, pathname, statbuf);
+    return ret;
+}
+int seng_fstat(int fd, struct seng_stat_t *statbuf) {
+    int ret = -1;
+    ocall_fstat(&ret, fd, statbuf);
+    return ret;
+}
+int seng_lstat(const char *pathname, struct seng_stat_t *statbuf) {
+    int ret = -1;
+    ocall_lstat(&ret, pathname, statbuf);
+    return ret;
+}
+
+DIR *seng_opendir(const char *name) {
+    void *ret = NULL;
+    ocall_opendir(&ret, name);
+
+    // TODO: cannot really check bcs. data len is opaque;
+    //      but it's anyway not meant to be dereferenced!
+    if (ret && ! sgx_is_outside_enclave(ret, 1)) abort();
+
+    return ret; // [user_check] / opaque handle
+}
+int seng_closedir(DIR *dirp) {
+    int ret = -1;
+//    if (dirp && ! sgx_is_outside_enclave(dirp, 1)) abort();
+    ocall_closedir(&ret, dirp);
+    return ret;
+}
+int seng_mkdir(const char *pathname, unsigned int mode) {
+    int ret = -1;
+    ocall_mkdir(&ret, pathname, mode);
+    return ret;
+}
+int seng_rmdir(const char *pathname) {
+    int ret = -1;
+    ocall_rmdir(&ret, pathname);
+    return ret;
+}
+
+
+struct seng_dirent *seng_readdir(void *dirp) {
+    // static memory
+    static struct seng_dirent ret_entry = {};
+
+    struct seng_dirent *ret = NULL;
+    ocall_readdir(&ret, dirp);
+    if (!ret) return NULL;
+
+    size_t res_len = sizeof(ret_entry);
+    if (!sgx_is_outside_enclave(ret, res_len)) {
+        abort();
+    }
+    memcpy(&ret_entry, ret, res_len);
+    return &ret_entry;
+}
+
+
+int seng_glob(const char *pattern, seng_glob_t *pglob) {
+    seng_glob_t *__tmp_pglob = NULL;
+    if (pglob != NULL) {
+        __tmp_pglob = (seng_glob_t *) sgx_ocalloc(sizeof(seng_glob_t));
+        if (__tmp_pglob == NULL) {
+            sgx_ocfree(); // TODO: call on eror of sgx_ocalloc?! && prev. not alloced?!
+            return GLOB_NOSPACE;
+        }
+    }
+
+    int ret = -1;
+    ocall_glob(&ret, pattern, __tmp_pglob);
+    int err = errno;
+    // if suddenly null or pointing into enclave, something is wrong
+    // TODO: should not be required, because WE allocated that buffer!!
+    if (__tmp_pglob && !sgx_is_outside_enclave(__tmp_pglob, sizeof(seng_glob_t))) {
+        abort();
+    }
+
+    // Copy the result ptr array and recursively the pattern matches 
+    if (__tmp_pglob) {
+        pglob->gl_pathc = __tmp_pglob->gl_pathc;
+        pglob->gl_flags = __tmp_pglob->gl_flags;
+
+        // results have to be copied
+        if (pglob->gl_pathc > 0) {
+            // copy array ptr into enclave
+            char **__res_array = __tmp_pglob->gl_pathv;
+
+            // check that result pattern set array exists and is outside enclave
+            if (!__res_array || !sgx_is_outside_enclave(__res_array, pglob->gl_pathc + 1)) {
+                    abort();
+            }
+            
+            // allocate result pattern set array
+            pglob->gl_pathv = (char **) malloc(sizeof(char *) * pglob->gl_pathc+1);
+            if (pglob->gl_pathv == NULL) {
+                abort();
+            }
+
+            // copy
+            memcpy(pglob->gl_pathv, __res_array, sizeof(char *) * pglob->gl_pathc + 1);
+
+            // Recursive checking and copying of result patterns
+            for (unsigned int i = 0; i < pglob->gl_pathc; i++) {
+                // exists
+                if (!pglob->gl_pathv[i]) abort();
+
+                // save length inside enclave
+                size_t __ptrn_len = strlen(pglob->gl_pathv[i]);
+
+                // check string outside enclave
+                if (!sgx_is_outside_enclave(pglob->gl_pathv[i], __ptrn_len)) abort();
+
+                // alloc for pattern + null-byte
+                char *__ptrn = malloc(__ptrn_len + 1);
+                if (!__ptrn) abort();
+
+                // copy and terminate pattern, update pointer
+                memcpy(__ptrn, pglob->gl_pathv[i], __ptrn_len);
+                __ptrn[__ptrn_len] = '\0';
+                pglob->gl_pathv[i] = __ptrn;
+            }
+
+            // According to man page, array should terminate will 0-ptr
+            pglob->gl_pathv[pglob->gl_pathc] = NULL;
+        }
+    }
+
+    // Free the pglob memory outside enclave
+    ocall_globfree(__tmp_pglob);
+
+    // Free tmp memory
+    sgx_ocfree();
+    errno = err;
+    return ret;
+}
+
+void seng_globfree(seng_glob_t *pglob) {
+    // TODO: store && recover errno?
+    if (!pglob || !pglob->gl_pathv) return;
+    for (unsigned int i=0; i < pglob->gl_pathc; i++) {
+        free(pglob->gl_pathv[i]);
+    }
+    free(pglob->gl_pathv);
+}
+// --> user by "ngx_conf_include"
+
+// fcntl -- TODO: how variable #args?!
+// int seng_fcntl(int fd, int cmd, ... );
+int seng_file_fcntl3(int fd, int cmd, int arg) {
+    int ret = -1;
+    ocall_file_fcntl3(&ret, fd, cmd, arg);
+    return ret;
+}
+
+int seng_file_fcntl2(int fd, int cmd) {
+    int ret = -1;
+    ocall_file_fcntl2(&ret, fd, cmd);
+    return ret;
+}
+
+int seng_flock_operation(int fd, int cmd, struct seng_flock *flock) {
+    int ret = -1;
+    ocall_flock_operation(&ret, fd, cmd, flock);
+    return ret;
+}
diff --git a/src/os/seng/trusted/t_ngx_files.h b/src/os/seng/trusted/t_ngx_files.h
new file mode 100644
index 0000000..3e4a319
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_files.h
@@ -0,0 +1,59 @@
+#ifndef _T_NGX_FILES_H_INCLUDED_
+#define _T_NGX_FILES_H_INCLUDED_
+
+#include "ngx_seng_config.h"
+#include "ngx_seng_t.h"
+
+int seng_file_open(const char *pathname, int flags, unsigned int mode);
+int seng_file_close(int fd);
+ssize_t seng_file_read(int fd, void *buf, size_t count);
+ssize_t seng_file_write(int fd, const void *buf, size_t count);
+
+int seng_unlink(const char *pathname);
+int seng_rename(const char *oldpath, const char *newpath);
+int seng_chmod(const char *pathname, unsigned int mode);
+int seng_utimes(const char *filename, const struct timeval times[2]);
+
+char *seng_realpath(const char *path, char *resolved_path);
+char *seng_getcwd(char *buf, size_t size);
+
+int seng_dup2(int oldfd, int newfd);
+
+long int seng_lseek(int fd, long int offset, int whence);
+
+// writev -- nested pointers
+ssize_t seng_file_writev(int fd, const struct iovec *iov, int iovcnt);
+
+int seng_stat(const char *pathname, struct seng_stat_t *statbuf);
+int seng_fstat(int fd, struct seng_stat_t *statbuf);
+int seng_lstat(const char *pathname, struct seng_stat_t *statbuf);
+
+DIR *seng_opendir(const char *name);
+int seng_closedir(DIR *dirp);
+int seng_mkdir(const char *pathname, unsigned int mode);
+int seng_rmdir(const char *pathname);
+
+// readdir -- TODO: struct dirent
+struct seng_dirent *seng_readdir(void *dirp);
+
+int seng_glob(const char *pattern, seng_glob_t *pglob);
+void seng_globfree(seng_glob_t *pglob);
+// --> user by "ngx_conf_include"
+
+// fcntl -- TODO: how variable #args?!
+// int seng_fcntl(int fd, int cmd, ... );
+int seng_file_fcntl3(int fd, int cmd, int arg);
+int seng_file_fcntl2(int fd, int cmd);
+
+int seng_flock_operation(int fd, int cmd, struct seng_flock *flock);
+
+// optional: openat, fstatat
+// optional: pread
+// optional: pwrite
+// optional: pwritev
+
+// NGX_CREATE_FILE_MAPPING --> WE CAN NOT(!) SUPPORT THAT EASILY !!
+// -> ftruncate, mmap (READ|WRITE, SHARED), munmap
+// ==> disabled http_geo_module -- only current user
+
+#endif /* _T_NGX_FILES_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/t_ngx_process_user.c b/src/os/seng/trusted/t_ngx_process_user.c
new file mode 100644
index 0000000..cddc757
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_process_user.c
@@ -0,0 +1,118 @@
+#include "t_ngx_process_user.h"
+
+#include <sgx_trts.h> // sgx_is_outside_enclave
+#include <string.h> // memcpy
+
+#include <sgx_edger8r.h> // sgx_ocalloc()
+
+#include <errno.h>
+
+unsigned int seng_getpid(void) {
+    unsigned int ret = -1;
+    ocall_getpid(&ret);
+    return ret;
+}
+unsigned int seng_geteuid(void) {
+    unsigned int ret = -1;
+    ocall_geteuid(&ret);
+    return ret;
+}
+unsigned int seng_getuid(void) {
+    unsigned int ret = -1;
+    ocall_getuid(&ret);
+    return ret;
+}
+
+
+char * seng_getenv_copy(const char *name) {
+    char *ret_ptr = NULL;
+    ocall_getenv(&ret_ptr, name);
+    int err = errno;
+    if (!ret_ptr) return NULL;
+
+    // TODO: Return Pointer should actually point into environment!!;
+    //      which is untrusted w/o LibOS!
+
+    size_t env_len = strlen(ret_ptr);
+    if (!sgx_is_outside_enclave(ret_ptr, env_len)) {
+        abort();
+    }
+
+    char *env_copy = malloc(env_len + 1);
+    // TODO
+    if (env_copy == NULL) abort();
+    env_copy[env_len] = '\0';
+    memcpy(env_copy, ret_ptr, env_len);
+
+    errno = err;
+    return env_copy;
+}
+
+
+struct seng_passwd * seng_getpwnam(const char *name) {
+    // static memory
+    static struct seng_passwd ret_val = {};
+
+    struct seng_passwd *ret = NULL;
+    ocall_getpwnam(&ret, name);
+    if (!ret) return NULL;
+
+    size_t val_size = sizeof(ret_val);
+    if (!sgx_is_outside_enclave(ret, val_size)) {
+        abort();
+    }
+    memcpy(&ret_val, ret, val_size);
+    return &ret_val;
+}
+struct seng_group * seng_getgrnam(const char *name) {
+    // static memory
+    static struct seng_group ret_val = {};
+
+    struct seng_group *ret = NULL;
+    ocall_getgrnam(&ret, name);
+    if (!ret) return NULL;
+
+    size_t val_size = sizeof(ret_val);
+    if (!sgx_is_outside_enclave(ret, val_size)) {
+        abort();
+    }
+    memcpy(&ret_val, ret, val_size);
+    return &ret_val;
+}
+
+int seng_chown(const char *pathname, unsigned int owner, unsigned int group) {
+    int ret = -1;
+    ocall_chown(&ret, pathname, owner, group);
+    return ret;
+}
+
+int seng_gethostname(char *name, size_t len) {
+    if (!name) {
+        errno = EFAULT;
+        return -1;
+    }
+    if (len <= 0) {
+        errno = ENAMETOOLONG; // EINVAL
+        return -1;
+    }
+
+    void *__tmp = NULL;
+	__tmp = sgx_ocalloc(len);
+	if (__tmp == NULL) {
+		sgx_ocfree(); // TODO: call on eror of sgx_ocalloc?!
+        errno = EFAULT;
+		return -1;
+	}
+
+    // call with untrusted memory buffer address
+    int ret = -1;
+	ocall_gethostname(&ret, __tmp, len);
+    if (!sgx_is_outside_enclave(__tmp, len-1)) {
+        abort();
+    }
+    memcpy(name, __tmp, len-1);
+    name[len] = '\0';
+
+	sgx_ocfree();
+    return ret;
+}
\ No newline at end of file
diff --git a/src/os/seng/trusted/t_ngx_process_user.h b/src/os/seng/trusted/t_ngx_process_user.h
new file mode 100644
index 0000000..efcf490
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_process_user.h
@@ -0,0 +1,19 @@
+#ifndef _T_NGX_PROC_USER_H_INCLUDED_
+#define _T_NGX_PROC_USER_H_INCLUDED_
+
+#include "ngx_seng_t.h"
+
+unsigned int seng_getpid(void);
+unsigned int seng_geteuid(void);
+unsigned int seng_getuid(void);
+
+char * seng_getenv_copy(const char *name);
+
+struct seng_passwd * seng_getpwnam(const char *name);
+struct seng_group * seng_getgrnam(const char *name);
+
+int seng_chown(const char *pathname, unsigned int owner, unsigned int group);
+
+int seng_gethostname(char *name, size_t len);
+
+#endif /* _T_NGX_PROC_USER_H_INCLUDED_ */
diff --git a/src/os/seng/trusted/t_ngx_rlimit.c b/src/os/seng/trusted/t_ngx_rlimit.c
new file mode 100644
index 0000000..96a9592
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_rlimit.c
@@ -0,0 +1,7 @@
+#include "t_ngx_rlimit.h"
+
+int seng_getrlimit(int resource, struct seng_rlimit *rlim) {
+    int ret = -1;
+    ocall_getrlimit(&ret, resource, rlim);
+    return ret;
+}
\ No newline at end of file
diff --git a/src/os/seng/trusted/t_ngx_rlimit.h b/src/os/seng/trusted/t_ngx_rlimit.h
new file mode 100644
index 0000000..c2aed79
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_rlimit.h
@@ -0,0 +1,8 @@
+#ifndef _T_NGX_RLIMT_H_INCLUDED_
+#define _T_NGX_RLIMT_H_INCLUDED_
+
+#include "ngx_seng_t.h"
+
+int seng_getrlimit(int resource, struct seng_rlimit *rlim);
+
+#endif
diff --git a/src/os/seng/trusted/t_ngx_time.c b/src/os/seng/trusted/t_ngx_time.c
new file mode 100644
index 0000000..b6fbdb6
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_time.c
@@ -0,0 +1,51 @@
+#include "t_ngx_time.h"
+
+#include <sgx_trts.h> // sgx_is_outside_enclave
+#include <string.h> // memcpy
+
+#include <errno.h>
+
+// TODO: add assert(sizeof(struct seng_tm) == sizeof(struct tm)),
+//      where "struct tm" is taken from <time.h> of sgx sdk tlibc
+struct seng_tm *seng_localtime(const long int *timep) {
+    // Static memory for return value
+    static struct seng_tm result_tm;
+
+    struct seng_tm *ret = NULL;
+    ocall_localtime(&ret, timep);
+
+    if (ret == NULL) return ret;
+    // Check that return pointer points outside enclave ++ copy
+    if (! sgx_is_outside_enclave(ret, sizeof(result_tm))) {
+        abort();
+    }
+    memcpy(&result_tm, ret, sizeof(result_tm));
+    return &result_tm;
+}
+unsigned int seng_sleep(unsigned int seconds) {
+    unsigned int ret = -1;
+    ocall_sleep(&ret, seconds);
+    return ret;
+}
+int seng_usleep(unsigned int usec) {
+    int ret = -1;
+    ocall_usleep(&ret, usec);
+    return ret;
+}
+
+long int seng_mktime(struct seng_tm *tm) {
+    long int ret = -1;
+    ocall_mktime(&ret, tm);
+    return ret;
+}
+
+int seng_gettimeofday(struct seng_timeval *tv, void *zone) {
+    if (zone) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    int ret = -1;
+    ocall_gettimeofday_no_zone(&ret, tv);
+    return ret;
+}
\ No newline at end of file
diff --git a/src/os/seng/trusted/t_ngx_time.h b/src/os/seng/trusted/t_ngx_time.h
new file mode 100644
index 0000000..5f2584b
--- /dev/null
+++ b/src/os/seng/trusted/t_ngx_time.h
@@ -0,0 +1,17 @@
+#ifndef _T_NGX_TIME_H_INCLUDED_
+#define _T_NGX_TIME_H_INCLUDED_
+
+//TODO:
+//#include <time.h> // timeval
+//#include <tdefines.h> // sgxssl: time_t ++ struct tm
+
+#include "ngx_seng_t.h"
+
+struct seng_tm *seng_localtime(const long int *timep);
+unsigned int seng_sleep(unsigned int seconds);
+int seng_usleep(unsigned int usec);
+
+long int seng_mktime(struct seng_tm *tm);
+int seng_gettimeofday(struct seng_timeval *tv, void *unused_zone);
+
+#endif /* _T_NGX_TIME_H_INCLUDED_ */
diff --git a/src/os/seng/untrusted/nginx/enclave_load.c b/src/os/seng/untrusted/nginx/enclave_load.c
new file mode 100644
index 0000000..e3d91f5
--- /dev/null
+++ b/src/os/seng/untrusted/nginx/enclave_load.c
@@ -0,0 +1,415 @@
+#include "enclave_load.h"
+
+#include <stdio.h>
+#include <stdlib.h> // malloc
+#include <string.h>
+#include <unistd.h>
+#include <pwd.h>
+
+#include <sched.h>
+#include <stdatomic.h>
+#include <assert.h>
+
+#include <sgx_urts.h>
+#include <sgx_uswitchless.h>
+
+# define MAX_PATH FILENAME_MAX
+
+//#define DEBUG_ENC_LOAD
+
+/* Global EID shared by multiple threads */
+sgx_enclave_id_t global_eid = 0;
+
+typedef struct _sgx_errlist_t {
+    sgx_status_t err;
+    const char *msg;
+    const char *sug; /* Suggestion */
+} sgx_errlist_t;
+
+/* Error code returned by sgx_create_enclave */
+static sgx_errlist_t sgx_errlist[] = {
+    {
+        SGX_ERROR_UNEXPECTED,
+        "Unexpected error occurred.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_PARAMETER,
+        "Invalid parameter.",
+        NULL
+    },
+    {
+        SGX_ERROR_OUT_OF_MEMORY,
+        "Out of memory.",
+        NULL
+    },
+    {
+        SGX_ERROR_ENCLAVE_LOST,
+        "Power transition occurred.",
+        "Please refer to the sample \"PowerTransition\" for details."
+    },
+    {
+        SGX_ERROR_INVALID_ENCLAVE,
+        "Invalid enclave image.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_ENCLAVE_ID,
+        "Invalid enclave identification.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_SIGNATURE,
+        "Invalid enclave signature.",
+        NULL
+    },
+    {
+        SGX_ERROR_OUT_OF_EPC,
+        "Out of EPC memory.",
+        NULL
+    },
+    {
+        SGX_ERROR_NO_DEVICE,
+        "Invalid Intel Software Guard Extensions device.",
+        "Please make sure Intel Software Guard Extensions module is enabled in the BIOS, and install Intel Software Guard Extensions driver afterwards."
+    },
+    {
+        SGX_ERROR_MEMORY_MAP_CONFLICT,
+        "Memory map conflicted.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_METADATA,
+        "Invalid enclave metadata.",
+        NULL
+    },
+    {
+        SGX_ERROR_DEVICE_BUSY,
+        "Intel Software Guard Extensions device was busy.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_VERSION,
+        "Enclave version was invalid.",
+        NULL
+    },
+    {
+        SGX_ERROR_INVALID_ATTRIBUTE,
+        "Enclave was not authorized.",
+        NULL
+    },
+    {
+        SGX_ERROR_ENCLAVE_FILE_ACCESS,
+        "Can't open enclave file.",
+        NULL
+    },
+};
+
+/* Check error conditions for loading enclave */
+void print_error_message(sgx_status_t ret)
+{
+    size_t idx = 0;
+    size_t ttl = sizeof sgx_errlist/sizeof sgx_errlist[0];
+
+    for (idx = 0; idx < ttl; idx++) {
+        if(ret == sgx_errlist[idx].err) {
+            if(NULL != sgx_errlist[idx].sug)
+                printf("Info: %s\n", sgx_errlist[idx].sug);
+            printf("Error: %s\n", sgx_errlist[idx].msg);
+            break;
+        }
+    }
+    
+    if (idx == ttl)
+        printf("Error: Unexpected error occurred [0x%x].\n", ret);
+}
+
+
+/*
+    // Changing dir to where the executable is.
+    char absolutePath[MAX_PATH];
+    char *ptr = NULL;
+
+    ptr = realpath(dirname(argv[0]), absolutePath);
+
+    if (ptr == NULL || chdir(absolutePath) != 0)
+    	return 1;
+*/
+
+
+static sgx_status_t create_enclave(const sgx_uswitchless_config_t *us_config, 
+            sgx_launch_token_t *token, int *updated)
+{
+    sgx_status_t ret = SGX_ERROR_UNEXPECTED;
+
+    // Add switchless SGX configuration
+    if (us_config) {
+        const void* enclave_ex_p[32] = { 0 };
+        enclave_ex_p[SGX_CREATE_ENCLAVE_EX_SWITCHLESS_BIT_IDX] = (void*)us_config;
+        ret = sgx_create_enclave_ex(TESTENCLAVE_FILENAME, SGX_DEBUG_FLAG, token, updated, &global_eid, NULL, SGX_CREATE_ENCLAVE_EX_SWITCHLESS, enclave_ex_p);
+    } else {
+        ret = sgx_create_enclave(TESTENCLAVE_FILENAME, SGX_DEBUG_FLAG, token, updated, &global_eid, NULL);
+    }
+
+    if (ret != SGX_SUCCESS) {
+        print_error_message(ret);
+    }
+
+    return ret;
+}
+
+static void build_token_path(char *out_token_path) {
+    if (!out_token_path) return;
+    /* Retrieve the launch token saved by last transaction from home or current directory */
+    const char *home_dir = getpwuid(getuid())->pw_dir;
+    if (home_dir != NULL && 
+        (strlen(home_dir)+strlen("/")+sizeof(TOKEN_FILENAME)+1) <= MAX_PATH) {
+        /* compose the token path */
+        strncpy(out_token_path, home_dir, strlen(home_dir));
+        strncat(out_token_path, "/", strlen("/"));
+        strncat(out_token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME)+1);
+    } else {
+        /* if token path is too long or $HOME is NULL */
+        strncpy(out_token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME));
+    }
+}
+
+
+static FILE *fetch_launch_token(const char *token_path, sgx_launch_token_t *out_token) {
+    /* Try to open and read */
+    FILE *fp = fopen(token_path, "rb");
+    if (fp == NULL && (fp = fopen(token_path, "wb")) == NULL) {
+        printf("Warning: Failed to create/open the launch token file \"%s\".\n", token_path);
+    }
+//#ifdef DEBUG_ENC_LOAD
+    printf("token_path: %s\n", token_path);
+//#endif
+    if (fp != NULL) {
+        /* read the token from saved file */
+        size_t read_num = fread(out_token, 1, sizeof(sgx_launch_token_t), fp);
+        if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {
+            // TODO: Why "&token"?! -- memset(&token, 0x0, sizeof(sgx_launch_token_t));
+            /* if token is invalid, clear the buffer */
+            memset(&out_token, 0x0, sizeof(sgx_launch_token_t));
+            fprintf(stderr, "Warning: Invalid launch token read from \"%s\".\n", token_path);
+        }
+    }
+
+    return fp;
+}
+
+static atomic_int inited_uworkers;
+static bool pin_cpu = false;
+static cpu_set_t *masks = NULL;
+
+void worker_statup(sgx_uswitchless_worker_type_t type, sgx_uswitchless_worker_event_t event,
+                    const sgx_uswitchless_worker_stats_t *status) {
+    if (event != SGX_USWITCHLESS_WORKER_EVENT_START) return;
+    switch (type)
+    {
+    case SGX_USWITCHLESS_WORKER_TYPE_UNTRUSTED: {
+#ifdef DEBUG_ENC_LOAD
+        printf("Starting uworker\n");
+#endif
+        if (pin_cpu) {
+            int uworker_index = atomic_fetch_add(&inited_uworkers, 1);
+#ifdef DEBUG_ENC_LOAD
+            printf("Pinning uworker\n");            
+            int _t = 0;
+            for (int j=0;;j++) {
+                if(CPU_ISSET(j, &masks[uworker_index])) {
+                    printf("%d is set\n", j);
+                    _t++;
+                }
+                if (_t >= CPU_COUNT(&masks[uworker_index])) break;
+            }
+#endif
+            if (0 != sched_setaffinity(0, sizeof(cpu_set_t), &masks[uworker_index])) {
+                fprintf(stderr, "[warning] uworker affinity setting failed, ignored\n");
+            }
+        }
+        break;
+    }
+    
+    default:
+        break;
+    }
+}
+
+// todo: replace with different approach, e.g., parsing cpuinfo file
+unsigned int get_num_phys_cores() {
+    unsigned int eax=11,ebx=0,ecx=1,edx=0;
+    // eax->#phys, ebx->#virt, edx->current
+    asm volatile("cpuid"
+        : "=a" (eax),"=b" (ebx),"=c" (ecx),"=d" (edx)
+        : "0" (eax), "2" (ecx)
+        :
+    );
+#ifdef DEBUG_ENC_LOAD
+    printf("Physical cores: %d, virtual ones: %d\n", eax, ebx);
+#endif
+    return eax;
+}
+
+bool create_nginx_enclave(int untrusted_enclave_workers, int trusted_enclave_workers,
+                        bool separate_workers) {
+    /* Configuration for Switchless SGX */
+    sgx_uswitchless_config_t us_config = SGX_USWITCHLESS_CONFIG_INITIALIZER;
+    us_config.num_uworkers = untrusted_enclave_workers;
+    us_config.num_tworkers = trusted_enclave_workers;
+    us_config.callback_func[SGX_USWITCHLESS_WORKER_EVENT_START] = worker_statup;
+
+    atomic_init(&inited_uworkers, 0);
+
+    /* switchless workers should run on different cores than main application
+     * to avoid frequently preempting the enclave threads */
+    // TODO: currently we only separate the untrusted worker threads
+    int workers = untrusted_enclave_workers;
+    if (separate_workers && workers > 0) {
+        unsigned int phys_cores = get_num_phys_cores();
+        long total_cores = sysconf(_SC_NPROCESSORS_ONLN);
+        bool hyper_threading = total_cores > phys_cores ? true : false;
+#ifdef DEBUG_ENC_LOAD
+        printf("hyper_threading is: %s\n", hyper_threading ? "on" : "off");
+#endif
+
+        cpu_set_t mask;
+        CPU_ZERO(&mask);
+        int ret = sched_getaffinity(0, sizeof(mask), &mask);
+
+        if (ret == 0) {
+            int avail_phys_cores = 0;
+            // todo: currently we assume that virt.cores are offset by #physcores
+            if (hyper_threading) {
+                for (int i=0; i<phys_cores; i++) {
+                    if(CPU_ISSET(0, &mask)) {
+                        avail_phys_cores++;
+                    }
+                }
+            } else {
+                avail_phys_cores = CPU_COUNT(&mask);
+            }
+
+            /* we only separate explicitly, if application has enough physical
+            * cores available */
+            if(avail_phys_cores > workers) {
+                pin_cpu = true;
+                masks = (cpu_set_t *) malloc(sizeof(cpu_set_t) * workers);
+
+                // copy of mask
+                cpu_set_t tmp_mask;
+                CPU_ZERO(&tmp_mask);
+                CPU_XOR(&tmp_mask, &tmp_mask, &mask);
+                assert(0 != CPU_EQUAL(&mask, &tmp_mask));
+
+#ifdef DEBUG_ENC_LOAD
+                printf("Going to enable pinning for (u)workers\n");
+                printf("CPUs enabled (tmp): %d\n", CPU_COUNT(&tmp_mask));
+                int _t = 0;
+                for (int j=0;;j++) {
+                    if(CPU_ISSET(j, &tmp_mask)) {
+                        printf("%d is set\n", j);
+                        _t++;
+                    }
+                    if (_t >= CPU_COUNT(&tmp_mask)) break;
+                }
+#endif
+
+                // set 1 phys. core for each (u)worker, unset for rest of program
+                for(int i=0; i < workers; i++) {
+#ifdef DEBUG_ENC_LOAD
+                    printf("tmp_mask enabled: %d\n", CPU_COUNT(&tmp_mask));
+                    _t = 0;
+                    for (int j=0;;j++) {
+                        if(CPU_ISSET(j, &tmp_mask)) {
+                            printf("%d is set\n", j);
+                            _t++;
+                        }
+                        if (_t >= CPU_COUNT(&tmp_mask)) break;
+                    }
+#endif
+                    CPU_ZERO(&masks[i]);
+
+                    // find next set cpu, and clear it
+                    for(int c=0; c < total_cores; c++) {
+                        if(CPU_ISSET(c, &tmp_mask)) {
+#ifdef DEBUG_ENC_LOAD
+                            printf("CPU %d is set in tmp_mask\n", c);
+#endif
+                            CPU_CLR(c, &tmp_mask);
+                            CPU_SET(c, &masks[i]);
+                            if (hyper_threading) {
+                                // todo: usually the offset in Linux is phys_core for virt. ones
+                                CPU_CLR((c + phys_cores)%total_cores, &tmp_mask);
+                            }
+                            break;
+                        }
+                    }
+                }
+
+#ifdef DEBUG_ENC_LOAD
+                printf("tmp_mask enabled: %d\n", CPU_COUNT(&tmp_mask));
+                _t = 0;
+                for (int j=0;;j++) {
+                    if(CPU_ISSET(j, &tmp_mask)) {
+                        printf("%d is set\n", j);
+                        _t++;
+                    }
+                    if (_t >= CPU_COUNT(&tmp_mask)) break;
+                }
+#endif
+                // Update proc mask of application to remaining cores
+                if (0 != sched_setaffinity(0, sizeof(tmp_mask), &tmp_mask)) {
+                    fprintf(stderr, "Failed to updated CPU mask of main program, disabled pin\n");
+                    pin_cpu = false;
+                    free(masks);
+                }
+            }
+        }
+    }
+
+    char token_path[MAX_PATH] = {'\0'};
+    sgx_launch_token_t token = {0};
+    build_token_path(token_path);
+    if (!token_path) {
+        fprintf(stderr, "Failed to build token path\n");
+        return false;
+    }
+    FILE *token_file = fetch_launch_token(token_path, &token);
+
+    int updated = 0;
+    sgx_status_t ret = -1; // TODO: error constant
+    if (untrusted_enclave_workers == 0 && trusted_enclave_workers == 0) {
+        ret = create_enclave(NULL, &token, &updated);
+    } else {
+        ret = create_enclave(&us_config, &token, &updated);
+    } 
+    
+    /* Safe/Update launch token */
+    if (token_file != NULL) {
+        if (ret == SGX_SUCCESS && updated == 1) {
+            /* reopen the file with write capablity */
+            token_file = freopen(token_path, "wb", token_file);
+            if (token_file != NULL) {
+                size_t write_num = fwrite(token, 1, sizeof(sgx_launch_token_t), token_file);
+                if (write_num != sizeof(sgx_launch_token_t))
+                    fprintf(stderr, "Warning: Failed to save launch token\n");
+            }
+        } else {
+            fclose(token_file);
+        }
+    }
+
+    return true;
+}
+
+// Destroy the enclave
+sgx_status_t shutdown_nginx_enclave() {
+#ifdef DEBUG_ENC_LOAD
+    printf("Now destroying the enclave\n");
+#endif
+    sgx_status_t res = sgx_destroy_enclave(global_eid);
+    if (res != SGX_SUCCESS) fprintf(stderr, "Enclave destruction failed\n");
+    if (pin_cpu) free(masks);
+    return res;
+}
diff --git a/src/os/seng/untrusted/nginx/enclave_load.h b/src/os/seng/untrusted/nginx/enclave_load.h
new file mode 100644
index 0000000..9c8af7b
--- /dev/null
+++ b/src/os/seng/untrusted/nginx/enclave_load.h
@@ -0,0 +1,30 @@
+#ifndef _ENCLAVE_LOAD_H_INCLUDED_
+#define _ENCLAVE_LOAD_H_INCLUDED_
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE // for CPU_* macros
+#endif
+
+#include "sgx_error.h"       /* sgx_status_t */
+#include "sgx_eid.h"     /* sgx_enclave_id_t */
+
+#include <stdbool.h>
+
+# define TOKEN_FILENAME   "ngx_seng_enclave.token"
+# define TESTENCLAVE_FILENAME "./sbin/nginx_signed_enclave.so"
+
+extern sgx_enclave_id_t global_eid;    /* global enclave id */
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+bool create_nginx_enclave(int untrusted_enclave_workers, int trusted_enclave_workers,
+                        bool separate_workers);
+sgx_status_t shutdown_nginx_enclave();
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/src/os/seng/untrusted/nginx/u_nginx.c b/src/os/seng/untrusted/nginx/u_nginx.c
new file mode 100644
index 0000000..217d95d
--- /dev/null
+++ b/src/os/seng/untrusted/nginx/u_nginx.c
@@ -0,0 +1,34 @@
+#include <stdio.h>
+#include "u_nginx.h"
+#include "enclave_load.h" // create_nginx_enclave, shutdown_nginx_enclave
+#include "ngx_seng_u.h"
+
+
+extern char **environ;
+
+// The untrusted stub which spawns and calls into the nginx enclave
+int main(int argc, char **argv)
+{
+    /* NOTE:
+     * signal handlers for {SIGSEGV, SIGFPE, SIGILL, SIGBUS, SIGTRAP}
+     * must be registered before creating the enclave to avoid overwriting
+     * the signal handler of the SGX urts
+     */ 
+    // None of those is used by current NGINX signal handlers.
+
+    if (!create_nginx_enclave(2, 0, true)) {
+        fprintf(stderr, "Failed to create the NGINX enclave\n");
+        return -1;
+    }
+
+    int exit_value = -1;
+    sgx_status_t status = ecall_run_nginx(global_eid, &exit_value, argc, argv, environ);
+
+    if (status != SGX_SUCCESS) {
+        fprintf(stderr, "Failed to call into NGINX enclave, or enclave crashed (status: %d)\n", status);
+        exit_value = -1;
+    }
+
+    status = shutdown_nginx_enclave();
+    return exit_value;
+}
diff --git a/src/os/seng/untrusted/nginx/u_nginx.h b/src/os/seng/untrusted/nginx/u_nginx.h
new file mode 100644
index 0000000..0e6383e
--- /dev/null
+++ b/src/os/seng/untrusted/nginx/u_nginx.h
@@ -0,0 +1,26 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _TNGINX_H_INCLUDED_
+#define _TNGINX_H_INCLUDED_
+
+
+#define nginx_version      1010003
+#define NGINX_VERSION      "1.10.3"
+#define NGINX_VER          "nginx/" NGINX_VERSION
+
+#ifdef NGX_BUILD
+#define NGINX_VER_BUILD    NGINX_VER " (" NGX_BUILD ")"
+#else
+#define NGINX_VER_BUILD    NGINX_VER
+#endif
+
+#define NGINX_VAR          "NGINX"
+#define NGX_OLDPID_EXT     ".oldbin"
+
+
+#endif /* _NGINX_H_INCLUDED_ */
diff --git a/src/os/seng/untrusted/u_ngx_files.c b/src/os/seng/untrusted/u_ngx_files.c
new file mode 100644
index 0000000..c05616e
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_files.c
@@ -0,0 +1,146 @@
+#include "u_ngx_files.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <glob.h>
+#include <fcntl.h>
+#include <sys/file.h>
+
+#include <unistd.h>
+#include <dirent.h>
+#include <assert.h>
+#include <sys/uio.h>
+
+#include <errno.h>
+
+//#define DEBUG_FILE_U
+
+int ocall_file_open(const char *pathname, int flags, unsigned int mode) {
+#ifdef DEBUG_FILE_U
+    int ret = open(pathname, flags, mode);
+    int tmp = errno;
+    printf("ocall_file_open(%s, %d, %u) --> %d (%s)\n", pathname, flags, mode, ret, strerror(errno));
+    errno = tmp;
+    return ret;
+#else
+    return open(pathname, flags, mode);
+#endif
+}
+int ocall_file_close(int fd) {
+    return close(fd);
+}
+long ocall_file_read(int fd, void *buf, size_t count) {
+#ifdef DEBUG_FILE_U
+    ssize_t ret = read(fd, buf, count);
+    int tmp = errno;
+    printf("ocall_file_read(%d, %p, %ld) --> %ld (%s)\n", fd, buf, count, ret, strerror(errno));
+    errno = tmp;
+    return ret;
+#else
+    return read(fd, buf, count);
+#endif
+}
+long ocall_file_write(int fd, const void *buf, size_t count) {
+    return write(fd, buf, count);
+}
+
+
+int ocall_unlink(const char *pathname) {
+    return unlink(pathname);
+}
+int ocall_rename(const char *oldpath, const char *newpath) {
+    return rename(oldpath, newpath);
+}
+int ocall_chmod(const char *pathname, unsigned int mode) {
+    return chmod(pathname, mode);
+}
+int ocall_utimes(const char *filename, const struct seng_timeval times[2]){
+    assert(sizeof(struct seng_timeval) == sizeof(struct timeval));
+    return utimes(filename, (const struct timeval *)times);
+}
+
+
+char *ocall_realpath(const char *path, char *resolved_path) {
+    return realpath(path, resolved_path);
+}
+char *ocall_getcwd(char *buf, size_t size) {
+    return getcwd(buf, size);
+}
+
+
+int ocall_dup2(int oldfd, int newfd) {
+    return dup2(oldfd, newfd);
+}
+
+long int ocall_lseek(int fd, long int offset, int whence) {
+    return lseek(fd, offset, whence);
+}
+
+// writev -- nested pointers
+long ocall_file_writev(int fd, const struct seng_iovec *iov, int iovcnt) {
+    assert(sizeof(struct seng_iovec) == sizeof(struct iovec));
+    return writev(fd, (struct iovec *)iov, iovcnt);
+}
+
+int ocall_stat(const char *pathname, struct seng_stat_t *statbuf) {
+    assert(sizeof(struct seng_stat_t) == sizeof(struct stat));
+    // TODO: use 'struct stat' and copy field-wise
+    return stat(pathname, (struct stat *) statbuf);
+}
+int ocall_fstat(int fd, struct seng_stat_t *statbuf) {
+    assert(sizeof(struct seng_stat_t) == sizeof(struct stat));
+    // TODO: use 'struct stat' and copy field-wise
+    return fstat(fd, (struct stat *) statbuf);
+}
+int ocall_lstat(const char *pathname, struct seng_stat_t *statbuf) {
+    assert(sizeof(struct seng_stat_t) == sizeof(struct stat));
+    // TODO: use 'struct stat' and copy field-wise
+    return lstat(pathname, (struct stat *) statbuf);
+}
+
+
+void *ocall_opendir(const char *name) {
+    return opendir(name);
+}
+int ocall_closedir(void *dirp) {
+    return closedir(dirp);
+}
+int ocall_mkdir(const char *pathname, unsigned int mode) {
+    return mkdir(pathname, mode);
+}
+int ocall_rmdir(const char *pathname) {
+    return rmdir(pathname);
+}
+
+struct seng_dirent *ocall_readdir(void *dirp) {
+    assert(sizeof(struct seng_dirent) == sizeof(struct dirent));
+    return (struct seng_dirent *)readdir((DIR *)dirp);
+}
+
+// simplified/tailored version
+int ocall_glob(const char *pattern, seng_glob_t *pglob) {
+    // TODO: do types match?
+    return glob(pattern, 0, NULL, (glob_t *)pglob);
+}
+void ocall_globfree(seng_glob_t *pglob) {
+    // TODO: do types match?
+    return globfree((glob_t *)pglob);
+}
+// --> user by "ngx_conf_include"
+
+// fcntl -- TODO: how variable #args?!
+// int ocall_fcntl(int fd, int cmd, ... );
+int ocall_file_fcntl3(int fd, int cmd, int arg) {
+    return fcntl(fd, cmd, arg);
+}
+
+int ocall_file_fcntl2(int fd, int cmd) {
+    return fcntl(fd, cmd);
+}
+
+int ocall_flock_operation(int fd, int cmd, struct seng_flock *flock) {
+    assert(sizeof(struct seng_flock) == sizeof(struct flock));
+    return fcntl(fd, cmd, (struct flock *)flock);
+}
diff --git a/src/os/seng/untrusted/u_ngx_files.h b/src/os/seng/untrusted/u_ngx_files.h
new file mode 100644
index 0000000..0ef8a44
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_files.h
@@ -0,0 +1,67 @@
+#ifndef _U_NGX_FILES_H_INCLUDED_
+#define _U_NGX_FILES_H_INCLUDED_
+
+#include "ngx_seng_u.h"
+
+// Extracted from ngx_files.h
+
+// file -- open, close, read, write
+int ocall_file_open(const char *pathname, int flags, unsigned int mode);
+int ocall_file_close(int fd);
+long ocall_file_read(int fd, void *buf, size_t count);
+long ocall_file_write(int fd, const void *buf, size_t count);
+
+// unlink, rename, chmod, utimes
+int ocall_unlink(const char *pathname);
+int ocall_rename(const char *oldpath, const char *newpath);
+int ocall_chmod(const char *pathname, unsigned int mode);
+int ocall_utimes(const char *filename, const struct seng_timeval times[2]);
+
+// realpath, getcwd
+char *ocall_realpath(const char *path, char *resolved_path);
+char *ocall_getcwd(char *buf, size_t size);
+
+// dup2
+int ocall_dup2(int oldfd, int newfd);
+
+// lseek
+long int ocall_lseek(int fd, long int offset, int whence);
+
+// writev -- nested pointers
+long ocall_file_writev(int fd, const struct seng_iovec *iov, int iovcnt);
+
+// stat, fstat, lstat
+int ocall_stat(const char *pathname, struct seng_stat_t *statbuf);
+int ocall_fstat(int fd, struct seng_stat_t *statbuf);
+int ocall_lstat(const char *pathname, struct seng_stat_t *statbuf);
+
+// opendir, closedir, mkdir, rmdir
+void *ocall_opendir(const char *name);
+int ocall_closedir(void *dirp);
+int ocall_mkdir(const char *pathname, unsigned int mode);
+int ocall_rmdir(const char *pathname);
+
+// readdir
+struct seng_dirent *ocall_readdir(void *dirp);
+
+int ocall_glob(const char *pattern, seng_glob_t *pglob);
+void ocall_globfree(seng_glob_t *pglob);
+// --> user by "ngx_conf_include"
+
+// fcntl -- TODO: how variable #args?!
+// int ocall_fcntl(int fd, int cmd, ... );
+int ocall_file_fcntl3(int fd, int cmd, int arg);
+int ocall_file_fcntl2(int fd, int cmd);
+
+int ocall_flock_operation(int fd, int cmd, struct seng_flock *flock);
+
+// optional: openat, fstatat
+// optional: pread
+// optional: pwrite
+// optional: pwritev
+
+// NGX_CREATE_FILE_MAPPING --> WE CAN NOT(!) SUPPORT THAT EASILY !!
+// -> ftruncate, mmap (READ|WRITE, SHARED), munmap
+// ==> disabled http_geo_module -- only current user
+
+#endif /* _U_NGX_FILES_H_INCLUDED_ */
diff --git a/src/os/seng/untrusted/u_ngx_process.c b/src/os/seng/untrusted/u_ngx_process.c
new file mode 100644
index 0000000..6b0f360
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_process.c
@@ -0,0 +1,166 @@
+#include "u_ngx_process.h"
+
+#include <stdio.h>
+
+typedef struct {
+    int     signo;
+    char   *signame;
+    char   *name;
+    void  (*handler)(int signo);
+} ngx_signal_t;
+
+sig_atomic_t    ngx_quit;
+sig_atomic_t    ngx_terminate;
+sig_atomic_t    ngx_reconfigure;
+sig_atomic_t    ngx_reopen;
+
+static void ngx_signal_handler(int signo);
+
+ngx_signal_t  signals[] = {
+    { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),
+      "SIG" ngx_value(NGX_RECONFIGURE_SIGNAL),
+      "reload",
+      ngx_signal_handler },
+
+    { ngx_signal_value(NGX_REOPEN_SIGNAL),
+      "SIG" ngx_value(NGX_REOPEN_SIGNAL),
+      "reopen",
+      ngx_signal_handler },
+
+    { ngx_signal_value(NGX_NOACCEPT_SIGNAL),
+      "SIG" ngx_value(NGX_NOACCEPT_SIGNAL),
+      "",
+      ngx_signal_handler },
+
+    { ngx_signal_value(NGX_TERMINATE_SIGNAL),
+      "SIG" ngx_value(NGX_TERMINATE_SIGNAL),
+      "stop",
+      ngx_signal_handler },
+
+    { ngx_signal_value(NGX_SHUTDOWN_SIGNAL),
+      "SIG" ngx_value(NGX_SHUTDOWN_SIGNAL),
+      "quit",
+      ngx_signal_handler },
+
+    { ngx_signal_value(NGX_CHANGEBIN_SIGNAL),
+      "SIG" ngx_value(NGX_CHANGEBIN_SIGNAL),
+      "",
+      ngx_signal_handler },
+
+    { SIGALRM, "SIGALRM", "", ngx_signal_handler },
+
+    { SIGINT, "SIGINT", "", ngx_signal_handler },
+
+    { SIGIO, "SIGIO", "", ngx_signal_handler },
+
+    { SIGCHLD, "SIGCHLD", "", ngx_signal_handler },
+
+    { SIGSYS, "SIGSYS, SIG_IGN", "", SIG_IGN },
+
+    { SIGPIPE, "SIGPIPE, SIG_IGN", "", SIG_IGN },
+
+    { 0, NULL, "", NULL }
+};
+
+long int
+ocall_init_signal_atomics(struct seng_ngx_sigatomics *atomics) {
+    if (!atomics) return NGX_ERROR;
+    atomics->uptr_quit = &ngx_quit;
+    atomics->uptr_terminate = &ngx_terminate;
+    atomics->uptr_reconfigure = &ngx_reconfigure;
+    atomics->uptr_reopen = &ngx_reopen;
+    return NGX_OK;
+}
+
+long int
+ocall_ngx_init_signals()
+{
+    ngx_signal_t      *sig;
+    struct sigaction   sa;
+
+    for (sig = signals; sig->signo != 0; sig++) {
+        ngx_memzero(&sa, sizeof(struct sigaction));
+        sa.sa_handler = sig->handler;
+        sigemptyset(&sa.sa_mask);
+        if (sigaction(sig->signo, &sa, NULL) == -1) {
+            // TODO: write to log
+            fprintf(stderr, "sigaction(%s) failed", sig->signame);
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_signal_handler(int signo)
+{
+    char            *action;
+    ngx_err_t        err;
+    ngx_signal_t    *sig;
+
+    err = ngx_errno;
+
+    for (sig = signals; sig->signo != 0; sig++) {
+        if (sig->signo == signo) {
+            break;
+        }
+    }
+
+/* TODO: if we move time variables outside enclave, this would be rather easy
+    ngx_time_sigsafe_update();
+*/
+
+    action = "";
+
+    // only support NGX_PROCESS_SINGLE at the moment
+    //switch (ngx_process) { ... }
+    switch (signo) {
+
+    case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):
+        ngx_quit = 1;
+        action = ", shutting down";
+        break;
+
+    case ngx_signal_value(NGX_TERMINATE_SIGNAL):
+    case SIGINT:
+        ngx_terminate = 1;
+        action = ", exiting";
+        break;
+
+    case ngx_signal_value(NGX_NOACCEPT_SIGNAL):
+        // not needed in no-master, single process mode
+        break;
+
+    case ngx_signal_value(NGX_RECONFIGURE_SIGNAL):
+        ngx_reconfigure = 1;
+        action = ", reconfiguring";
+        break;
+
+    case ngx_signal_value(NGX_REOPEN_SIGNAL):
+        ngx_reopen = 1;
+        action = ", reopening logs";
+        break;
+
+    case ngx_signal_value(NGX_CHANGEBIN_SIGNAL):
+        // not needed in no-master, single process mode
+        break;
+
+    case SIGALRM:
+        // not needed in no-master, single process mode
+        break;
+
+    case SIGIO:
+        // not needed in no-master, single process mode
+        break;
+
+    case SIGCHLD:
+        // not needed in no-master, single process mode
+        break;
+    }
+
+    // TODO: write to log instead
+    fprintf(stderr, "signal %d (%s) received%s", signo, sig->signame, action);
+    ngx_set_errno(err);
+}
diff --git a/src/os/seng/untrusted/u_ngx_process.h b/src/os/seng/untrusted/u_ngx_process.h
new file mode 100644
index 0000000..fda671f
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_process.h
@@ -0,0 +1,51 @@
+#ifndef _U_NGX_PROCESS_H_INCLUDED_
+#define _U_NGX_PROCESS_H_INCLUDED_
+
+#include <signal.h>
+#include <errno.h>
+#include <string.h>
+#include "ngx_seng_u.h"
+
+#define ngx_errno errno
+#define ngx_set_errno(err)         errno = err
+#define ngx_memzero(buf, n) memset(buf, 0, n)
+typedef int               ngx_err_t;
+
+#define  NGX_OK          0
+#define  NGX_ERROR      -1
+
+#define NGX_PROCESS_SINGLE      0
+#define NGX_PROCESS_MASTER      1
+#define NGX_PROCESS_SIGNALLER   2
+#define NGX_PROCESS_WORKER      3
+#define NGX_PROCESS_HELPER      4
+
+// from ngx config header
+#define NGX_RECONFIGURE_SIGNAL HUP
+#define NGX_SHUTDOWN_SIGNAL     QUIT
+#define NGX_TERMINATE_SIGNAL    TERM
+#define NGX_NOACCEPT_SIGNAL     WINCH
+#define NGX_RECONFIGURE_SIGNAL  HUP
+
+#if (NGX_LINUXTHREADS)
+    #define NGX_REOPEN_SIGNAL        INFO
+    #define NGX_CHANGEBIN_SIGNAL     XCPU
+#else
+    #define NGX_REOPEN_SIGNAL        USR1
+    #define NGX_CHANGEBIN_SIGNAL     USR2
+#endif
+
+#define ngx_signal_helper(n) SIG##n
+#define ngx_signal_value(n) ngx_signal_helper(n)
+
+#define ngx_value_helper(n)     #n
+#define ngx_value(n)            ngx_value_helper(n)
+
+extern sig_atomic_t    ngx_quit;
+extern sig_atomic_t    ngx_terminate;
+extern sig_atomic_t    ngx_reconfigure;
+extern sig_atomic_t    ngx_reopen;
+
+long int ocall_ngx_init_signals(void);
+
+#endif /* _U_NGX_PROCESS_H_INCLUDED_ */
diff --git a/src/os/seng/untrusted/u_ngx_process_user.c b/src/os/seng/untrusted/u_ngx_process_user.c
new file mode 100644
index 0000000..0606dc2
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_process_user.c
@@ -0,0 +1,38 @@
+#include "u_ngx_process_user.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <pwd.h>
+#include <grp.h>
+#include <assert.h>
+
+unsigned int ocall_getpid(void) {
+    return getpid();
+}
+unsigned int ocall_geteuid(void) {
+    return geteuid();
+}
+unsigned int ocall_getuid(void) {
+    return getuid();
+}
+
+char * ocall_getenv(const char *name) {
+    return getenv(name);
+}
+
+struct seng_passwd *ocall_getpwnam(const char *name) {
+    assert(sizeof(struct seng_passwd) == sizeof(struct passwd));
+    return (struct seng_passwd *)getpwnam(name);
+}
+struct seng_group *ocall_getgrnam(const char *name) {
+    assert(sizeof(struct seng_group) == sizeof(struct group));
+    return (struct seng_group *) getgrnam(name);
+}
+
+int ocall_chown(const char *pathname, unsigned int owner, unsigned int group) {
+    return chown(pathname, owner, group);
+}
+
+int ocall_gethostname(char *name, size_t len) {
+    return gethostname(name, len);
+}
\ No newline at end of file
diff --git a/src/os/seng/untrusted/u_ngx_process_user.h b/src/os/seng/untrusted/u_ngx_process_user.h
new file mode 100644
index 0000000..0053141
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_process_user.h
@@ -0,0 +1,19 @@
+#ifndef _U_NGX_PROC_USER_H_INCLUDED_
+#define _U_NGX_PROC_USER_H_INCLUDED_
+
+#include "ngx_seng_u.h"
+
+unsigned int ocall_getpid(void);
+unsigned int ocall_geteuid(void);
+unsigned int ocall_getuid(void);
+
+char * ocall_getenv(const char *name);
+
+struct seng_passwd *ocall_getpwnam(const char *name);
+struct seng_group *ocall_getgrnam(const char *name);
+
+int ocall_chown(const char *pathname, unsigned int owner, unsigned int group);
+
+int ocall_gethostname(char *name, size_t len);
+
+#endif /* _U_NGX_PROC_USER_H_INCLUDED_ */
\ No newline at end of file
diff --git a/src/os/seng/untrusted/u_ngx_rlimit.c b/src/os/seng/untrusted/u_ngx_rlimit.c
new file mode 100644
index 0000000..942da16
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_rlimit.c
@@ -0,0 +1,8 @@
+#include "u_ngx_rlimit.h"
+#include <sys/resource.h>
+#include <assert.h>
+
+int ocall_getrlimit(int resource, struct seng_rlimit *rlim) {
+    assert(sizeof(struct seng_rlimit) == sizeof(struct rlimit));
+    return getrlimit(resource, (struct rlimit *)rlim);
+}
\ No newline at end of file
diff --git a/src/os/seng/untrusted/u_ngx_rlimit.h b/src/os/seng/untrusted/u_ngx_rlimit.h
new file mode 100644
index 0000000..6175b64
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_rlimit.h
@@ -0,0 +1,8 @@
+#ifndef _U_NGX_RLIMIT_H_INCLUDED_
+#define _U_NGX_RLIMIT_H_INCLUDED_
+
+#include "ngx_seng_u.h"
+
+int ocall_getrlimit(int resource, struct seng_rlimit *rlim);
+
+#endif
\ No newline at end of file
diff --git a/src/os/seng/untrusted/u_ngx_time.c b/src/os/seng/untrusted/u_ngx_time.c
new file mode 100644
index 0000000..76e86bd
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_time.c
@@ -0,0 +1,25 @@
+#include "u_ngx_time.h"
+
+#include <unistd.h>
+#include <time.h>
+#include <sys/time.h>
+#include <assert.h>
+
+struct seng_tm *ocall_localtime(const long int *timep) {
+    assert (sizeof(struct seng_tm) == sizeof(struct tm));
+    return (struct seng_tm *)localtime((const time_t *) timep);
+}
+unsigned int ocall_sleep(unsigned int seconds) {
+    return sleep(seconds);
+}
+int ocall_usleep(unsigned int usec) {
+    return usleep(usec);
+}
+long int ocall_mktime(struct seng_tm *tm) {
+    assert(sizeof(struct seng_tm) == sizeof(struct tm));
+    return mktime((struct tm *)tm);
+}
+int ocall_gettimeofday_no_zone(struct seng_timeval *tv) {
+    assert (sizeof(struct seng_timeval) == sizeof(struct timeval));
+    return gettimeofday((struct timeval *)tv, NULL);
+}
\ No newline at end of file
diff --git a/src/os/seng/untrusted/u_ngx_time.h b/src/os/seng/untrusted/u_ngx_time.h
new file mode 100644
index 0000000..9cfc1d6
--- /dev/null
+++ b/src/os/seng/untrusted/u_ngx_time.h
@@ -0,0 +1,13 @@
+#ifndef _U_NGX_TIME_H_INCLUDED_
+#define _U_NGX_TIME_H_INCLUDED_
+
+#include "ngx_seng_u.h"
+
+struct seng_tm *ocall_localtime(const long int *timep);
+unsigned int socall_sleep(unsigned int seconds);
+int ocall_usleep(unsigned int usec);
+
+long int ocall_mktime(struct seng_tm *tm);
+int ocall_gettimeofday_no_zone(struct seng_timeval *tv);
+
+#endif /* _U_NGX_TIME_H_INCLUDED_ */
diff --git a/src/os/unix/.gitignore b/src/os/unix/.gitignore
new file mode 100644
index 0000000..17dba6a
--- /dev/null
+++ b/src/os/unix/.gitignore
@@ -0,0 +1,4 @@
+ngx_seng_t.c
+ngx_seng_t.h
+ngx_seng_u.c
+ngx_seng_u.h
